<!DOCTYPE html>
<!-- VERSION: 2024-01-01-v3 - Force cache refresh -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>FX Option P&L Calculator</title>
    <!-- SheetJS library for Excel parsing -->
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <!-- Plotly.js for interactive charts -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
/* ============================================
   PROFESSIONAL DARK TERMINAL THEME
   ============================================ */

/* Color Variables */
:root {
    /* Backgrounds */
    --bg-main: #0a0a0a;
    --bg-elevated: #141414;
    --bg-input: #1a1a1a;
    --bg-hover: #1f1f1f;
    --bg-gradient: linear-gradient(135deg, #141414 0%, #0f0f0f 100%);
    --bg-gradient-subtle: linear-gradient(180deg, rgba(20, 20, 20, 0.8) 0%, rgba(10, 10, 10, 0.9) 100%);
    
    /* Text */
    --text-primary: #e5e5e5;
    --text-secondary: #a3a3a3;
    --text-muted: #737373;
    --text-white: #ffffff;
    
    /* Semantic Colors */
    --green: #22c55e;
    --green-light: #4ade80;
    --green-dark: #16a34a;
    --red: #ef4444;
    --red-light: #f87171;
    --red-dark: #dc2626;
    --cyan: #06b6d4;
    --cyan-light: #22d3ee;
    --cyan-dark: #0891b2;
    --cyan-glow: rgba(6, 182, 212, 0.3);
    --gray: #6b7280;
    --yellow: #eab308;
    --yellow-light: #facc15;
    --orange: #f97316;
    
    /* Borders */
    --border: #262626;
    --border-strong: #404040;
    --border-subtle: #1a1a1a;
    --border-glow: rgba(6, 182, 212, 0.2);
    
    /* Shadows */
    --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
    --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.4);
    --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.5);
    --shadow-xl: 0 20px 25px rgba(0, 0, 0, 0.6);
    --shadow-glow: 0 0 20px rgba(6, 182, 212, 0.2);
    --shadow-glow-strong: 0 0 30px rgba(6, 182, 212, 0.4);
    
    /* Fonts */
    --font-sans: 'Inter', -apple-system, sans-serif;
    --font-mono: 'JetBrains Mono', monospace;
}

/* Base Reset */
*, *::before, *::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: var(--font-sans);
    background: var(--bg-main);
    color: var(--text-primary);
    line-height: 1.5;
    -webkit-font-smoothing: antialiased;
    animation: fadeInBody 0.4s ease;
}

@keyframes fadeInBody {
    from {
        opacity: 0;
    }
    to {
        opacity: 1;
    }
}

/* Typography */
h1 { 
    font-size: 28px; 
    font-weight: 700; 
    color: var(--text-white); 
    margin-bottom: 12px; 
    letter-spacing: -0.02em;
    line-height: 1.2;
}
h2 { 
    font-size: 22px; 
    font-weight: 600; 
    color: var(--text-white); 
    margin-bottom: 16px; 
    letter-spacing: -0.01em;
    line-height: 1.3;
}
h3 { 
    font-size: 18px; 
    font-weight: 600; 
    color: var(--text-white); 
    margin-bottom: 12px; 
    line-height: 1.4;
}
h4 { 
    font-size: 14px; 
    font-weight: 600; 
    color: var(--text-secondary); 
    margin-bottom: 10px; 
    letter-spacing: 0.01em;
    line-height: 1.5;
}
p { 
    font-size: 14px; 
    color: var(--text-secondary); 
    margin-bottom: 12px; 
    line-height: 1.6;
}

/* Layout */
.container {
    max-width: 1800px;
    margin: 0 auto;
    padding: 24px;
}

/* Header */
.app-header {
    background: var(--bg-elevated);
    background-image: var(--bg-gradient);
    border-bottom: 1px solid var(--border);
    position: sticky;
    top: 0;
    z-index: 100;
    box-shadow: var(--shadow-md);
    backdrop-filter: blur(10px);
}

.header-container {
    max-width: 1800px;
    margin: 0 auto;
    padding: 20px 24px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.app-title {
    font-size: 22px;
    font-weight: 700;
    color: var(--text-white);
    display: flex;
    align-items: center;
    gap: 12px;
    letter-spacing: -0.01em;
}

.app-subtitle {
    font-size: 12px;
    color: var(--text-muted);
    margin-top: 4px;
    letter-spacing: 0.05em;
}

/* Tab Navigation */
.tab-navigation {
    max-width: 1800px;
    margin: 0 auto;
    padding: 0 24px;
    display: flex;
    gap: 0;
    background: var(--bg-elevated);
    border-bottom: 1px solid var(--border);
}

.tab-button {
    padding: 14px 28px;
    background: transparent;
    border: none;
    color: var(--text-secondary);
    font-family: var(--font-sans);
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    border-bottom: 2px solid transparent;
    transition: all 0.2s ease;
    position: relative;
}

.tab-button::before {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 2px;
    background: var(--cyan);
    transform: scaleX(0);
    transition: transform 0.2s ease;
    z-index: 1;
}

.tab-button:hover::before {
    transform: scaleX(1);
}

.tab-button:hover {
    color: var(--text-white);
    background: rgba(6, 182, 212, 0.08);
}

.tab-button.active {
    color: var(--text-white);
    background: rgba(6, 182, 212, 0.1);
}

.tab-button.active::before {
    transform: scaleX(1);
}

.tab-content {
    display: none;
    max-width: 1800px;
    margin: 0 auto;
    padding: 24px;
    animation: fadeInContent 0.3s ease;
}

@keyframes fadeInContent {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.tab-content.active {
    display: block;
}

/* Cards & Sections */
.card,
.section {
    background: var(--bg-elevated);
    background-image: var(--bg-gradient-subtle);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 20px;
    margin-bottom: 24px;
    box-shadow: var(--shadow-md);
    transition: all 0.2s ease;
}

.card:hover,
.section:hover {
    box-shadow: var(--shadow-lg);
    border-color: var(--border-strong);
    transform: translateY(-1px);
}

.card-header,
.section-header {
    font-size: 16px;
    font-weight: 600;
    color: var(--text-white);
    padding-bottom: 12px;
    border-bottom: 1px solid var(--border);
    margin-bottom: 20px;
    letter-spacing: 0.01em;
}

/* Forms */
.input-section {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 20px;
    margin-bottom: 24px;
}

.input-group {
    display: flex;
    flex-direction: column;
    transition: transform 0.2s ease;
}

.input-group:focus-within {
    transform: translateY(-1px);
}

label {
    font-size: 12px;
    font-weight: 500;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    display: block;
    margin-bottom: 6px;
}

input[type="text"],
input[type="number"],
input[type="date"],
input[type="time"],
select,
textarea {
    font-family: var(--font-mono);
    font-size: 13px;
    padding: 10px 14px;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text-primary);
    width: 100%;
    transition: all 0.2s ease;
    box-shadow: var(--shadow-sm);
}

input:focus,
select:focus,
textarea:focus {
    outline: none;
    border-color: var(--cyan);
    box-shadow: var(--shadow-md), 0 0 0 3px var(--cyan-glow);
    background: var(--bg-elevated);
}

input:hover,
select:hover,
textarea:hover {
    border-color: var(--border-strong);
}

input[type="checkbox"],
input[type="radio"] {
    width: 16px;
    height: 16px;
    accent-color: var(--cyan);
    cursor: pointer;
}

/* Buttons */
button,
.btn {
    font-family: var(--font-sans);
    font-size: 14px;
    font-weight: 500;
    padding: 12px 24px;
    background: var(--bg-elevated);
    color: var(--text-white);
    border: 1px solid var(--border-strong);
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    box-shadow: var(--shadow-sm);
    position: relative;
    overflow: hidden;
}

button:hover,
.btn:hover {
    background: var(--bg-hover);
    border-color: var(--cyan);
    box-shadow: var(--shadow-md), var(--shadow-glow);
    transform: translateY(-1px);
}

button:active,
.btn:active {
    transform: translateY(0);
    box-shadow: var(--shadow-sm);
}

button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none !important;
}

button:disabled::before {
    display: none;
}

.btn-primary {
    background: var(--bg-elevated);
    border-color: var(--cyan);
    box-shadow: var(--shadow-sm), 0 0 0 1px var(--cyan-glow);
}

.btn-primary:hover {
    box-shadow: var(--shadow-md), var(--shadow-glow);
    border-color: var(--cyan-light);
}

.btn-secondary,
button.secondary {
    background: var(--bg-input);
    border-color: var(--border);
    color: var(--text-secondary);
}

.btn-secondary:hover,
button.secondary:hover {
    color: var(--text-primary);
    border-color: var(--border-strong);
    background: var(--bg-elevated);
}

.btn-large {
    padding: 16px 32px;
    font-size: 16px;
    font-weight: 600;
}

.btn-sm {
    padding: 8px 16px;
    font-size: 12px;
}

/* Upload Area */
.upload-area,
.drop-zone {
    padding: 48px;
    background: var(--bg-elevated);
    background-image: var(--bg-gradient-subtle);
    border: 2px dashed var(--border);
    border-radius: 8px;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: var(--shadow-sm);
}

.upload-area:hover,
.drop-zone:hover {
    border-color: var(--cyan);
    background: var(--bg-hover);
    box-shadow: var(--shadow-md), var(--shadow-glow);
    transform: translateY(-2px);
}

.upload-area.drag-over,
.drop-zone.drag-over {
    border-color: var(--cyan-light);
    background: rgba(6, 182, 212, 0.1);
    box-shadow: var(--shadow-lg), var(--shadow-glow-strong);
    transform: scale(1.02);
}

/* Tables */
table,
.data-table {
    width: 100%;
    border-collapse: collapse;
    background: var(--bg-main);
    font-size: 13px;
    border-radius: 8px;
    overflow: hidden;
}

thead {
    background: var(--bg-elevated);
    background-image: var(--bg-gradient-subtle);
    position: sticky;
    top: 0;
    z-index: 10;
    box-shadow: var(--shadow-sm);
}

th {
    padding: 14px 16px;
    text-align: left;
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--text-muted);
    border-bottom: 2px solid var(--border);
    transition: background-color 0.2s ease;
}

th.numeric-header {
    text-align: right;
}

th.sortable-header:hover {
    background: var(--bg-hover);
    color: var(--text-secondary);
    cursor: pointer;
}

tbody tr {
    border-bottom: 1px solid var(--border-subtle);
    transition: all 0.2s ease;
}

tbody tr:nth-child(even) {
    background: rgba(20, 20, 20, 0.3);
}

tbody tr:hover {
    background: var(--bg-elevated);
    transform: scale(1.001);
    box-shadow: var(--shadow-sm);
}

td {
    padding: 12px 16px;
    color: var(--text-primary);
    transition: color 0.2s ease;
}

td:first-child {
    font-family: var(--font-mono);
    font-weight: 600;
    color: var(--text-white);
}

.data-table-numbers,
td[style*="text-align: right"] {
    font-family: var(--font-mono);
    text-align: right;
    font-variant-numeric: tabular-nums;
}

tfoot {
    background: var(--bg-elevated);
    border-top: 2px solid var(--border-strong);
}

tfoot td {
    padding: 10px 12px;
    font-weight: 600;
    color: var(--text-white);
}

/* Data Colors */
.positive,
.pnl-positive,
.summary-value.positive {
    color: var(--green) !important;
}

.negative,
.pnl-negative,
.summary-value.negative {
    color: var(--red) !important;
}

.neutral {
    color: var(--gray) !important;
}

/* Results Tabs */
.results-tabs {
    display: flex;
    gap: 0;
    margin-bottom: 20px;
    border-bottom: 1px solid var(--border);
}

.results-tabs .tab-button {
    padding: 10px 20px;
    background: transparent;
    border: none;
    border-bottom: 2px solid transparent;
    font-size: 13px;
    font-weight: 500;
    color: var(--text-secondary);
    cursor: pointer;
}

.results-tabs .tab-button:hover {
    color: var(--text-white);
    background: rgba(6, 182, 212, 0.08);
}

.results-tabs .tab-button.active {
    color: var(--text-white);
    border-bottom-color: var(--cyan);
}

.results-tab-content {
    display: none;
}

.results-tab-content.active {
    display: block;
}

/* Pair Selection */
.pair-group,
.pair-selection-group {
    background: var(--bg-elevated);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 16px;
    transition: all 0.2s ease;
    box-shadow: var(--shadow-sm);
}

.pair-group:hover,
.pair-selection-group:hover {
    box-shadow: var(--shadow-md);
    border-color: var(--border-strong);
}

.pair-group h4,
.pair-selection-group h4 {
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--text-secondary);
    margin-bottom: 10px;
}

.pair-checkbox,
.pair-checkbox-container {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    margin-right: 20px;
    margin-bottom: 8px;
}

.pair-checkbox label,
.pair-checkbox-container label {
    font-family: var(--font-mono);
    font-size: 13px;
    color: var(--text-primary);
    cursor: pointer;
    margin: 0;
    text-transform: none;
}

/* Currency Blocks */
.currency-block,
.currency-group-section {
    margin-bottom: 24px;
}

.currency-header,
.currency-block-header {
    background: var(--bg-elevated);
    color: var(--text-white);
    padding: 10px 16px;
    border-radius: 4px;
    margin-bottom: 12px;
    font-size: 14px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

/* Summary Blocks */
.summary-block,
.overall-summary {
    background: var(--bg-elevated);
    border-left: 3px solid var(--cyan);
    padding: 12px 16px;
    margin-top: 16px;
    border-radius: 4px;
}

.summary-block h4,
.overall-summary h4 {
    font-size: 11px;
    color: var(--cyan);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 10px;
}

.summary-block p,
.summary-block div,
.summary-block span,
.overall-summary p,
.overall-summary div,
.overall-summary span {
    color: var(--text-white);
}

.summary-bar {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
}

.summary-item {
    text-align: center;
}

.summary-label {
    font-size: 11px;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 4px;
}

.summary-value {
    font-family: var(--font-mono);
    font-size: 16px;
    font-weight: 600;
    color: var(--text-white);
}

/* Info Box */
.info-box,
.alert {
    background: var(--bg-elevated);
    background-image: var(--bg-gradient-subtle);
    border: 1px solid var(--border);
    border-left: 4px solid var(--cyan);
    border-radius: 8px;
    padding: 16px 20px;
    margin-bottom: 20px;
    box-shadow: var(--shadow-sm);
    transition: all 0.2s ease;
}

.info-box:hover,
.alert:hover {
    box-shadow: var(--shadow-md);
    border-left-color: var(--cyan-light);
}

.info-box,
.info-box p,
.info-box div,
.info-box span,
.info-box strong {
    color: var(--text-white) !important;
}

.alert-warning,
.warning {
    border-color: var(--red);
    border-left-color: var(--red);
    background: rgba(239, 68, 68, 0.05);
}

.alert-warning:hover,
.warning:hover {
    border-left-color: var(--red-light);
    box-shadow: var(--shadow-md), 0 0 10px rgba(239, 68, 68, 0.2);
}

.alert-info {
    border-color: var(--cyan);
    border-left-color: var(--cyan);
    background: rgba(6, 182, 212, 0.05);
}

.alert-info:hover {
    border-left-color: var(--cyan-light);
    box-shadow: var(--shadow-md), var(--shadow-glow);
}

.verification {
    border-left-color: var(--green);
    background: rgba(34, 197, 94, 0.05);
}

.verification:hover {
    border-left-color: var(--green-light);
    box-shadow: var(--shadow-md), 0 0 10px rgba(34, 197, 94, 0.2);
}

.error {
    border-left-color: var(--red);
    background: rgba(239, 68, 68, 0.05);
}

.error:hover {
    border-left-color: var(--red-light);
    box-shadow: var(--shadow-md), 0 0 10px rgba(239, 68, 68, 0.2);
}

/* Expandable Pairs */
.expandable-pair {
    margin: 12px 0;
    border: 1px solid var(--border);
    border-radius: 4px;
    overflow: hidden;
    background: var(--bg-elevated);
}

.pair-header {
    padding: 12px 16px;
    background: var(--bg-input);
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.pair-header:hover {
    background: var(--bg-hover);
}

.pair-details {
    padding: 16px;
    display: none;
    background: var(--bg-elevated);
}

.pair-details.expanded {
    display: block;
}

/* Details/Summary */
details {
    margin: 12px 0;
    border: 1px solid var(--border);
    border-radius: 4px;
    background: var(--bg-elevated);
}

details summary {
    padding: 12px 16px;
    cursor: pointer;
    font-weight: 600;
    color: var(--text-white);
    background: var(--bg-input);
}

details summary:hover {
    background: var(--bg-hover);
}

details[open] summary {
    border-bottom: 1px solid var(--border);
}

details > div {
    padding: 16px;
}

/* Nested Correlation Groups */
.nested-correlation-group {
    margin: 12px 0;
    padding: 0;
}

.nested-correlation-group h4 {
    font-size: 13px;
    font-weight: 600;
    color: var(--text-secondary);
    margin-bottom: 10px;
}

/* Scrollbar */
::-webkit-scrollbar {
    width: 10px;
    height: 10px;
}

::-webkit-scrollbar-track {
    background: var(--bg-main);
}

::-webkit-scrollbar-thumb {
    background: var(--bg-elevated);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: var(--bg-hover);
}

/* Force override any inline blue styles */
[style*="background: blue"],
[style*="background-color: blue"],
[style*="background: #3b82f6"],
[style*="background-color: #3b82f6"],
[style*="background: #007bff"],
[style*="background-color: #007bff"],
[style*="background: #1e40af"],
[style*="background-color: #1e40af"],
[style*="background: rgb(59, 130, 246)"],
[style*="background-color: rgb(59, 130, 246)"] {
    background: var(--bg-elevated) !important;
    color: var(--text-white) !important;
}

/* Force remove bright terminal green */
[style*="color: #00ff00"],
[style*="color: rgb(0, 255, 0)"] {
    color: var(--text-primary) !important;
}

/* Ranking Tables */
.ranking-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 13px;
}

/* Strike Tables */
.strike-summary {
    border-collapse: collapse;
    font-size: 13px;
    background: var(--bg-main);
}

.strike-summary th {
    background: var(--bg-elevated);
    color: var(--text-muted);
    font-size: 10px;
    text-transform: uppercase;
}

.strike-table-wrapper {
    overflow-x: auto;
}

/* Modal */
.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 1000;
    justify-content: center;
    align-items: center;
}

.modal-content {
    background: var(--bg-elevated);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 24px;
    max-width: 90%;
    max-height: 90%;
    overflow: auto;
}

/* Progress Bar */
.progress-bar {
    width: 100%;
    height: 6px;
    background: var(--bg-input);
    border-radius: 6px;
    overflow: hidden;
    box-shadow: inset var(--shadow-sm);
    position: relative;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--cyan) 0%, var(--cyan-light) 100%);
    transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 0 10px var(--cyan-glow);
    position: relative;
}

.progress-fill::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    animation: shimmer 2s infinite;
}

@keyframes shimmer {
    0% {
        transform: translateX(-100%);
    }
    100% {
        transform: translateX(100%);
    }
}

/* Batch Analysis Tabs */
.batch-tabs-container {
    margin-bottom: 0;
    border-bottom: 1px solid var(--border);
    background: var(--bg-elevated);
    border-radius: 4px 4px 0 0;
}

.batch-tabs {
    display: flex;
    gap: 0;
}

/* Filter Panel */
.filter-panel {
    background: var(--bg-elevated);
    border: 1px solid var(--border);
    border-top: none;
    border-radius: 0 0 4px 4px;
    padding: 16px;
    margin-bottom: 20px;
}

.filter-controls {
    display: flex;
    gap: 16px;
    align-items: flex-end;
    flex-wrap: wrap;
}

.filter-group {
    flex: 1;
    min-width: 200px;
}

.filter-group label {
    display: block;
    margin-bottom: 6px;
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--text-secondary);
}

.filter-group input[type="text"] {
    width: 100%;
    padding: 8px 12px;
    font-family: var(--font-mono);
    font-size: 13px;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: 4px;
    color: var(--text-primary);
}

.filter-group input[type="text"]:focus {
    outline: none;
    border-color: var(--cyan);
    box-shadow: 0 0 0 2px rgba(6, 182, 212, 0.1);
}

.filter-group input[type="text"]::placeholder {
    color: var(--text-muted);
}

.filter-group select {
    width: 100%;
    padding: 8px 12px;
    font-family: var(--font-sans);
    font-size: 13px;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: 4px;
    color: var(--text-primary);
    cursor: pointer;
}

.filter-status {
    margin-top: 12px;
    font-size: 12px;
    color: var(--text-secondary);
    font-style: italic;
}

.filter-status.active {
    color: var(--cyan);
    font-style: normal;
}

/* ============================================
   Collapsible Currency Blocks
   ============================================ */

.collapsible {
    cursor: pointer;
    user-select: none;
    display: flex;
    align-items: center;
    gap: 12px;
    transition: background-color 0.15s ease;
}

.collapsible:hover {
    background: var(--bg-hover);
}

.collapse-icon {
    font-size: 12px;
    color: var(--text-secondary);
    transition: transform 0.2s ease;
    display: inline-block;
    min-width: 16px;
    text-align: center;
}

.currency-header.collapsed .collapse-icon {
    transform: rotate(-90deg);
}

.currency-name {
    flex: 1;
}

.currency-content {
    max-height: 5000px;
    overflow: hidden;
    transition: max-height 0.3s ease, opacity 0.2s ease, padding 0.2s ease;
    opacity: 1;
}

.currency-content.collapsed {
    max-height: 0;
    opacity: 0;
    padding-top: 0 !important;
    padding-bottom: 0 !important;
    margin-top: 0 !important;
    margin-bottom: 0 !important;
}

/* Nested collapsible (for correlation sub-groups) */
.nested-correlation-group .collapsible {
    padding: 8px 12px;
    background: var(--bg-elevated);
    border-radius: 4px;
    margin-bottom: 8px;
}

.nested-correlation-group .currency-content {
    padding-left: 0;
}

/* Block controls */
.block-controls {
    margin-bottom: 16px;
    display: flex;
    gap: 8px;
}

.block-controls .btn {
    padding: 6px 12px;
    font-size: 12px;
}

/* ============================================
   Modal System for Charts
   ============================================ */

.modal-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(8px);
    z-index: 99999;
    overflow-y: auto;
    padding: 20px;
    align-items: center;
    justify-content: center;
    animation: fadeIn 0.2s ease;
}

@keyframes fadeIn {
    from {
        opacity: 0;
    }
    to {
        opacity: 1;
    }
}

.modal-overlay.active {
    display: flex !important;
}

.modal-content {
    background: var(--bg-elevated);
    background-image: var(--bg-gradient);
    border: 2px solid var(--cyan);
    border-radius: 12px;
    width: 90%;
    max-width: 1200px;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: var(--shadow-xl), var(--shadow-glow-strong);
    position: relative;
    z-index: 100000;
    animation: slideUp 0.3s ease;
}

@keyframes slideUp {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 24px 28px;
    border-bottom: 1px solid var(--cyan);
    background: rgba(6, 182, 212, 0.05);
    background-image: linear-gradient(135deg, rgba(6, 182, 212, 0.1) 0%, rgba(6, 182, 212, 0.05) 100%);
    border-radius: 12px 12px 0 0;
}

.modal-header h3 {
    margin: 0;
    font-size: 20px;
    font-weight: 600;
    color: var(--cyan-light);
    letter-spacing: -0.01em;
}

.modal-close {
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid var(--border);
    font-size: 24px;
    color: var(--text-secondary);
    cursor: pointer;
    padding: 0;
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 6px;
    transition: all 0.2s ease;
}

.modal-close:hover {
    background: var(--bg-hover);
    color: var(--text-white);
    border-color: var(--cyan);
    transform: rotate(90deg);
    box-shadow: var(--shadow-sm);
}

.modal-body {
    padding: 28px;
    background: var(--bg-elevated);
    color: var(--text-white);
}

.modal-footer {
    display: flex;
    gap: 12px;
    justify-content: flex-end;
    padding: 16px 24px;
    border-top: 1px solid var(--border);
    background: #0d0d0d;
}

/* Pair info summary */
.pair-info-summary {
    background: var(--bg-main);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 16px;
    margin-bottom: 20px;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 16px;
}

.info-item {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.info-label {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--text-secondary);
}

.info-value {
    font-family: var(--font-mono);
    font-size: 16px;
    font-weight: 500;
    color: var(--text-white);
}

/* Strike breakdown table */
.strike-breakdown-table {
    margin-top: 24px;
}

.strike-breakdown-table table {
    width: 100%;
    border-collapse: collapse;
    font-size: 13px;
}

.strike-breakdown-table th {
    text-align: left;
    padding: 10px 12px;
    background: var(--bg-main);
    border-bottom: 1px solid var(--border);
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    color: var(--text-muted);
}

.strike-breakdown-table td {
    padding: 10px 12px;
    border-bottom: 1px solid var(--border-subtle);
}

.strike-breakdown-table tbody tr {
    transition: background-color 0.15s ease;
}

.strike-breakdown-table tbody tr:hover {
    background-color: rgba(0, 255, 255, 0.1) !important;
}

/* Chart-enabled cells - CSP-safe with data attributes */
.chart-cell {
    cursor: pointer;
    position: relative;
    transition: all 0.2s ease;
}

.chart-cell:hover {
    box-shadow: 0 0 0 2px var(--cyan), var(--shadow-glow);
    z-index: 10;
    transform: translateY(-1px);
}

.chart-cell:active {
    transform: scale(0.98) translateY(0);
    transition: transform 0.1s ease;
}

.batch-tab {
    padding: 14px 28px;
    background: transparent;
    border: none;
    border-bottom: 2px solid transparent;
    color: var(--text-secondary);
    font-family: var(--font-sans);
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s;
}

.batch-tab:hover {
    color: var(--text-primary);
    background: var(--bg-hover);
}

.batch-tab.active {
    color: var(--text-white);
    border-bottom-color: var(--cyan);
    background: var(--bg-main);
}

/* Tab Panels */
.batch-tab-panel {
    display: none;
    padding-top: 20px;
}

.batch-tab-panel.active {
    display: block;
    animation: fadeIn 0.2s ease;
}

@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Summary Sections in Overview */
.summary-section {
    margin-bottom: 32px;
}

.summary-section h3 {
    font-size: 16px;
    font-weight: 600;
    color: var(--text-white);
    margin-bottom: 16px;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border);
}

/* Export Section */
.export-section {
    margin-top: 32px;
    padding-top: 24px;
    border-top: 1px solid var(--border);
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
}

/* Charts Placeholder */
.charts-placeholder {
    background: var(--bg-elevated);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 60px 40px;
    text-align: center;
}

.charts-placeholder p {
    color: var(--text-secondary);
    font-size: 16px;
}

/* Sortable Table Headers */
.sortable-header {
    cursor: pointer;
    user-select: none;
    position: relative;
    padding-right: 20px !important;
    transition: background 0.15s, color 0.15s;
}

.sortable-header:hover {
    color: var(--text-primary);
    background: var(--bg-hover);
}

.sortable-header::after {
    content: '‚áÖ';
    position: absolute;
    right: 6px;
    opacity: 0.3;
    font-size: 10px;
}

.sortable-header.sort-asc::after {
    content: '‚ñ≤';
    opacity: 1;
    color: var(--cyan);
}

.sortable-header.sort-desc::after {
    content: '‚ñº';
    opacity: 1;
    color: var(--cyan);
}

/* Highlight sorted column - ONLY for header cells */
th.sorted-column {
    background: var(--bg-hover) !important;
}

/* NEVER apply sorted-column background to tbody cells - preserve their colors */
tbody td.sorted-column {
    background: inherit !important;
}

/* ============================================
   FIX: Remove Bold from Numbers in Tables
   ============================================ */

/* Ensure numbers are NOT bold - normal weight */
.data-table-numbers,
td.data-table-numbers,
.pair-details td,
.strike-summary td,
.expandable-pair td,
.expanded-pair td {
    font-weight: 400 !important;
}

/* Only pair names (first column) should be bold */
td:first-child {
    font-weight: 600;
}

/* Override any bold styling on numeric cells */
td:not(:first-child) {
    font-weight: 400;
}

/* Specific override for expanded pair details */
.pair-details td,
.strike-breakdown td,
[class*="pair-detail"] td {
    font-weight: 400 !important;
}

/* Only headers should be bold */
th {
    font-weight: 600;
}


/* Utility Classes */
.text-center { text-align: center; }
.text-right { text-align: right; }
.font-mono { font-family: var(--font-mono); }
.mt-1 { margin-top: 8px; }
.mt-2 { margin-top: 16px; }
.mb-1 { margin-bottom: 8px; }
.mb-2 { margin-bottom: 16px; }

/* ============================================
   CONTRAST FIX - Readable Text on All Backgrounds
   ============================================ */

/* Force dark text on specific colored backgrounds (only for page UI, not email HTML) */
/* Note: Removed white/light color overrides to preserve email HTML styling */
[style*="background-color: rgb(6, 182, 212)"],
[style*="background-color: #06b6d4"],
[style*="background: #06b6d4"],
[style*="background-color: cyan"],
[style*="background: cyan"],
[style*="background-color: rgb(34, 197, 94)"],
[style*="background-color: #22c55e"],
[style*="background: #22c55e"],
[style*="background-color: green"] {
    background: var(--bg-elevated) !important;
    color: var(--text-white) !important;
}

/* Override old blue border colors */
[style*="border-left: 3px solid #007bff"],
[style*="border-left: 3px solid rgb(0, 123, 255)"] {
    border-left: 3px solid var(--cyan) !important;
}

/* Ensure all box contents are readable */
#windowPreview,
#windowPreview *,
.window-preview,
.window-preview *,
.analysis-window,
.analysis-window * {
    color: var(--text-white) !important;
}

    </style>
</head>
<body>
    <!-- Professional Header -->
    <header class="app-header">
        <div class="header-container">
            <div class="header-left">
                <h1 class="app-title">
                    <span class="title-icon">üìä</span>
                    FX Options P&L Calculator
                </h1>
                <span class="app-subtitle">Delta-Hedged Volatility Analysis</span>
            </div>
        </div>

        <!-- Tab Navigation -->
        <div class="tab-navigation">
            <button class="tab-button" onclick="switchTab('single-pair')">Single Pair Analysis</button>
            <button class="tab-button active" onclick="switchTab('batch')">Batch Analysis</button>
        </div>
    </header>

    <div class="container">

        <!-- Single Pair Analysis Tab -->
        <div id="single-pair-tab" class="tab-content">

        <!-- Configuration Card -->
        <div class="card">
            <div class="card-header">Configuration</div>

            <div class="info-box">
                <div>
                <strong>Setup:</strong> EURUSD Options (5 strikes) ‚Ä¢ Notional: 100M Settlement Currency (USD) per strike<br>
                <strong>Note:</strong> Base currency (EUR) notional varies by strike: Base Notional = 100M / Strike<br>
                <strong>Data Format:</strong> Variable-length spot series, 10-minute sampling intervals<br>
                <strong>Model:</strong> Black-Scholes with r=0, q=0<br>
                <strong>Strikes:</strong> 10Œî Put, 25Œî Put, ATM Call, 25Œî Call, 10Œî Call
                </div>
            </div>

        <div class="input-section">
            <div class="input-group">
                <label>Initial Spot (for test data generation):</label>
                <input type="number" id="initialSpot" step="0.0001" value="1.1000">
            </div>
            <div class="input-group">
                <label>Hours of Data (for test data generation):</label>
                <input type="number" id="hoursOfData" step="1" value="24" min="0.167" max="1000">
            </div>
            <div class="input-group">
                <label>Implied Volatility (%):</label>
                <input type="number" id="vol" step="0.1" value="10">
            </div>
        </div>

        <div class="input-section">
            <div class="input-group">
                <label>Base Data Frequency (minutes):</label>
                <select id="baseFrequency">
                    <option value="10" selected>10 minutes</option>
                    <option value="30">30 minutes</option>
                    <option value="60">60 minutes</option>
                    <option value="120">120 minutes</option>
                </select>
            </div>
            <div class="input-group">
                <label>Hedging Frequency (minutes):</label>
                <select id="hedgeFrequency">
                    <option value="10" selected>10 minutes</option>
                    <option value="30">30 minutes</option>
                    <option value="60">60 minutes</option>
                    <option value="120">120 minutes</option>
                </select>
            </div>
        </div>

        <div class="input-section">
            <div class="input-group">
                <label>Option Expiry:</label>
                <div style="margin-top: 5px;">
                    <label style="font-weight: normal; display: block; margin-bottom: 5px;">
                        <input type="radio" name="expiryMode" value="atEnd" checked onchange="toggleExpiryMode()">
                        At end of spot series (standard)
                    </label>
                    <label style="font-weight: normal; display: block;">
                        <input type="radio" name="expiryMode" value="custom" onchange="toggleExpiryMode()">
                        Custom: <input type="number" id="customExpiryValue" value="48" min="0.1" step="0.1" style="width: 80px; margin-left: 5px;" disabled>
                        <select id="customExpiryUnit" style="width: 90px;" disabled>
                            <option value="hours">Hours</option>
                            <option value="minutes">Minutes</option>
                        </select>
                    </label>
                </div>
            </div>
            <div class="info-box" id="expiryCalculations" style="display: none; margin-top: 10px;">
                <div>
                    <strong>Calculated:</strong><br>
                    <span id="spotSeriesLengthDisplay" style="margin-left: 10px;">‚Ä¢ Spot Series Length: -- hours</span><br>
                    <span id="timeRemainingDisplay" style="margin-left: 10px;">‚Ä¢ Time Remaining at End: -- hours</span><br>
                    <span id="expiryWarning" style="margin-left: 10px; color: var(--red); font-weight: bold;"></span>
                </div>
            </div>
        </div>

        <div class="input-section">
            <div class="input-group input-group-full">
                <label>Spot Price Series (one per line, interval matches Base Data Frequency):</label>
                <textarea id="spotSeries" rows="10" placeholder="Paste spot prices here, one per line (minimum 2 values)..."></textarea>
                <div style="margin-top: 5px;">
                    <button class="secondary" onclick="generateTestData()">Generate Test Data</button>
                    <button onclick="calculate()">Calculate All Strikes</button>
                </div>
            </div>
        </div>

        <div class="input-section">
            <div class="input-group input-group-full">
                <label><strong>Custom Strikes (Optional - Max 5)</strong></label>
                <div id="customStrikesContainer" style="margin-top: 10px;">
                    <!-- Custom strike rows will be added here -->
                </div>
                <div style="margin-top: 10px;">
                    <button class="secondary" onclick="addCustomStrike()" id="addCustomStrikeBtn">Add Custom Strike</button>
                    <span id="customStrikeCount" style="margin-left: 10px; color: var(--text-secondary);">Custom Strikes: 0/5</span>
                </div>
            </div>
        </div>
        </div>
        <!-- End Configuration Card -->

        <!-- Results Section -->
        <div id="validation-message"></div>
        <div id="strikes-info"></div>
        <div id="summary"></div>
        <div id="results"></div>
        </div>
        <!-- End Single Pair Analysis Tab -->

        <!-- Batch Analysis Tab -->
        <div id="batch-tab" class="tab-content active">

            <!-- Upload Section Card -->
            <div class="card upload-section">
                <div class="card-header">Data Upload</div>

                <div class="upload-container">
                    <div class="upload-box-wrapper">
                        <div class="upload-area" onclick="document.getElementById('excelFileInput').click()">
                            <div class="upload-icon">üìÅ</div>
                            <h3>Upload Excel File</h3>
                            <p>Drop your Excel file here or click to browse</p>
                            <p class="upload-hint">Required sheets: "Spot Data" and "Implied Vols"</p>
                            <input type="file" id="excelFileInput" accept=".xlsx" onchange="handleExcelUpload(event)" style="display: none;">
                            <button class="btn-large" onclick="event.stopPropagation(); document.getElementById('excelFileInput').click()">
                                Choose File
                            </button>
                        </div>
                    </div>

                    <div class="upload-requirements">
                        <div class="info-box" style="margin-top: 0;">
                            <div>
                            <h4>Required Excel Format:</h4>
                            
                            <div style="margin-bottom: 16px;">
                                <strong>Sheet 1: "Spot Data"</strong><br>
                                ‚Ä¢ Column A: Timestamps<br>
                                ‚Ä¢ Other columns: <strong>USD pairs ONLY</strong><br>
                                ‚Ä¢ Format: EURUSD, GBPUSD, USDJPY, USDCAD, etc.<br>
                                ‚Ä¢ <strong>Do NOT include cross pairs</strong> (e.g., EURGBP, EURJPY)<br>
                                ‚Ä¢ Supports any USD pair (G10, EM, all currencies)
                            </div>
                            
                            <div>
                                <strong>Sheet 2: "Implied Vols"</strong><br>
                                ‚Ä¢ Column A: Pair names (USD pairs + crosses)<br>
                                ‚Ä¢ Column B: Volatilities (as decimals, e.g., 0.08 for 8%)<br>
                                ‚Ä¢ Include vols for ALL desired pairs:<br>
                                &nbsp;&nbsp;- USD pairs: EURUSD, GBPUSD, USDJPY, etc.<br>
                                &nbsp;&nbsp;- Cross pairs: EURGBP, EURJPY, CADCHF, etc.<br>
                                ‚Ä¢ <strong>Only crosses with vols will be available</strong><br>
                                ‚Ä¢ Your cross pair labels determine the quote convention
                            </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Upload Status -->
            <div id="uploadStatus"></div>
            <div id="uploadWarnings"></div>

            <!-- Configuration Card -->
            <div class="card" style="display: none;" id="batchConfigSection">
                <div class="card-header">Configuration</div>

                <div class="input-section">
                    <div class="input-group">
                        <label>Base Data Frequency:</label>
                        <select id="batchBaseFrequency">
                            <option value="10" selected>10 minutes</option>
                            <option value="30">30 minutes</option>
                            <option value="60">60 minutes</option>
                            <option value="120">120 minutes</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>Hedging Frequency:</label>
                        <select id="batchHedgeFrequency">
                            <option value="10" selected>10 minutes</option>
                            <option value="30">30 minutes</option>
                            <option value="60">60 minutes</option>
                            <option value="120">120 minutes</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>Option Expiry:</label>
                        <div style="margin-top: 5px;">
                            <label style="font-weight: normal; display: block; margin-bottom: 5px;">
                                <input type="radio" id="endOfSeriesRadio" name="batchExpiryMode" value="atEnd" checked>
                                At end of spot series
                            </label>
                            <label style="font-weight: normal; display: block;">
                                <input type="radio" id="customExpiryRadio" name="batchExpiryMode" value="custom">
                                Custom: <input type="number" id="customExpiryInput" value="48" min="0.1" step="0.1" style="width: 80px; margin-left: 5px;" disabled>
                                <select id="customExpiryUnit" style="width: 90px;" disabled>
                                    <option value="hours">Hours</option>
                                    <option value="minutes">Minutes</option>
                                </select>
                            </label>
                        </div>
                    </div>
                    <div class="input-group">
                        <label class="input-label">
                            <input type="checkbox" id="includeCorrelationAnalysis" checked>
                            Include Correlation Analysis
                        </label>
                        <span class="label-hint" style="display: block; margin-top: 4px; font-size: 12px; color: #6b7280;">
                            Compare realized vs implied correlations across currency groups
                        </span>
                    </div>
                </div>
            </div>
            <!-- End Configuration Card -->

            <!-- Analysis Window Selection Card -->
            <div class="card" id="analysisWindowSection" style="display: none;">
                <div class="card-header">Analysis Window</div>
                <div style="margin: 15px 0;">
                    <label style="font-weight: normal; display: block; margin-bottom: 10px;">
                        <input type="radio" id="useEntireDataset" name="analysisWindowMode" value="entire" checked>
                        Use entire dataset (default)
                    </label>

                    <label style="font-weight: normal; display: block; margin-bottom: 10px;">
                        <input type="radio" id="useCustomWindow" name="analysisWindowMode" value="custom">
                        Custom window:
                    </label>

                    <div id="customWindowInputs" style="max-width: 500px;">
                        <table style="border-spacing: 10px 5px;">
                            <tr>
                                <td style="text-align: right; padding-right: 10px; font-weight: 500;">Start:</td>
                                <td>
                                    <input type="date" id="analysisStartDate" disabled onchange="updateAnalysisWindowPreview()">
                                    <input type="time" id="analysisStartTime" step="600" style="margin-left: 5px;" disabled onchange="updateAnalysisWindowPreview()">
                                </td>
                            </tr>
                            <tr>
                                <td style="text-align: right; padding-right: 10px; font-weight: 500;">End:</td>
                                <td>
                                    <input type="date" id="analysisEndDate" disabled onchange="updateAnalysisWindowPreview()">
                                    <input type="time" id="analysisEndTime" step="600" style="margin-left: 5px;" disabled onchange="updateAnalysisWindowPreview()">
                                </td>
                            </tr>
                        </table>

                        <div id="windowPreview" class="info-box">
                            <!-- Preview will be populated here -->
                        </div>
                    </div>
                </div>
            </div>
            <!-- End Analysis Window Card -->

            <!-- Pair Selection Card -->
            <div class="card" id="pairSelectionSection" style="display: none;">
                <div class="card-header">
                    Select Currency Pairs
                    <span class="pair-counter" id="pairSelectionCount">0 selected</span>
                </div>

                <div style="margin-bottom: 16px;">
                    <button onclick="selectAllPairs()" class="secondary btn-sm">Select All</button>
                    <button onclick="deselectAllPairs()" class="secondary btn-sm">Deselect All</button>
                </div>

                <div id="pairCheckboxGrid" class="pair-selection-grid">
                    <!-- Checkboxes will be populated here -->
                </div>

                <button onclick="startBatchCalculation()" class="btn-large" style="width: 100%; margin-top: 16px;">
                    Calculate All Selected Pairs
                </button>
            </div>

            <!-- Correlation Group Selection Card -->
            <div class="card" id="correlationGroupSelection" style="display: none;">
                <!-- Will be populated by displayCorrelationGroupSelection() -->
            </div>

            <!-- Progress Section Card -->
            <div id="progressSection" class="progress-container" style="display: none;">
                <div class="card-header">Calculating...</div>
                <div class="progress-info">
                    <span id="currentPairText">Processing...</span>
                    <span id="progressText" class="progress-percent">0%</span>
                </div>
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill" style="width: 0%;"></div>
                </div>
            </div>

            <!-- Results Section -->
            <div id="batchResults" style="display: none;">
                <h2>Results</h2>

                <!-- Export Buttons -->
                <div id="exportButtons" style="display: none; margin-top: 24px; padding-top: 24px; border-top: 2px solid #e5e7eb;">
                    <h3 style="margin-bottom: 16px; color: #1f2937;">Export Results</h3>
                    <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                        <button class="btn btn-primary" onclick="copyEmailReport()" style="min-width: 200px;">
                            üìã Copy Email Report
                        </button>
                        <button class="btn btn-secondary" onclick="copyBloombergChat()" style="min-width: 200px;">
                            üí¨ Copy Bloomberg Chat
                        </button>
                    </div>
                    <div id="exportStatus" style="margin-top: 12px; font-size: 13px; color: #059669;"></div>
                </div>
                
                <div id="batchResultsContent">
                <!-- Top 5 / Bottom 5 Rankings -->
                <div id="rankingsSection">
                    <h3 class="currency-header" style="text-align: center; margin-top: 20px;">üèÜ TOP 5 PERFORMERS</h3>
                    <div id="top5Table"></div>

                    <h3 class="currency-header" style="text-align: center; margin-top: 20px; border-left: 3px solid var(--red);">üìâ BOTTOM 5 PERFORMERS</h3>
                    <div id="bottom5Table"></div>
                </div>

                <!-- Currency Groups -->
                <div id="currencyGroupsSection">
                    <h2 style="margin-top: 40px;">Currency Groups</h2>
                    <div id="currencyGroupsContent"></div>
                </div>

                <!-- Expandable Details -->
                <div id="expandableDetailsSection">
                    <h2 style="margin-top: 40px;">Pair Details (Click to Expand)</h2>
                    <div id="expandableDetailsContent"></div>
                </div>
                </div>
                <!-- End batchResultsContent -->
            </div>
        </div>
        <!-- End Batch Analysis Tab -->

    </div>

    <script>
        // Constants
        const SETTLEMENT_NOTIONAL = 100_000_000; // 100 million USD (settlement currency)
        const MIN_POINTS = 2; // Minimum data points (need at least 1 interval)
        const MAX_POINTS = 10000; // Maximum data points (reasonable limit)
        const MAX_CUSTOM_STRIKES = 5;
        let customStrikeCounter = 0;

        // Master currency ordering for consistent display
        // G10 currencies first, then EM pairs
        const CURRENCY_ORDER = [
            'USD',   // US Dollar
            'EUR',   // Euro
            'GBP',   // British Pound
            'CHF',   // Swiss Franc
            'JPY',   // Japanese Yen
            'AUD',   // Australian Dollar
            'NZD',   // New Zealand Dollar
            'CAD',   // Canadian Dollar
            'MXN',   // Mexican Peso
            'BRL',   // Brazilian Real
            'ZAR',   // South African Rand
            'TRY',   // Turkish Lira
            'RUB',   // Russian Ruble
            'INR',   // Indian Rupee
            'CNY',   // Chinese Yuan (Onshore)
            'CNH',   // Chinese Yuan (Offshore)
            'KRW',   // South Korean Won
            'TWD',   // Taiwan Dollar
            'SGD',   // Singapore Dollar
            'HKD',   // Hong Kong Dollar
            'THB',   // Thai Baht
            'IDR',   // Indonesian Rupiah
            'MYR',   // Malaysian Ringgit
            'PHP',   // Philippine Peso
            'PLN',   // Polish Zloty
            'CZK',   // Czech Koruna
            'HUF',   // Hungarian Forint
            'ILS',   // Israeli Shekel
            'CLP',   // Chilean Peso
            'COP',   // Colombian Peso
            'PEN',   // Peruvian Sol
            'ARS'    // Argentine Peso
        ];

        function getCurrencyRank(currency) {
            const index = CURRENCY_ORDER.indexOf(currency);
            return index === -1 ? 999 : index; // Unknown currencies go to end
        }

        function sortCurrencies(currencies) {
            return [...currencies].sort((a, b) => getCurrencyRank(a) - getCurrencyRank(b));
        }

        function constructMainPair(mainCurrency, secondaryCurrency) {
            // Construct the canonical pair name following standard convention
            // and the specified ordering
            
            const rank1 = getCurrencyRank(mainCurrency);
            const rank2 = getCurrencyRank(secondaryCurrency);
            
            // The currency with lower rank (appears earlier in CURRENCY_ORDER) comes first
            if (rank1 < rank2) {
                return `${mainCurrency}${secondaryCurrency}`;
            } else {
                return `${secondaryCurrency}${mainCurrency}`;
            }
        }

        function normalizeCorrelationForDisplay(corr, mainPair) {
            // Ensure pair1 is always the mainPair
            // If it's not, swap pair1 and pair2
            
            if (corr.pair1 === mainPair) {
                return {
                    pair1: corr.pair1,
                    pair2: corr.pair2,
                    impliedCorr: corr.impliedCorr,
                    realizedCorr: corr.realizedCorr,
                    difference: corr.difference
                };
            } else if (corr.pair2 === mainPair) {
                // Swap
                return {
                    pair1: corr.pair2,
                    pair2: corr.pair1,
                    impliedCorr: corr.impliedCorr,
                    realizedCorr: corr.realizedCorr,
                    difference: corr.difference
                };
            } else {
                // Neither is the main pair, return as-is
                return corr;
            }
        }

        // ============ TAB SWITCHING ============

        function switchTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });

            // Remove active class from all buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected tab
            if (tabName === 'single-pair') {
                document.getElementById('single-pair-tab').classList.add('active');
                document.querySelectorAll('.tab-button')[0].classList.add('active');
            } else if (tabName === 'batch') {
                document.getElementById('batch-tab').classList.add('active');
                document.querySelectorAll('.tab-button')[1].classList.add('active');
            }
        }

        // ============ BATCH ANALYSIS FUNCTIONS ============

        let batchData = {
            timestamps: [],
            frequency: 10,
            pairNames: [],
            spotPrices: {},
            impliedVols: {},
            results: {},
            usdPairs: [],
            currencies: [],
            availableCrosses: [],
            unavailableCrosses: []
        };

        function handleExcelUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array', cellFormula: false, cellDates: true});

                    // Check for required sheets
                    if (!workbook.SheetNames.includes('Spot Data')) {
                        showBatchMessage('Error: Excel file must contain a sheet named "Spot Data"', 'error');
                        return;
                    }
                    if (!workbook.SheetNames.includes('Implied Vols')) {
                        showBatchMessage('Error: Excel file must contain a sheet named "Implied Vols"', 'error');
                        return;
                    }

                    // Parse Spot Data sheet
                    const spotSheet = workbook.Sheets['Spot Data'];
                    const spotData = XLSX.utils.sheet_to_json(spotSheet, {raw: false, dateNF: 'yyyy-mm-dd hh:mm:ss'});

                    // Filter out rows where Timestamp is null/empty
                    const validData = spotData.filter(row => row.Timestamp != null || row.timestamp != null);

                    if (validData.length < MIN_POINTS) {
                        showBatchMessage(`Error: Minimum ${MIN_POINTS} valid data points required, got ${validData.length}`, 'error');
                        return;
                    }

                    // Extract timestamps
                    batchData.timestamps = validData.map(row => row.Timestamp || row.timestamp);

                    // Auto-detect frequency
                    batchData.frequency = detectFrequency(batchData.timestamps);

                    // Extract currency pairs (all columns except Timestamp)
                    const allKeys = Object.keys(validData[0]);
                    const spotColumns = allKeys.filter(key =>
                        key !== 'Timestamp' && key !== 'timestamp' && key.trim() !== ''
                    );

                    // Extract spot prices for all columns first (for validation)
                    const tempSpotPrices = {};
                    spotColumns.forEach(pair => {
                        const prices = validData.map(row => parseFloat(row[pair]));
                        // Validate all prices are positive numbers
                        if (prices.some(p => isNaN(p) || p <= 0)) {
                            throw new Error(`Invalid spot prices found for pair: ${pair}`);
                        }
                        tempSpotPrices[pair] = prices;
                    });

                    // Parse Implied Vols sheet
                    const volSheet = workbook.Sheets['Implied Vols'];
                    const volData = XLSX.utils.sheet_to_json(volSheet);

                    const tempImpliedVols = {};
                    volData.forEach(row => {
                        const pairName = row.Pair || row.pair;
                        if (!pairName) return; // Skip empty rows
                        const volValue = parseFloat(row.ImpliedVol || row.impliedvol || row.impliedVol);

                        if (isNaN(volValue) || volValue <= 0) {
                            throw new Error(`Invalid implied vol for pair: ${pairName}`);
                        }

                        tempImpliedVols[pairName] = volValue;
                    });

                    // Validate upload for cross derivation
                    const validation = validateUploadForCrossDerivation(tempSpotPrices, tempImpliedVols);
                    if (!validation.valid) {
                        showBatchMessage('Upload failed:\n\n' + validation.errors.join('\n'), 'error');
                        return;
                    }

                    // Store USD pairs and currencies
                    batchData.usdPairs = validation.usdPairs;
                    batchData.currencies = validation.currencies;

                    // Extract spot prices only for USD pairs
                    batchData.spotPrices = {};
                    batchData.usdPairs.forEach(pair => {
                        batchData.spotPrices[pair] = tempSpotPrices[pair];
                    });

                    // Store all implied vols (USD pairs + crosses)
                    batchData.impliedVols = tempImpliedVols;

                    // Filter available crosses
                    const { availableCrosses, unavailableCrosses } = filterAvailableCrosses(
                        batchData.impliedVols,
                        batchData.usdPairs,
                        batchData.currencies
                    );
                    batchData.availableCrosses = availableCrosses;
                    batchData.unavailableCrosses = unavailableCrosses;

                    // Show warnings if any
                    if (validation.warnings.length > 0 || unavailableCrosses.length > 0) {
                        let warningHTML = '<div class="alert alert-warning" style="margin-top: 10px;"><strong>Upload Successful with Warnings:</strong><ul>';
                        validation.warnings.forEach(w => {
                            warningHTML += `<li>${w}</li>`;
                        });
                        if (unavailableCrosses.length > 0) {
                            warningHTML += '<li><strong>Cross pairs with vols but missing USD pairs:</strong><ul>';
                            unavailableCrosses.forEach(item => {
                                warningHTML += `<li>${item.pair} - ${item.reason}</li>`;
                            });
                            warningHTML += '</ul></li>';
                        }
                        warningHTML += '</ul></div>';
                        document.getElementById('uploadWarnings').innerHTML = warningHTML;
                    }

                    // Set pairNames to USD pairs only (crosses will be derived later)
                    batchData.pairNames = batchData.usdPairs;

                    // Calculate time period
                    const numPoints = batchData.timestamps.length;
                    const totalMinutes = (numPoints - 1) * batchData.frequency;
                    const totalHours = totalMinutes / 60;

                    // Store full data range
                    const firstTimestamp = batchData.timestamps[0];
                    const lastTimestamp = batchData.timestamps[batchData.timestamps.length - 1];

                    batchData.fullDataRange = {
                        start: firstTimestamp,
                        end: lastTimestamp,
                        points: numPoints,
                        minutes: totalMinutes,
                        hours: totalHours
                    };

                    // Show success message with time range
                    const startStr = formatDateTime(firstTimestamp);
                    const endStr = formatDateTime(lastTimestamp);

                    showBatchMessage(
                        `‚úì Excel file uploaded successfully<br>` +
                        `‚úì Detected ${numPoints} time points<br>` +
                        `‚úì Data Time Range: ${startStr} ‚Üí ${endStr}<br>` +
                        `‚úì Total Duration: ${totalMinutes} minutes (${totalHours.toFixed(1)} hours)<br>` +
                        `‚úì Frequency auto-detected: ${batchData.frequency} minutes<br>` +
                        `‚úì Found ${batchData.usdPairs.length} USD pairs<br>` +
                        `‚úì Available currencies: ${batchData.currencies.join(', ')}<br>` +
                        `‚úì Available cross pairs: ${batchData.availableCrosses.length}`,
                        'verification'
                    );

                    // Hide upload section after successful upload
                    document.querySelector('.upload-section').style.display = 'none';

                    // Show configuration and pair selection
                    document.getElementById('batchConfigSection').style.display = 'grid';
                    document.getElementById('batchBaseFrequency').value = batchData.frequency;
                    document.getElementById('analysisWindowSection').style.display = 'block';
                    initializeAnalysisWindow();
                    displayPairSelection();
                    document.getElementById('pairSelectionSection').style.display = 'block';

                } catch (error) {
                    showBatchMessage(`Error parsing Excel file: ${error.message}`, 'error');
                    console.error('Excel parsing error:', error);
                }
            };

            reader.readAsArrayBuffer(file);
        }

        // ============ CROSS PAIR CALCULATION FUNCTIONS ============

        function parseUSDPairs(spotDataColumns) {
            const usdPairs = [];
            const currencies = new Set(['USD']); // Always include USD

            spotDataColumns.forEach(column => {
                if (column === 'Timestamp' || column === 'timestamp') return;

                // Check if it's a USD pair (contains 'USD')
                if (column.includes('USD')) {
                    usdPairs.push(column);

                    // Extract the non-USD currency
                    if (column.startsWith('USD')) {
                        // USD/XXX format (e.g., USDJPY, USDKRW, USDINR)
                        const ccy = column.substring(3, 6);
                        currencies.add(ccy);
                    } else {
                        // XXX/USD format (e.g., EURUSD, GBPUSD)
                        const ccy = column.substring(0, 3);
                        currencies.add(ccy);
                    }
                } else {
                    console.warn(`Ignoring non-USD pair in Spot Data: ${column}`);
                }
            });

            return {
                usdPairs: usdPairs,
                currencies: Array.from(currencies).sort()
            };
        }

        function parseCrossPair(crossPairName) {
            // crossPairName is 6 characters, e.g., "CADCHF", "EURGBP", "ZARJPY"
            return {
                base: crossPairName.substring(0, 3),   // First 3 chars
                quote: crossPairName.substring(3, 6)   // Last 3 chars
            };
        }

        function calculateCrossRate(crossPairName, usdPairData, usdPairs, timeIndex) {
            const { base, quote } = parseCrossPair(crossPairName);

            // Helper function: Get XXX/USD rate for any currency
            function getUSDRate(currency) {
                if (currency === 'USD') return 1.0;

                const directPair = currency + 'USD';   // e.g., EURUSD
                const indirectPair = 'USD' + currency; // e.g., USDJPY

                if (usdPairs.includes(directPair)) {
                    // Already in XXX/USD format - use directly
                    return usdPairData[directPair][timeIndex];
                } else if (usdPairs.includes(indirectPair)) {
                    // USD/XXX format - invert to get XXX/USD
                    const usdXXXRate = usdPairData[indirectPair][timeIndex];
                    return 1.0 / usdXXXRate;
                } else {
                    throw new Error(`No USD pair found for ${currency}`);
                }
            }

            // Get both currencies in XXX/USD terms
            const baseUSD = getUSDRate(base);    // BASE/USD
            const quoteUSD = getUSDRate(quote);  // QUOTE/USD

            // Calculate cross rate: BASE/QUOTE = (BASE/USD) / (QUOTE/USD)
            return baseUSD / quoteUSD;
        }

        function deriveCrossSeries(crossPairName, usdPairData, usdPairs, timestamps) {
            const crossSeries = [];

            for (let i = 0; i < timestamps.length; i++) {
                try {
                    const crossRate = calculateCrossRate(crossPairName, usdPairData, usdPairs, i);
                    crossSeries.push(crossRate);
                } catch (error) {
                    console.error(`Error calculating ${crossPairName} at ${timestamps[i]}:`, error.message);
                    return null; // Return null if any calculation fails
                }
            }

            return crossSeries;
        }

        function filterAvailableCrosses(impliedVols, usdPairs, currencies) {
            const availableCrosses = [];
            const unavailableCrosses = [];

            Object.keys(impliedVols).forEach(pair => {
                // Skip USD pairs (we already have spot data for these)
                if (pair.includes('USD')) return;

                // Parse cross pair
                const { base, quote } = parseCrossPair(pair);

                // Check if both currencies are available in our USD pairs
                if (currencies.includes(base) && currencies.includes(quote)) {
                    availableCrosses.push(pair);
                } else {
                    unavailableCrosses.push({
                        pair: pair,
                        reason: `Missing USD pair for ${!currencies.includes(base) ? base : quote}`
                    });
                }
            });

            // Log unavailable crosses for user visibility
            if (unavailableCrosses.length > 0) {
                console.warn('The following crosses have vols but cannot be calculated (missing USD pairs):');
                unavailableCrosses.forEach(item => {
                    console.warn(`  ${item.pair}: ${item.reason}`);
                });
            }

            return { availableCrosses, unavailableCrosses };
        }

        function validateUploadForCrossDerivation(spotData, impliedVols) {
            const errors = [];
            const warnings = [];

            // 1. Validate Spot Data contains only USD pairs
            const spotColumns = Object.keys(spotData).filter(col => col !== 'Timestamp' && col !== 'timestamp');
            spotColumns.forEach(column => {
                if (!column.includes('USD')) {
                    errors.push(`Invalid column in Spot Data: "${column}". Only USD pairs are allowed.`);
                }
            });

            if (errors.length > 0) return { valid: false, errors, warnings };

            // 2. Parse USD pairs and currencies
            const { usdPairs, currencies } = parseUSDPairs(spotColumns);

            if (usdPairs.length === 0) {
                errors.push('No USD pairs found in Spot Data. Please upload at least one USD pair.');
                return { valid: false, errors, warnings };
            }

            // 3. Check cross pairs in vol sheet
            const crossPairs = Object.keys(impliedVols).filter(p => !p.includes('USD'));

            crossPairs.forEach(crossPair => {
                if (crossPair.length !== 6) {
                    warnings.push(`Invalid cross pair format: "${crossPair}". Must be 6 characters (e.g., EURGBP).`);
                    return;
                }

                const { base, quote } = parseCrossPair(crossPair);

                if (!currencies.includes(base)) {
                    warnings.push(`Cannot calculate ${crossPair}: Missing USD pair for ${base}`);
                }
                if (!currencies.includes(quote)) {
                    warnings.push(`Cannot calculate ${crossPair}: Missing USD pair for ${quote}`);
                }
            });

            // 4. Check for missing vols in USD pairs
            usdPairs.forEach(pair => {
                if (impliedVols[pair] === undefined) {
                    warnings.push(`USD pair ${pair} has spot data but no implied vol. It will be excluded from analysis.`);
                }
            });

            return { valid: true, errors: [], warnings, usdPairs, currencies };
        }

        function getCurrencyName(code) {
            const names = {
                'EUR': 'EUR - Euro',
                'GBP': 'GBP - British Pound',
                'AUD': 'AUD - Australian Dollar',
                'NZD': 'NZD - New Zealand Dollar',
                'JPY': 'JPY - Japanese Yen',
                'CHF': 'CHF - Swiss Franc',
                'CAD': 'CAD - Canadian Dollar',
                'SGD': 'SGD - Singapore Dollar',
                'CNH': 'CNH - Chinese Yuan (Offshore)',
                'THB': 'THB - Thai Baht',
                'ZAR': 'ZAR - South African Rand',
                'MXN': 'MXN - Mexican Peso',
                'KRW': 'KRW - Korean Won',
                'INR': 'INR - Indian Rupee',
                'TRY': 'TRY - Turkish Lira',
                'BRL': 'BRL - Brazilian Real'
            };

            return names[code] || `${code} - ${code}`;
        }

        function buildCrossBlocks(availableCrosses, currencies) {
            const blocks = {};

            currencies.forEach(currency => {
                if (currency === 'USD') return; // Skip USD

                const pairsInBlock = availableCrosses.filter(pair =>
                    pair.includes(currency)
                );

                if (pairsInBlock.length > 0) {
                    blocks[currency] = pairsInBlock.sort();
                }
            });

            return blocks;
        }

        // ============ CORRELATION ANALYSIS FUNCTIONS ============

        // Currency precedence for canonical ordering
        const CURRENCY_PRECEDENCE = {
            'USD': 1,
            'EUR': 2,
            'GBP': 3,
            'JPY': 4,
            'CHF': 5,
            'AUD': 6,
            'NZD': 7,
            'CAD': 8,
            'SGD': 9,
            'CNH': 10,
            'THB': 11,
            'ZAR': 12,
            'MXN': 13,
            'KRW': 14,
            'INR': 15,
            'TRY': 16,
            'BRL': 17
        };

        function getCurrencyPrecedence(currency) {
            return CURRENCY_PRECEDENCE[currency] || 999; // Unknown currencies go last
        }

        function getCanonicalOrder(ccy1, ccy2) {
            // Returns currencies in precedence order
            // e.g., getCanonicalOrder('JPY', 'USD') ‚Üí ['USD', 'JPY']
            const prec1 = getCurrencyPrecedence(ccy1);
            const prec2 = getCurrencyPrecedence(ccy2);

            if (prec1 < prec2) {
                return [ccy1, ccy2];
            } else {
                return [ccy2, ccy1];
            }
        }

        function extractOtherCurrency(pairName, baseCurrency) {
            // Extract the non-base currency from a pair
            // pairName: 6 characters (e.g., "EURUSD", "USDJPY", "EURGBP")
            // baseCurrency: 3 characters (e.g., "USD", "EUR", "JPY")

            const ccy1 = pairName.substring(0, 3);
            const ccy2 = pairName.substring(3, 6);

            if (ccy1 === baseCurrency) {
                return ccy2;
            } else if (ccy2 === baseCurrency) {
                return ccy1;
            } else {
                // Pair doesn't contain baseCurrency - should not happen if filtered correctly
                console.error(`ERROR: ${pairName} does not contain ${baseCurrency}`);
                return null;
            }
        }

        function calculateImpliedCorrelation(pair1, pair2, crossPair, impliedVols) {
            let vol1 = impliedVols[pair1];
            let vol2 = impliedVols[pair2];
            let volCross = impliedVols[crossPair];

            // If cross pair not found, try inverse (volatility is symmetric)
            if (volCross === undefined || volCross === null) {
                const { base, quote } = parseCrossPair(crossPair);
                const inverseCrossPair = quote + base;
                volCross = impliedVols[inverseCrossPair];
            }

            if (vol1 === undefined || vol1 === null || vol2 === undefined || vol2 === null || volCross === undefined || volCross === null) {
                return null; // Missing data
            }

            // Formula: œÅ = (œÉ‚ÇÅ¬≤ + œÉ‚ÇÇ¬≤ - œÉ_cross¬≤) / (2 √ó œÉ‚ÇÅ √ó œÉ‚ÇÇ)
            const correlation = (vol1**2 + vol2**2 - volCross**2) / (2 * vol1 * vol2);

            // Clamp to [-1, 1] range (formula can give values outside due to vol surface arbitrage)
            return Math.max(-1, Math.min(1, correlation));
        }

        function calculateRealizedCorrelation(pair1, pair2, crossPair, realizedVols) {
            let vol1 = realizedVols[pair1];
            let vol2 = realizedVols[pair2];
            let volCross = realizedVols[crossPair];

            // If cross pair not found, try inverse (volatility is symmetric)
            if (volCross === undefined || volCross === null) {
                const { base, quote } = parseCrossPair(crossPair);
                const inverseCrossPair = quote + base;
                volCross = realizedVols[inverseCrossPair];
            }

            // Check for null/undefined, but allow 0 (zero volatility is valid)
            if (vol1 === undefined || vol1 === null || vol2 === undefined || vol2 === null || volCross === undefined || volCross === null) {
                return null; // Missing data
            }

            // Same formula as implied, but using realized vols
            const correlation = (vol1**2 + vol2**2 - volCross**2) / (2 * vol1 * vol2);

            // Clamp to [-1, 1] range
            return Math.max(-1, Math.min(1, correlation));
        }

        function normalizePairForCorrelation(pairName, baseCurrency) {
            // pairName: e.g., "USDJPY", "EURUSD", "GBPJPY"
            // baseCurrency: e.g., "USD", "JPY", "GBP"

            // Extract currencies
            let ccy1, ccy2;
            if (pairName.includes('USD')) {
                if (pairName.startsWith('USD')) {
                    ccy1 = 'USD';
                    ccy2 = pairName.substring(3, 6);
                } else {
                    ccy1 = pairName.substring(0, 3);
                    ccy2 = 'USD';
                }
            } else {
                ccy1 = pairName.substring(0, 3);
                ccy2 = pairName.substring(3, 6);
            }

            // Determine if we need to invert to normalize to baseCurrency
            if (ccy1 === baseCurrency) {
                return { normalized: `${ccy1}${ccy2}`, inverted: false };
            } else if (ccy2 === baseCurrency) {
                return { normalized: `${ccy2}${ccy1}`, inverted: true };
            } else {
                return null; // Pair doesn't contain baseCurrency
            }
        }

        function buildCorrelationGroups(analyzedPairs, currencies) {
            const groups = {};

            currencies.forEach(baseCurrency => {
                // Find all pairs containing this currency (exact match)
                const pairsWithCurrency = analyzedPairs.filter(pair => {
                    const ccy1 = pair.substring(0, 3);
                    const ccy2 = pair.substring(3, 6);
                    return ccy1 === baseCurrency || ccy2 === baseCurrency;
                });

                // CRITICAL: Remove duplicates using Set
                const uniquePairs = [...new Set(pairsWithCurrency)];

                console.log(`${baseCurrency} pairs before dedup: ${pairsWithCurrency.length}, after: ${uniquePairs.length}`);

                // Need at least 2 pairs to form correlations
                if (uniquePairs.length >= 2) {
                    groups[baseCurrency] = uniquePairs;
                }
            });

            return groups;
        }

        function calculateGroupCorrelations(baseCurrency, pairsInGroup, impliedVols, realizedVols) {
            console.log(`\n=== ${baseCurrency} Correlations ===`);
            console.log(`Pairs in group: ${pairsInGroup.join(', ')}`);

            const correlations = [];
            const processedPairs = new Set();

            // Extract other currencies from each pair
            const normalizedPairs = pairsInGroup.map(pair => {
                const otherCurrency = extractOtherCurrency(pair, baseCurrency);
                console.log(`  ${pair} with base ${baseCurrency} ‚Üí other currency: ${otherCurrency}`);
                return {
                    originalPair: pair,
                    otherCurrency: otherCurrency
                };
            });

            console.log(`Normalized pairs:`, normalizedPairs);

            // Generate all pairwise combinations
            for (let i = 0; i < normalizedPairs.length; i++) {
                for (let j = i + 1; j < normalizedPairs.length; j++) {
                    const pair1Data = normalizedPairs[i];
                    const pair2Data = normalizedPairs[j];

                    const ccy1 = pair1Data.otherCurrency;
                    const ccy2 = pair2Data.otherCurrency;

                    if (!ccy1 || !ccy2) {
                        console.warn(`  SKIP: Could not extract currencies`);
                        continue;
                    }

                    // Determine canonical order for display
                    const [canonCcy1, canonCcy2] = getCanonicalOrder(ccy1, ccy2);
                    
                    // Create canonical pair identifier to avoid duplicates
                    // Use original pair names for the key, not normalized ones
                    const pairKey = [pair1Data.originalPair, pair2Data.originalPair].sort().join('_');

                    if (processedPairs.has(pairKey)) {
                        console.log(`  SKIP: Already processed ${pair1Data.originalPair} vs ${pair2Data.originalPair}`);
                        continue;
                    }
                    processedPairs.add(pairKey);
                    
                    console.log(`  Processing: ${pair1Data.originalPair} vs ${pair2Data.originalPair}`);

                    // Find cross pair
                    const crossPair1 = ccy1 + ccy2;
                    const crossPair2 = ccy2 + ccy1;

                    console.log(`  Looking for cross pair between ${ccy1} and ${ccy2}: trying ${crossPair1} or ${crossPair2}`);

                    let crossPair = null;
                    if (impliedVols[crossPair1] !== undefined) {
                        crossPair = crossPair1;
                        console.log(`    ‚úì Found ${crossPair1}`);
                    } else if (impliedVols[crossPair2] !== undefined) {
                        crossPair = crossPair2;
                        console.log(`    ‚úì Found ${crossPair2}`);
                    } else {
                        console.log(`    ‚úó Missing both ${crossPair1} and ${crossPair2} - SKIPPING`);
                    }

                    if (!crossPair) {
                        console.log(`  SKIP: ${baseCurrency} correlation ${ccy1}/${ccy2} - missing cross pair vol`);
                        continue;
                    }

                    // Calculate
                    const impliedCorr = calculateImpliedCorrelation(
                        pair1Data.originalPair,
                        pair2Data.originalPair,
                        crossPair,
                        impliedVols
                    );

                    const realizedCorr = calculateRealizedCorrelation(
                        pair1Data.originalPair,
                        pair2Data.originalPair,
                        crossPair,
                        realizedVols
                    );

                    console.log(`  Calculated: impliedCorr=${impliedCorr}, realizedCorr=${realizedCorr}`);

                    if (impliedCorr !== null && realizedCorr !== null) {
                        const displayPair1 = baseCurrency + canonCcy1;
                        const displayPair2 = baseCurrency + canonCcy2;

                        correlations.push({
                            pair1: displayPair1,
                            pair2: displayPair2,
                            pair1Original: pair1Data.originalPair,
                            pair2Original: pair2Data.originalPair,
                            crossPair: crossPair,
                            impliedCorr: impliedCorr,
                            realizedCorr: realizedCorr,
                            difference: realizedCorr - impliedCorr
                        });

                        console.log(`  ‚úì ${displayPair1} vs ${displayPair2} (cross: ${crossPair})`);
                    } else {
                        console.log(`  ‚úó SKIPPED: impliedCorr=${impliedCorr}, realizedCorr=${realizedCorr}`);
                        if (impliedCorr === null) {
                            console.log(`    Missing implied vols: ${pair1Data.originalPair}=${impliedVols[pair1Data.originalPair]}, ${pair2Data.originalPair}=${impliedVols[pair2Data.originalPair]}, ${crossPair}=${impliedVols[crossPair]}`);
                        }
                        if (realizedCorr === null) {
                            console.log(`    Missing realized vols: ${pair1Data.originalPair}=${realizedVols[pair1Data.originalPair]}, ${pair2Data.originalPair}=${realizedVols[pair2Data.originalPair]}, ${crossPair}=${realizedVols[crossPair]}`);
                        }
                    }
                }
            }

            console.log(`${baseCurrency}: ${pairsInGroup.length} pairs ‚Üí ${correlations.length} correlations`);

            return correlations;
        }

        function testCorrelationLogic() {
            // Test data
            const testPairs = ['EURUSD', 'GBPUSD', 'USDJPY', 'EURJPY', 'GBPJPY', 'EURGBP'];
            const testCurrencies = ['USD', 'EUR', 'GBP', 'JPY'];

            console.log('\n=== CORRELATION LOGIC TEST ===\n');

            // Test buildCorrelationGroups
            const groups = buildCorrelationGroups(testPairs, testCurrencies);

            Object.keys(groups).forEach(currency => {
                console.log(`\n${currency} Group:`);
                console.log(`  Pairs: ${groups[currency].join(', ')}`);
                console.log(`  Expected correlations: ${groups[currency].length * (groups[currency].length - 1) / 2}`);

                // Test extractOtherCurrency for each pair
                groups[currency].forEach(pair => {
                    const other = extractOtherCurrency(pair, currency);
                    console.log(`    ${pair} ‚Üí other: ${other}`);
                });
            });

            console.log('\n=== Expected Results ===');
            console.log('USD: 3 pairs (EURUSD, GBPUSD, USDJPY) ‚Üí 3 correlations');
            console.log('  1. USD/EUR vs USD/GBP (cross: EURGBP)');
            console.log('  2. USD/EUR vs USD/JPY (cross: EURJPY)');
            console.log('  3. USD/GBP vs USD/JPY (cross: GBPJPY)');

            console.log('\nEUR: 3 pairs (EURUSD, EURJPY, EURGBP) ‚Üí 3 correlations');
            console.log('  1. EUR/USD vs EUR/GBP (cross: GBPUSD)');
            console.log('  2. EUR/USD vs EUR/JPY (cross: USDJPY)');
            console.log('  3. EUR/GBP vs EUR/JPY (cross: GBPJPY)');

            console.log('\nGBP: 3 pairs (GBPUSD, GBPJPY, EURGBP) ‚Üí 3 correlations');
            console.log('  1. GBP/USD vs GBP/EUR (cross: EURUSD)');
            console.log('  2. GBP/USD vs GBP/JPY (cross: USDJPY)');
            console.log('  3. GBP/EUR vs GBP/JPY (cross: EURJPY)');

            console.log('\nJPY: 3 pairs (USDJPY, EURJPY, GBPJPY) ‚Üí 3 correlations');
            console.log('  1. JPY/USD vs JPY/EUR (cross: EURUSD)');
            console.log('  2. JPY/USD vs JPY/GBP (cross: GBPUSD)');
            console.log('  3. JPY/EUR vs JPY/GBP (cross: EURGBP)');
        }

        function calculateAllCorrelations(analyzedPairs, currencies, impliedVols, realizedVols, selectedCurrencies) {
            const allCorrelations = {};

            // Build correlation groups
            const groups = buildCorrelationGroups(analyzedPairs, currencies);

            // Calculate correlations for selected currency groups
            Object.keys(groups).forEach(baseCurrency => {
                if (selectedCurrencies.includes(baseCurrency)) {
                    const pairsInGroup = groups[baseCurrency];
                    const correlations = calculateGroupCorrelations(
                        baseCurrency,
                        pairsInGroup,
                        impliedVols,
                        realizedVols
                    );

                    if (correlations.length > 0) {
                        allCorrelations[baseCurrency] = {
                            correlations: correlations,
                            avgImpliedCorr: correlations.reduce((sum, c) => sum + c.impliedCorr, 0) / correlations.length,
                            avgRealizedCorr: correlations.reduce((sum, c) => sum + c.realizedCorr, 0) / correlations.length,
                            avgDifference: correlations.reduce((sum, c) => sum + c.difference, 0) / correlations.length,
                            count: correlations.length
                        };
                    }
                }
            });

            return allCorrelations;
        }

        function formatCorrelation(correlation) {
            // Convert to percentage, no decimals
            // 0.8724 ‚Üí 87%
            // -0.4521 ‚Üí -45%
            const percent = Math.round(correlation * 100);
            return percent >= 0 ? `${percent}%` : `${percent}%`;
        }

        function formatCorrelationDiff(difference) {
            // Convert to percentage with sign, no decimals
            // 0.0734 ‚Üí +7%
            // -0.0421 ‚Üí -4%
            const percent = Math.round(difference * 100);
            const sign = percent > 0 ? '+' : '';
            return `${sign}${percent}%`;
        }

        /**
         * Generate display for correlation matrix via intermediates
         * Shows ALL possible pairs (rows) vs intermediate currencies (columns)
         * Rows are sorted by currency groups (USD pairs first, then EUR pairs, etc.)
         * For 8 currencies: 8*7 = 56 pairs (exhaustive list)
         */
        function generateCorrelationMatrixDisplay(correlationMatrix, currencies = []) {
            if (!correlationMatrix || Object.keys(correlationMatrix).length === 0) {
                return '<div class="info-box"><p>No correlation matrix data available.</p></div>';
            }
            
            // Get all available currencies - use provided currencies or extract from matrix
            let allCurrencies;
            if (currencies && currencies.length > 0) {
                allCurrencies = new Set(currencies);
            } else {
                // Fallback: extract from matrix
                allCurrencies = new Set();
                Object.keys(correlationMatrix).forEach(pair => {
                    allCurrencies.add(pair.substring(0, 3));
                    allCurrencies.add(pair.substring(3, 6));
                });
            }
            
            // Get all intermediate currencies
            const allIntermediates = new Set();
            Object.keys(correlationMatrix).forEach(pair => {
                if (correlationMatrix[pair].viaIntermediates) {
                    Object.keys(correlationMatrix[pair].viaIntermediates).forEach(intermediate => {
                        allIntermediates.add(intermediate);
                    });
                }
            });
            
            // Fixed currency order: USD, EUR, GBP, CHF, JPY, AUD, NZD, CAD
            // Use this order for intermediates (columns) to match row ordering
            const currencyOrder = ['USD', 'EUR', 'GBP', 'CHF', 'JPY', 'AUD', 'NZD', 'CAD'];
            const currencyOrderMap = {};
            currencyOrder.forEach((ccy, idx) => {
                currencyOrderMap[ccy] = idx;
            });
            
            // Function to get currency order (use fixed order if available, otherwise use existing function)
            function getCurrencyOrder(currency) {
                if (currencyOrderMap.hasOwnProperty(currency)) {
                    return currencyOrderMap[currency];
                }
                return getCurrencyPrecedence(currency) + 1000; // Put unknown currencies after known ones
            }
            
            const intermediates = Array.from(allIntermediates).sort((a, b) => {
                return getCurrencyOrder(a) - getCurrencyOrder(b);
            });
            
            if (intermediates.length === 0) {
                return '<div class="info-box"><p>No intermediate currency data available.</p></div>';
            }
            
            // Generate ALL possible pairs from available currencies (exhaustive list)
            // For 8 currencies: 8 * 7 = 56 pairs
            // Order currencies by fixed order
            const currenciesList = Array.from(allCurrencies).sort((a, b) => {
                return getCurrencyOrder(a) - getCurrencyOrder(b);
            });
            
            const allPossiblePairs = [];
            currenciesList.forEach(baseCurrency => {
                currenciesList.forEach(quoteCurrency => {
                    if (baseCurrency !== quoteCurrency) {
                        allPossiblePairs.push(baseCurrency + quoteCurrency);
                    }
                });
            });
            
            // Sort pairs by currency groups (base currency first, then by quote currency)
            // Group by base currency, then sort within groups by quote currency order
            const pairsByCurrency = {};
            allPossiblePairs.forEach(pair => {
                const baseCurrency = pair.substring(0, 3);
                if (!pairsByCurrency[baseCurrency]) {
                    pairsByCurrency[baseCurrency] = [];
                }
                pairsByCurrency[baseCurrency].push(pair);
            });
            
            // Sort currencies by fixed order
            const sortedCurrencies = Object.keys(pairsByCurrency).sort((a, b) => {
                return getCurrencyOrder(a) - getCurrencyOrder(b);
            });
            
            const sortedPairs = [];
            sortedCurrencies.forEach((currency, idx) => {
                // Sort pairs within each group by quote currency order
                const pairs = pairsByCurrency[currency].sort((a, b) => {
                    const quoteA = a.substring(3, 6);
                    const quoteB = b.substring(3, 6);
                    return getCurrencyOrder(quoteA) - getCurrencyOrder(quoteB);
                });
                sortedPairs.push(...pairs);
                // Add separator after each currency group (except the last one)
                if (idx < sortedCurrencies.length - 1) {
                    sortedPairs.push({ isSeparator: true });
                }
            });
            
            // Calculate scales for color coding (only from pairs that have data)
            const scales = {
                impliedCorr: { min: Infinity, max: -Infinity },
                realizedCorr: { min: Infinity, max: -Infinity },
                corrDiff: { min: Infinity, max: -Infinity }
            };
            
            allPossiblePairs.forEach(pair => {
                if (correlationMatrix[pair] && correlationMatrix[pair].viaIntermediates) {
                    Object.values(correlationMatrix[pair].viaIntermediates).forEach(data => {
                        scales.impliedCorr.min = Math.min(scales.impliedCorr.min, data.impliedCorr);
                        scales.impliedCorr.max = Math.max(scales.impliedCorr.max, data.impliedCorr);
                        scales.realizedCorr.min = Math.min(scales.realizedCorr.min, data.realizedCorr);
                        scales.realizedCorr.max = Math.max(scales.realizedCorr.max, data.realizedCorr);
                        scales.corrDiff.min = Math.min(scales.corrDiff.min, data.difference);
                        scales.corrDiff.max = Math.max(scales.corrDiff.max, data.difference);
                    });
                }
            });
            
            // Calculate row averages for each pair
            const rowAverages = {};
            allPossiblePairs.forEach(pair => {
                let sumImpl = 0, sumReal = 0, sumDiff = 0, count = 0;
                
                intermediates.forEach(intermediate => {
                    const data = correlationMatrix[pair]?.viaIntermediates?.[intermediate];
                    if (data) {
                        sumImpl += data.impliedCorr;
                        sumReal += data.realizedCorr;
                        sumDiff += data.difference;
                        count++;
                    }
                });
                
                if (count > 0) {
                    rowAverages[pair] = {
                        impliedCorr: sumImpl / count,
                        realizedCorr: sumReal / count,
                        difference: sumDiff / count,
                        count: count
                    };
                }
            });
            
            // Calculate averages across intermediates
            const intermediateAverages = {};
            intermediates.forEach(intermediate => {
                let sumImpl = 0, sumReal = 0, sumDiff = 0, count = 0;
                
                allPossiblePairs.forEach(pair => {
                    const data = correlationMatrix[pair]?.viaIntermediates?.[intermediate];
                    if (data) {
                        sumImpl += data.impliedCorr;
                        sumReal += data.realizedCorr;
                        sumDiff += data.difference;
                        count++;
                    }
                });
                
                if (count > 0) {
                    intermediateAverages[intermediate] = {
                        impliedCorr: sumImpl / count,
                        realizedCorr: sumReal / count,
                        difference: sumDiff / count,
                        count: count
                    };
                }
            });
            
            // Build table HTML
            let html = `
            <div class="card" style="overflow-x: auto;">
                <div style="margin-bottom: 16px;">
                    <p style="color: var(--text-secondary); font-size: 13px; margin-bottom: 8px;">
                        Shows correlations of all pairs calculated via different intermediate currencies.
                        Each cell shows: Implied Corr | Realized Corr | Difference
                    </p>
                    <p style="color: var(--text-secondary); font-size: 12px;">
                        Rows are grouped by base currency (USD pairs first, then EUR pairs, etc.). Rightmost column shows average across all intermediates.
                    </p>
                </div>
                <table class="data-table" style="min-width: 800px; font-size: 11px;">
                    <thead>
                        <tr>
                            <th style="position: sticky; left: 0; background: var(--bg-elevated); z-index: 10; padding: 4px 6px; text-align: left; border-right: 2px solid var(--border);">Pair</th>`;

            // Header row with intermediate currencies
            intermediates.forEach(intermediate => {
                html += `
                            <th style="padding: 4px 4px; text-align: center; min-width: 110px; background: var(--bg-elevated);">
                                <div style="font-weight: 600; margin-bottom: 2px;">Via ${intermediate}</div>
                                <div style="font-size: 9px; color: var(--text-muted); font-weight: normal;">Impl | Real | Diff</div>
                            </th>`;
            });

            // Add average column header
            html += `
                            <th style="padding: 4px 4px; text-align: center; min-width: 110px; background: var(--bg-elevated); border-left: 2px solid var(--border);">
                                <div style="font-weight: 600; margin-bottom: 2px;">AVERAGE</div>
                                <div style="font-size: 9px; color: var(--text-muted); font-weight: normal;">Impl | Real | Diff</div>
                            </th>`;
            
            html += `
                        </tr>
                    </thead>
                    <tbody>`;
            
            // Data rows
            sortedPairs.forEach((pair, idx) => {
                // Check if this is a separator
                if (pair && typeof pair === 'object' && pair.isSeparator) {
                    // Add a simple dividing line
                    html += `
                        <tr>
                            <td colspan="${intermediates.length + 2}" style="padding: 0; border-top: 2px solid var(--border-strong);"></td>
                        </tr>`;
                    return;
                }
                
                // Regular data row
                html += `
                        <tr>
                            <td style="position: sticky; left: 0; background: var(--bg-main); z-index: 9; padding: 3px 6px; font-weight: 600; border-right: 2px solid var(--border); font-size: 11px; white-space: nowrap;">${pair}</td>`;

                intermediates.forEach(intermediate => {
                    const data = correlationMatrix[pair]?.viaIntermediates?.[intermediate];
                    
                    if (data) {
                        const implBgColor = getCellColor(data.impliedCorr, scales.impliedCorr);
                        const realBgColor = getCellColor(data.realizedCorr, scales.realizedCorr);
                        const diffBgColor = getCellColor(data.difference, scales.corrDiff);
                        
                        const implTextColor = getTextColorForBackground(implBgColor);
                        const realTextColor = getTextColorForBackground(realBgColor);
                        const diffTextColor = getTextColorForBackground(diffBgColor);
                        
                        html += `
                            <td style="padding: 3px 3px; text-align: center;">
                                <div style="display: flex; gap: 3px; justify-content: center; align-items: center;">
                                    <span style="padding: 2px 4px; border-radius: 3px; background-color: ${implBgColor}; color: ${implTextColor}; font-weight: 500; font-size: 10px;">
                                        ${formatCorrInteger(data.impliedCorr)}
                                    </span>
                                    <span style="padding: 2px 4px; border-radius: 3px; background-color: ${realBgColor}; color: ${realTextColor}; font-weight: 500; font-size: 10px;">
                                        ${formatCorrInteger(data.realizedCorr)}
                                    </span>
                                    <span style="padding: 2px 4px; border-radius: 3px; background-color: ${diffBgColor}; color: ${diffTextColor}; font-weight: 600; font-size: 10px;">
                                        ${data.difference >= 0 ? '+' : ''}${formatCorrInteger(data.difference)}
                                    </span>
                                </div>
                            </td>`;
                    } else {
                        html += `
                            <td style="padding: 3px 3px; text-align: center; color: var(--text-muted);">‚Äî</td>`;
                    }
                });
                
                // Add row average
                const rowAvg = rowAverages[pair];
                if (rowAvg) {
                    const implBgColor = getCellColor(rowAvg.impliedCorr, scales.impliedCorr);
                    const realBgColor = getCellColor(rowAvg.realizedCorr, scales.realizedCorr);
                    const diffBgColor = getCellColor(rowAvg.difference, scales.corrDiff);
                    
                    const implTextColor = getTextColorForBackground(implBgColor);
                    const realTextColor = getTextColorForBackground(realBgColor);
                    const diffTextColor = getTextColorForBackground(diffBgColor);
                    
                    html += `
                            <td style="padding: 3px 3px; text-align: center; border-left: 2px solid var(--border-strong);">
                                <div style="display: flex; gap: 3px; justify-content: center; align-items: center;">
                                    <span style="padding: 2px 4px; border-radius: 3px; background-color: ${implBgColor}; color: ${implTextColor}; font-weight: 700; font-size: 10px;">
                                        ${formatCorrInteger(rowAvg.impliedCorr)}
                                    </span>
                                    <span style="padding: 2px 4px; border-radius: 3px; background-color: ${realBgColor}; color: ${realTextColor}; font-weight: 700; font-size: 10px;">
                                        ${formatCorrInteger(rowAvg.realizedCorr)}
                                    </span>
                                    <span style="padding: 2px 4px; border-radius: 3px; background-color: ${diffBgColor}; color: ${diffTextColor}; font-weight: 700; font-size: 10px;">
                                        ${rowAvg.difference >= 0 ? '+' : ''}${formatCorrInteger(rowAvg.difference)}
                                    </span>
                                </div>
                            </td>`;
                } else {
                    html += `
                            <td style="padding: 3px 3px; text-align: center; color: var(--text-muted); border-left: 2px solid var(--border-strong);">‚Äî</td>`;
                }
                
                html += `
                        </tr>`;
            });
            
            // Average row (column averages)
            html += `
                    </tbody>
                    <tfoot>
                        <tr style="border-top: 2px solid var(--cyan); background: var(--bg-elevated);">
                            <td style="position: sticky; left: 0; background: var(--bg-elevated); z-index: 9; padding: 6px 8px; font-weight: 700; color: var(--cyan); border-right: 2px solid var(--border);">AVERAGE</td>`;
            
            intermediates.forEach(intermediate => {
                const avg = intermediateAverages[intermediate];
                if (avg) {
                    const implBgColor = getCellColor(avg.impliedCorr, scales.impliedCorr);
                    const realBgColor = getCellColor(avg.realizedCorr, scales.realizedCorr);
                    const diffBgColor = getCellColor(avg.difference, scales.corrDiff);
                    
                    const implTextColor = getTextColorForBackground(implBgColor);
                    const realTextColor = getTextColorForBackground(realBgColor);
                    const diffTextColor = getTextColorForBackground(diffBgColor);
                    
                    html += `
                            <td style="padding: 3px 3px; text-align: center;">
                                <div style="display: flex; gap: 3px; justify-content: center; align-items: center;">
                                    <span style="padding: 2px 4px; border-radius: 3px; background-color: ${implBgColor}; color: ${implTextColor}; font-weight: 700; font-size: 10px;">
                                        ${formatCorrInteger(avg.impliedCorr)}
                                    </span>
                                    <span style="padding: 2px 4px; border-radius: 3px; background-color: ${realBgColor}; color: ${realTextColor}; font-weight: 700; font-size: 10px;">
                                        ${formatCorrInteger(avg.realizedCorr)}
                                    </span>
                                    <span style="padding: 2px 4px; border-radius: 3px; background-color: ${diffBgColor}; color: ${diffTextColor}; font-weight: 700; font-size: 10px;">
                                        ${avg.difference >= 0 ? '+' : ''}${formatCorrInteger(avg.difference)}
                                    </span>
                                </div>
                            </td>`;
                } else {
                    html += `
                            <td style="padding: 3px 3px; text-align: center; color: var(--text-muted);">‚Äî</td>`;
                }
            });
            
            // Average of averages (grand average in the rightmost column)
            let grandSumImpl = 0, grandSumReal = 0, grandSumDiff = 0, grandCount = 0;
            Object.values(rowAverages).forEach(avg => {
                grandSumImpl += avg.impliedCorr;
                grandSumReal += avg.realizedCorr;
                grandSumDiff += avg.difference;
                grandCount++;
            });
            
            if (grandCount > 0) {
                const grandAvg = {
                    impliedCorr: grandSumImpl / grandCount,
                    realizedCorr: grandSumReal / grandCount,
                    difference: grandSumDiff / grandCount
                };
                
                const implBgColor = getCellColor(grandAvg.impliedCorr, scales.impliedCorr);
                const realBgColor = getCellColor(grandAvg.realizedCorr, scales.realizedCorr);
                const diffBgColor = getCellColor(grandAvg.difference, scales.corrDiff);
                
                const implTextColor = getTextColorForBackground(implBgColor);
                const realTextColor = getTextColorForBackground(realBgColor);
                const diffTextColor = getTextColorForBackground(diffBgColor);
                
                html += `
                            <td style="padding: 3px 3px; text-align: center; border-left: 2px solid var(--border-strong);">
                                <div style="display: flex; gap: 3px; justify-content: center; align-items: center;">
                                    <span style="padding: 2px 4px; border-radius: 3px; background-color: ${implBgColor}; color: ${implTextColor}; font-weight: 700; font-size: 10px;">
                                        ${formatCorrInteger(grandAvg.impliedCorr)}
                                    </span>
                                    <span style="padding: 2px 4px; border-radius: 3px; background-color: ${realBgColor}; color: ${realTextColor}; font-weight: 700; font-size: 10px;">
                                        ${formatCorrInteger(grandAvg.realizedCorr)}
                                    </span>
                                    <span style="padding: 2px 4px; border-radius: 3px; background-color: ${diffBgColor}; color: ${diffTextColor}; font-weight: 700; font-size: 10px;">
                                        ${grandAvg.difference >= 0 ? '+' : ''}${formatCorrInteger(grandAvg.difference)}
                                    </span>
                                </div>
                            </td>`;
            } else {
                html += `
                            <td style="padding: 3px 3px; text-align: center; color: var(--text-muted); border-left: 2px solid var(--border-strong);">‚Äî</td>`;
            }
            
            html += `
                        </tr>
                    </tfoot>
                </table>
            </div>`;
            
            return html;
        }

        // ============ CORRELATION MATRIX VIA INTERMEDIATE CURRENCIES ============
        
        /**
         * Calculate correlation matrix showing correlations of cross pairs via different intermediate currencies
         * For example: NZD/CHF via USD = correlation(USD/NZD, USD/CHF)
         * Normalization: Always use INTERMEDIATE/CURRENCY format (e.g., USD/NZD, USD/CHF)
         */
        function calculateCorrelationMatrixViaIntermediates(analyzedPairs, currencies, impliedVols, realizedVols) {
            const matrix = {};
            
            // Generate ALL possible pairs from available currencies (both directions)
            // For 8 currencies, this gives 8*7 = 56 pairs
            const allPossiblePairs = [];
            currencies.forEach(baseCurrency => {
                currencies.forEach(quoteCurrency => {
                    if (baseCurrency !== quoteCurrency) {
                        const pair = baseCurrency + quoteCurrency;
                        allPossiblePairs.push(pair);
                    }
                });
            });
            
            console.log('Calculating correlation matrix via intermediates...');
            console.log('All possible pairs:', allPossiblePairs.length, 'pairs from', currencies.length, 'currencies');
            console.log('Available intermediates:', currencies);
            
            // For each possible pair
            allPossiblePairs.forEach(pair => {
                const { base, quote } = parseCrossPair(pair);
                const pairData = {
                    pair: pair,
                    base: base,
                    quote: quote,
                    viaIntermediates: {}
                };
                
                // For each intermediate currency
                currencies.forEach(intermediate => {
                    // Skip if intermediate is one of the currencies in the pair
                    if (intermediate === base || intermediate === quote) {
                        return;
                    }
                    
                    // Get normalized pairs: INTERMEDIATE/BASE and INTERMEDIATE/QUOTE
                    const pair1Normalized = getNormalizedPairForIntermediate(base, intermediate, analyzedPairs);
                    const pair2Normalized = getNormalizedPairForIntermediate(quote, intermediate, analyzedPairs);
                    
                    if (!pair1Normalized || !pair2Normalized) {
                        // Missing data for this intermediate
                        return;
                    }
                    
                    // For the cross pair itself, check if we need to use inverse
                    // e.g., if we need USDGBP but only have GBPUSD, use GBPUSD (inverted)
                    let crossPairForCalc = pair;
                    let crossPairInverted = false;
                    if (!impliedVols[pair] && !realizedVols[pair]) {
                        // Try inverse
                        const inversePair = quote + base;
                        if (impliedVols[inversePair] || realizedVols[inversePair]) {
                            crossPairForCalc = inversePair;
                            crossPairInverted = true;
                        }
                    }
                    
                    // Calculate implied correlation
                    const impliedCorr = calculateImpliedCorrelation(
                        pair1Normalized.pair,
                        pair2Normalized.pair,
                        crossPairForCalc,
                        impliedVols
                    );
                    
                    // Calculate realized correlation
                    const realizedCorr = calculateRealizedCorrelation(
                        pair1Normalized.pair,
                        pair2Normalized.pair,
                        crossPairForCalc,
                        realizedVols
                    );
                    
                    if (impliedCorr !== null && realizedCorr !== null) {
                        pairData.viaIntermediates[intermediate] = {
                            pair1: pair1Normalized.pair,
                            pair2: pair2Normalized.pair,
                            pair1Inverted: pair1Normalized.inverted,
                            pair2Inverted: pair2Normalized.inverted,
                            impliedCorr: impliedCorr,
                            realizedCorr: realizedCorr,
                            difference: realizedCorr - impliedCorr
                        };
                    }
                });
                
                // Include pair in matrix even if no data (will show dashes)
                matrix[pair] = pairData;
            });
            
            console.log('Correlation matrix calculated:', Object.keys(matrix).length, 'pairs');
            return matrix;
        }
        
        /**
         * Get normalized pair for intermediate currency
         * For correlation via intermediate, we need INTERMEDIATE/CURRENCY format
         * Returns the actual pair name found (volatility is symmetric, so no inversion needed)
         */
        function getNormalizedPairForIntermediate(currency, intermediate, analyzedPairs) {
            // Try direct: INTERMEDIATE/CURRENCY (e.g., USDNZD for USD/NZD)
            const directPair = intermediate + currency;
            if (analyzedPairs.includes(directPair)) {
                return { pair: directPair, normalized: directPair };
            }
            
            // Try inverted: CURRENCY/INTERMEDIATE (e.g., NZDUSD for NZD/USD)
            // For correlation, vol(NZD/USD) = vol(USD/NZD), so we can use it directly
            const invertedPair = currency + intermediate;
            if (analyzedPairs.includes(invertedPair)) {
                return { pair: invertedPair, normalized: directPair }; // Return actual pair, but note normalized form
            }
            
            // Not found
            return null;
        }

        function detectFrequency(timestamps) {
            // Filter out any null/undefined timestamps
            const validTimestamps = timestamps.filter(t => t != null);

            if (validTimestamps.length < 2) {
                throw new Error('Need at least 2 valid timestamps to detect frequency');
            }

            let t1, t2;

            // Handle different timestamp formats
            if (validTimestamps[0] instanceof Date) {
                // Already a Date object from SheetJS
                t1 = validTimestamps[0];
                t2 = validTimestamps[1];
            } else if (typeof validTimestamps[0] === 'string') {
                // String format - parse it
                t1 = new Date(validTimestamps[0]);
                t2 = new Date(validTimestamps[1]);
            } else if (typeof validTimestamps[0] === 'number') {
                // Excel serial number - convert to Date
                // Excel epoch is 1900-01-01 (but with a leap year bug, we use 1899-12-30)
                const excelEpoch = new Date(1899, 11, 30);
                t1 = new Date(excelEpoch.getTime() + validTimestamps[0] * 86400000);
                t2 = new Date(excelEpoch.getTime() + validTimestamps[1] * 86400000);
            }

            // Validate dates
            if (isNaN(t1.getTime()) || isNaN(t2.getTime())) {
                console.error('Invalid timestamps:', validTimestamps[0], validTimestamps[1]);
                throw new Error('Could not parse timestamps');
            }

            // Calculate difference in minutes
            const diffMs = t2 - t1;
            const diffMinutes = Math.round(diffMs / (1000 * 60));

            console.log('Detected frequency:', diffMinutes, 'minutes between', t1, 'and', t2);

            if (diffMinutes <= 0) {
                throw new Error('Invalid frequency detected: ' + diffMinutes + ' minutes');
            }

            return diffMinutes;
        }

        function displayPairSelection() {
            const usdPairs = batchData.usdPairs || [];
            const availableCrosses = batchData.availableCrosses || [];
            const currencies = batchData.currencies || [];

            let html = `
                <div class="card-header">
                    Select Currency Pairs to Analyze
                    <span class="pair-counter" id="pairCounter">0 selected</span>
                </div>

                <div id="crossWarnings"></div>
            `;

            // Display warnings for unavailable crosses
            if (batchData.unavailableCrosses && batchData.unavailableCrosses.length > 0) {
                html += `
                    <div class="alert alert-warning" style="margin: 16px 0;">
                        <strong>Note:</strong> ${batchData.unavailableCrosses.length} cross pair(s) have implied vols 
                        but cannot be calculated because required USD pairs are missing:
                        <ul style="margin-top: 8px;">
                            ${batchData.unavailableCrosses.map(item =>
                                `<li>${item.pair} - ${item.reason}</li>`
                            ).join('')}
                        </ul>
                    </div>
                `;
            }

            // USD Pairs section
            html += `
                <div class="pair-group" style="margin-bottom: 24px;">
                    <h4>USD Pairs (${usdPairs.length} available)</h4>
                    <div class="pair-grid" id="usdPairGrid">`;

            usdPairs.forEach(pair => {
                html += `
                    <label class="pair-checkbox">
                        <input type="checkbox" name="pair" value="${pair}" checked onchange="updatePairCounter()">
                        <span>${pair}</span>
                    </label>`;
            });

            html += `
                    </div>
                </div>`;

            // Build currency blocks for crosses
            const crossBlocks = buildCrossBlocks(availableCrosses, currencies);

            // Display each currency block
            Object.keys(crossBlocks).sort().forEach(currency => {
                const pairs = crossBlocks[currency];
                const currencyName = getCurrencyName(currency);

                html += `
                <div class="pair-group" style="margin-bottom: 24px;">
                    <h4>${currencyName} Crosses (${pairs.length} available)</h4>
                    <div class="pair-grid" id="${currency}CrossGrid">`;

                pairs.forEach(pair => {
                    html += `
                        <label class="pair-checkbox">
                            <input type="checkbox" name="pair" value="${pair}" checked onchange="updatePairCounter()">
                            <span>${pair}</span>
                        </label>`;
                });

                html += `
                    </div>
                </div>`;
            });

            // Selection buttons
            html += `
                <div style="margin-top: 24px; display: flex; gap: 12px; flex-wrap: wrap;">
                    <button class="btn btn-secondary" onclick="selectAllPairs()">Select All</button>
                    <button class="btn btn-secondary" onclick="deselectAllPairs()">Deselect All</button>
                    <button class="btn btn-secondary" onclick="selectUSDOnly()">USD Pairs Only</button>
                    <button class="btn btn-secondary" onclick="selectG10Only()">G10 Only</button>
                </div>

                <button class="btn btn-primary btn-large" onclick="startBatchCalculation()" 
                        style="width: 100%; margin-top: 24px;">
                    Calculate Selected Pairs
                </button>
            `;

            const section = document.getElementById('pairSelectionSection');
            section.innerHTML = html;
            section.style.display = 'block';

            updatePairCounter();

            // Show correlation group selection if enabled
            if (document.getElementById('includeCorrelationAnalysis') && document.getElementById('includeCorrelationAnalysis').checked) {
                const correlationGroups = buildCorrelationGroups(
                    [...usdPairs, ...availableCrosses],
                    currencies
                );
                displayCorrelationGroupSelection(correlationGroups);
            } else {
                document.getElementById('correlationGroupSelection').style.display = 'none';
            }
        }

        function selectAllPairs() {
            document.querySelectorAll('input[name="pair"]').forEach(cb => cb.checked = true);
            updatePairCounter();
        }

        function deselectAllPairs() {
            document.querySelectorAll('input[name="pair"]').forEach(cb => cb.checked = false);
            updatePairCounter();
        }

        function selectUSDOnly() {
            document.querySelectorAll('input[name="pair"]').forEach(cb => {
                cb.checked = cb.value.includes('USD');
            });
            updatePairCounter();
        }

        function selectG10Only() {
            const g10Currencies = ['EUR', 'GBP', 'AUD', 'NZD', 'JPY', 'CHF', 'CAD'];
            document.querySelectorAll('input[name="pair"]').forEach(cb => {
                const pair = cb.value;
                const hasG10 = g10Currencies.some(ccy => pair.includes(ccy));
                cb.checked = hasG10;
            });
            updatePairCounter();
        }

        function updatePairCounter() {
            const checked = document.querySelectorAll('input[name="pair"]:checked').length;
            const counter = document.getElementById('pairCounter');
            if (counter) {
                counter.textContent = `${checked} selected`;
            }
        }

        function displayCorrelationGroupSelection(correlationGroups) {
            if (!document.getElementById('includeCorrelationAnalysis') || !document.getElementById('includeCorrelationAnalysis').checked) {
                document.getElementById('correlationGroupSelection').style.display = 'none';
                return; // Correlation analysis disabled
            }

            const currencies = Object.keys(correlationGroups).sort();

            if (currencies.length === 0) {
                document.getElementById('correlationGroupSelection').style.display = 'none';
                return; // No correlation groups available
            }

            let html = `
                <div class="card-header">
                    Select Currency Groups for Correlation Analysis
                </div>

                <div class="pair-group">
                    <h4>Available Currency Groups</h4>
                    <p style="font-size: 13px; color: #6b7280; margin-bottom: 16px;">
                        Select which currency groups to analyze for realized vs implied correlations.
                        Each group requires at least 2 pairs with the common currency.
                    </p>

                    <div class="pair-grid">`;

            currencies.forEach(currency => {
                const pairCount = correlationGroups[currency].length;
                const corrCount = (pairCount * (pairCount - 1)) / 2; // n choose 2
                const isUSD = currency === 'USD';

                html += `
                    <label class="pair-checkbox">
                        <input type="checkbox" name="corrGroup" value="${currency}" ${isUSD ? 'checked' : ''}>
                        <span>${getCurrencyName(currency)}</span>
                        <div style="font-size: 11px; color: #6b7280; margin-top: 2px;">
                            ${pairCount} pairs, ${corrCount} correlations
                        </div>
                    </label>`;
            });

            html += `
                    </div>
                </div>

                <div style="margin-top: 16px;">
                    <button class="btn btn-secondary btn-sm" onclick="selectAllCorrGroups()">Select All</button>
                    <button class="btn btn-secondary btn-sm" onclick="deselectAllCorrGroups()">Deselect All</button>
                </div>
            `;

            const section = document.getElementById('correlationGroupSelection');
            section.innerHTML = html;
            section.style.display = 'block';
        }

        function selectAllCorrGroups() {
            document.querySelectorAll('input[name="corrGroup"]').forEach(cb => cb.checked = true);
        }

        function deselectAllCorrGroups() {
            document.querySelectorAll('input[name="corrGroup"]').forEach(cb => cb.checked = false);
        }

        function showBatchMessage(message, type = 'verification') {
            const div = document.getElementById('uploadStatus');
            let html = `<div class="${type}" style="margin: 10px 0;">${message}</div>`;

            // Add re-upload button for successful uploads
            if (type === 'verification') {
                html += `<button class="secondary" style="margin-top: 10px;" onclick="resetUpload()">Upload Different File</button>`;
            }

            div.innerHTML = html;
        }

        function resetUpload() {
            // Clear batch data
            batchData = {
                timestamps: [],
                spotPrices: {},
                impliedVols: {},
                pairNames: [],
                frequency: 10,
                results: {},
                fullDataRange: null,
                usdPairs: [],
                currencies: [],
                availableCrosses: [],
                unavailableCrosses: []
            };

            // Clear file input
            document.getElementById('excelFileInput').value = '';

            // Hide all sections
            document.getElementById('uploadStatus').innerHTML = '';
            document.getElementById('batchConfigSection').style.display = 'none';
            document.getElementById('analysisWindowSection').style.display = 'none';
            document.getElementById('pairSelectionSection').style.display = 'none';
            document.getElementById('batchResultsSection').style.display = 'none';

            // Show upload section
            document.querySelector('.upload-section').style.display = 'block';
        }

        function toggleBatchExpiryMode() {
            const customRadio = document.getElementById('customExpiryRadio');
            const customInput = document.getElementById('customExpiryInput');
            const customUnit = document.getElementById('customExpiryUnit');

            if (customRadio && customRadio.checked) {
                customInput.disabled = false;
                customUnit.disabled = false;
                customInput.focus();
            } else {
                customInput.disabled = true;
                customUnit.disabled = true;
            }
        }

        // Add event listeners for batch expiry radio buttons
        document.addEventListener('DOMContentLoaded', function() {
            const endOfSeriesRadio = document.getElementById('endOfSeriesRadio');
            const customExpiryRadio = document.getElementById('customExpiryRadio');

            if (endOfSeriesRadio) {
                endOfSeriesRadio.addEventListener('change', toggleBatchExpiryMode);
            }
            if (customExpiryRadio) {
                customExpiryRadio.addEventListener('change', toggleBatchExpiryMode);
            }
        });

        function formatDateTime(timestamp) {
            const date = timestamp instanceof Date ? timestamp : new Date(timestamp);
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${year}-${month}-${day} ${hours}:${minutes}`;
        }

        function formatDateForInput(timestamp) {
            const date = timestamp instanceof Date ? timestamp : new Date(timestamp);
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function formatTimeForInput(timestamp) {
            const date = timestamp instanceof Date ? timestamp : new Date(timestamp);
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${hours}:${minutes}`;
        }

        function initializeAnalysisWindow() {
            if (!batchData.fullDataRange) return;

            // Set initial values to full data range
            const startDate = formatDateForInput(batchData.fullDataRange.start);
            const startTime = formatTimeForInput(batchData.fullDataRange.start);
            const endDate = formatDateForInput(batchData.fullDataRange.end);
            const endTime = formatTimeForInput(batchData.fullDataRange.end);

            document.getElementById('analysisStartDate').value = startDate;
            document.getElementById('analysisStartTime').value = startTime;
            document.getElementById('analysisEndDate').value = endDate;
            document.getElementById('analysisEndTime').value = endTime;

            // Show preview for entire dataset
            updateAnalysisWindowPreview();
        }

        function toggleAnalysisWindow() {
            const useCustom = document.getElementById('useCustomWindow').checked;
            const customInputsDiv = document.getElementById('customWindowInputs');

            const startDate = document.getElementById('analysisStartDate');
            const startTime = document.getElementById('analysisStartTime');
            const endDate = document.getElementById('analysisEndDate');
            const endTime = document.getElementById('analysisEndTime');

            if (useCustom) {
                // Enable custom inputs
                customInputsDiv.style.opacity = '1';
                startDate.disabled = false;
                startTime.disabled = false;
                endDate.disabled = false;
                endTime.disabled = false;
            } else {
                // Disable custom inputs
                customInputsDiv.style.opacity = '0.5';
                startDate.disabled = true;
                startTime.disabled = true;
                endDate.disabled = true;
                endTime.disabled = true;
            }

            updateAnalysisWindowPreview();
        }

        // Add event listeners for analysis window radio buttons
        document.addEventListener('DOMContentLoaded', function() {
            const useEntireRadio = document.getElementById('useEntireDataset');
            const useCustomRadio = document.getElementById('useCustomWindow');

            if (useEntireRadio) {
                useEntireRadio.addEventListener('change', toggleAnalysisWindow);
            }
            if (useCustomRadio) {
                useCustomRadio.addEventListener('change', toggleAnalysisWindow);
            }

            // Add event listener for base frequency changes to update hedge frequency options
            const baseFreqSelect = document.getElementById('batchBaseFrequency');
            if (baseFreqSelect) {
                baseFreqSelect.addEventListener('change', updateHedgeFrequencyOptions);
            }
        });

        function updateHedgeFrequencyOptions() {
            const baseFreq = parseInt(document.getElementById('batchBaseFrequency').value);
            const hedgeFreqSelect = document.getElementById('batchHedgeFrequency');

            if (!hedgeFreqSelect) return;

            // Get current selection
            const currentHedgeFreq = parseInt(hedgeFreqSelect.value);

            // Disable options that are less than base frequency
            Array.from(hedgeFreqSelect.options).forEach(option => {
                const freq = parseInt(option.value);
                if (freq < baseFreq) {
                    option.disabled = true;
                    option.style.color = '#ccc';
                } else {
                    option.disabled = false;
                    option.style.color = '';
                }
            });

            // If current selection is now invalid, select the first valid option
            if (currentHedgeFreq < baseFreq) {
                // Find first valid option >= baseFreq
                for (let i = 0; i < hedgeFreqSelect.options.length; i++) {
                    const freq = parseInt(hedgeFreqSelect.options[i].value);
                    if (freq >= baseFreq) {
                        hedgeFreqSelect.value = hedgeFreqSelect.options[i].value;
                        break;
                    }
                }
            }
        }

        function validateFrequencies(baseFreq, hedgeFreq) {
            if (hedgeFreq < baseFreq) {
                return {
                    valid: false,
                    message: `Error: Hedging frequency (${hedgeFreq} min) cannot be less than base data frequency (${baseFreq} min).<br>` +
                             `This would cause the hedging algorithm to attempt rebalancing between data points, resulting in NaN values.<br>` +
                             `Please select a hedging frequency >= ${baseFreq} minutes.`
                };
            }

            // Warning if hedge frequency is not a multiple of base frequency
            if (hedgeFreq % baseFreq !== 0) {
                return {
                    valid: true,
                    warning: `Warning: Hedging frequency (${hedgeFreq} min) is not a multiple of base frequency (${baseFreq} min).<br>` +
                             `Some hedge rebalance times may not align exactly with data timestamps.`
                };
            }

            return { valid: true };
        }

        function updateAnalysisWindowPreview() {
            if (!batchData.fullDataRange) return;

            const useEntire = document.getElementById('useEntireDataset').checked;
            const previewDiv = document.getElementById('windowPreview');

            if (useEntire) {
                // Show entire dataset info
                previewDiv.innerHTML = `
                    <strong>Analysis Window:</strong> Entire dataset<br>
                    ‚Üí ${batchData.fullDataRange.points} data points<br>
                    ‚Üí Duration: ${batchData.fullDataRange.hours.toFixed(1)} hours
                `;
            } else {
                // Get selected window
                const startDateTime = getSelectedStartDateTime();
                const endDateTime = getSelectedEndDateTime();

                if (!startDateTime || !endDateTime) {
                    previewDiv.innerHTML = '<strong>Please select valid start and end times</strong>';
                    return;
                }

                // Validate
                if (startDateTime >= endDateTime) {
                    previewDiv.innerHTML = '<strong style="color: var(--red);">Error: Start must be before End</strong>';
                    return;
                }

                if (startDateTime < batchData.fullDataRange.start || endDateTime > batchData.fullDataRange.end) {
                    previewDiv.innerHTML = '<strong style="color: var(--red);">Error: Window must be within data range</strong>';
                    return;
                }

                // Calculate window properties
                const durationMinutes = (endDateTime - startDateTime) / (1000 * 60);
                const durationHours = (durationMinutes / 60).toFixed(1);

                // Count data points in window
                const windowPoints = batchData.timestamps.filter(t => {
                    const ts = t instanceof Date ? t : new Date(t);
                    return ts >= startDateTime && ts <= endDateTime;
                }).length;

                previewDiv.innerHTML = `
                    <strong>Analysis Window:</strong> Custom<br>
                    ‚Üí Duration: ${durationHours} hours (${windowPoints} data points)<br>
                    ‚Üí Option initiated at: ${formatDateTime(startDateTime)}<br>
                    ‚Üí Analysis ends at: ${formatDateTime(endDateTime)}
                `;
            }
        }

        function getSelectedStartDateTime() {
            const dateStr = document.getElementById('analysisStartDate').value;
            const timeStr = document.getElementById('analysisStartTime').value;
            if (!dateStr || !timeStr) return null;
            return new Date(`${dateStr}T${timeStr}`);
        }

        function getSelectedEndDateTime() {
            const dateStr = document.getElementById('analysisEndDate').value;
            const timeStr = document.getElementById('analysisEndTime').value;
            if (!dateStr || !timeStr) return null;
            return new Date(`${dateStr}T${timeStr}`);
        }

        function filterDataToAnalysisWindow(fullData, windowStart, windowEnd) {
            const filteredTimestamps = [];
            const filteredSpotPrices = {};

            // Initialize spot price arrays
            Object.keys(fullData.spotPrices).forEach(pair => {
                filteredSpotPrices[pair] = [];
            });

            // Filter data points within window
            fullData.timestamps.forEach((timestamp, index) => {
                const t = timestamp instanceof Date ? timestamp : new Date(timestamp);
                if (t >= windowStart && t <= windowEnd) {
                    filteredTimestamps.push(timestamp);

                    // Add spot prices for all pairs
                    Object.keys(fullData.spotPrices).forEach(pair => {
                        filteredSpotPrices[pair].push(fullData.spotPrices[pair][index]);
                    });
                }
            });

            return {
                timestamps: filteredTimestamps,
                spotPrices: filteredSpotPrices,
                pairNames: fullData.pairNames,
                impliedVols: fullData.impliedVols,
                frequency: fullData.frequency,
                fullDataRange: fullData.fullDataRange,
                analysisWindow: {
                    start: windowStart,
                    end: windowEnd,
                    points: filteredTimestamps.length,
                    minutes: (windowEnd - windowStart) / (1000 * 60)
                }
            };
        }

        async function startBatchCalculation() {
            // Get selected pairs
            const selectedPairs = Array.from(document.querySelectorAll('input[name="pair"]:checked'))
                .map(cb => cb.value);

            if (selectedPairs.length === 0) {
                showBatchMessage('Error: Please select at least one currency pair', 'error');
                return;
            }

            const usdPairs = selectedPairs.filter(p => p.includes('USD'));
            const crossPairs = selectedPairs.filter(p => !p.includes('USD'));

            console.log(`Analyzing ${usdPairs.length} USD pairs and ${crossPairs.length} cross pairs`);

            // Hide pair selection, show progress
            document.getElementById('pairSelectionSection').style.display = 'none';
            document.getElementById('progressSection').style.display = 'block';
            document.getElementById('batchResults').style.display = 'none';

            // Derive cross pair spot series
            const allSpotData = { ...batchData.spotPrices }; // Start with USD pairs
            let derivedCount = 0;

            if (crossPairs.length > 0) {
                document.getElementById('currentPairText').textContent = `Deriving cross pair spot series...`;
                document.getElementById('progressFill').style.width = '5%';
                document.getElementById('progressText').textContent = '5%';

                for (let i = 0; i < crossPairs.length; i++) {
                    const crossPair = crossPairs[i];
                    const progress = 5 + ((i + 1) / crossPairs.length) * 10;
                    document.getElementById('progressFill').style.width = progress + '%';
                    document.getElementById('progressText').textContent = Math.round(progress) + '%';
                    document.getElementById('currentPairText').textContent = `Deriving ${crossPair}...`;

                    const crossSeries = deriveCrossSeries(
                        crossPair,
                        batchData.spotPrices,
                        batchData.usdPairs,
                        batchData.timestamps
                    );

                    if (crossSeries) {
                        allSpotData[crossPair] = crossSeries;
                        derivedCount++;
                        console.log(`‚úì Derived ${crossPair}`);
                    } else {
                        console.error(`‚úó Failed to derive ${crossPair}, excluding from analysis`);
                        const index = selectedPairs.indexOf(crossPair);
                        if (index > -1) {
                            selectedPairs.splice(index, 1);
                        }
                    }

                    // Allow UI to update
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
            }

            // Update batchData with derived cross series
            batchData.spotPrices = allSpotData;
            batchData.pairNames = selectedPairs;

            // Get configuration
            const baseFreq = parseInt(document.getElementById('batchBaseFrequency').value);
            const hedgeFreq = parseInt(document.getElementById('batchHedgeFrequency').value);

            // Validate frequencies
            const freqValidation = validateFrequencies(baseFreq, hedgeFreq);
            if (!freqValidation.valid) {
                showBatchMessage(freqValidation.message, 'error');
                document.getElementById('progressSection').style.display = 'none';
                document.getElementById('pairSelectionSection').style.display = 'block';
                return;
            }

            // Show warning if hedge frequency is not a multiple of base frequency
            if (freqValidation.warning) {
                showBatchMessage(freqValidation.warning, 'warning');
            }

            // Get option expiry settings
            const expiryMode = document.querySelector('input[name="batchExpiryMode"]:checked').value;
            let optionTenorMinutes;

            if (expiryMode === 'custom') {
                const customValue = parseFloat(document.getElementById('customExpiryInput').value);
                const customUnit = document.getElementById('customExpiryUnit').value;
                optionTenorMinutes = (customUnit === 'hours') ? customValue * 60 : customValue;
            }

            // Apply analysis window filter
            const useEntire = document.getElementById('useEntireDataset').checked;
            let analysisData;

            if (useEntire) {
                // Use full dataset
                analysisData = batchData;
            } else {
                // Filter to custom window
                const windowStart = getSelectedStartDateTime();
                const windowEnd = getSelectedEndDateTime();

                // Validation
                if (!windowStart || !windowEnd) {
                    showBatchMessage('Error: Please select valid start and end times', 'error');
                    document.getElementById('progressSection').style.display = 'none';
                    document.getElementById('pairSelectionSection').style.display = 'block';
                    return;
                }

                if (windowStart >= windowEnd) {
                    showBatchMessage('Error: Analysis window start must be before end', 'error');
                    document.getElementById('progressSection').style.display = 'none';
                    document.getElementById('pairSelectionSection').style.display = 'block';
                    return;
                }

                if (windowStart < batchData.fullDataRange.start || windowEnd > batchData.fullDataRange.end) {
                    showBatchMessage('Error: Analysis window must be within data range', 'error');
                    document.getElementById('progressSection').style.display = 'none';
                    document.getElementById('pairSelectionSection').style.display = 'block';
                    return;
                }

                // Filter data
                analysisData = filterDataToAnalysisWindow(batchData, windowStart, windowEnd);

                // Validate filtered data
                if (analysisData.timestamps.length < 2) {
                    showBatchMessage('Error: Analysis window must contain at least 2 data points', 'error');
                    document.getElementById('progressSection').style.display = 'none';
                    document.getElementById('pairSelectionSection').style.display = 'block';
                    return;
                }

                const windowDuration = (windowEnd - windowStart) / (1000 * 60);
                if (windowDuration < hedgeFreq) {
                    showBatchMessage('Error: Analysis window duration must be >= hedging frequency', 'error');
                    document.getElementById('progressSection').style.display = 'none';
                    document.getElementById('pairSelectionSection').style.display = 'block';
                    return;
                }
            }

            // Store analysis data for use in calculations
            window.currentAnalysisData = analysisData;

            // Initialize results
            batchData.results = {};
            batchData.analysisWindow = analysisData.analysisWindow || null;

            // Calculate for each pair sequentially
            const totalPairs = selectedPairs.length;
            const startProgress = crossPairs.length > 0 ? 15 : 0; // Reserve 15% for cross derivation if needed
            const calculationProgressRange = 100 - startProgress;

            for (let i = 0; i < selectedPairs.length; i++) {
                const pair = selectedPairs[i];
                const progress = startProgress + ((i + 1) / totalPairs) * calculationProgressRange;

                // Update progress
                document.getElementById('progressFill').style.width = progress + '%';
                document.getElementById('progressText').textContent = Math.round(progress) + '%';
                document.getElementById('currentPairText').textContent = `Processing ${pair}...`;

                // Calculate P&L for this pair
                try {
                    const result = await calculatePairPnL(pair, baseFreq, hedgeFreq, optionTenorMinutes, expiryMode);
                    batchData.results[pair] = result;
                } catch (error) {
                    console.error(`Error calculating ${pair}:`, error);
                    batchData.results[pair] = { error: error.message };
                }

                // Allow UI to update
                await new Promise(resolve => setTimeout(resolve, 10));
            }

            // Hide progress, show results
            document.getElementById('progressSection').style.display = 'none';
            document.getElementById('batchResults').style.display = 'block';

            // Calculate correlations if enabled
            let correlationResults = null;
            if (document.getElementById('includeCorrelationAnalysis') && document.getElementById('includeCorrelationAnalysis').checked) {
                const selectedGroups = Array.from(
                    document.querySelectorAll('input[name="corrGroup"]:checked')
                ).map(cb => cb.value);

                if (selectedGroups.length > 0) {
                    // Extract realized vols from P&L results
                    const realizedVols = {};
                    Object.keys(batchData.results).forEach(pair => {
                        if (batchData.results[pair].realizedVol !== undefined) {
                            realizedVols[pair] = batchData.results[pair].realizedVol;
                        }
                    });

                    // Calculate realized vols for cross pairs that don't have P&L results
                    // Cross pairs have spot data but no P&L calculation, so we need to calculate their realized vol
                    const analyzedPairs = [...new Set(selectedPairs.filter(p => batchData.results[p] && !batchData.results[p].error))];
                    
                    // Get the analysis data (which may be filtered to a window)
                    const analysisData = window.currentAnalysisData || batchData;
                    
                    // Check all pairs that don't have realized vols but have spot data
                    // Note: Check for undefined, not falsy (0 is a valid realized vol)
                    analyzedPairs.forEach(pair => {
                        if (realizedVols[pair] === undefined && analysisData.spotPrices[pair]) {
                            // Calculate realized vol for this cross pair
                            const spots = analysisData.spotPrices[pair];
                            const numPoints = spots.length;
                            const totalMinutes = (numPoints - 1) * baseFreq;
                            const totalDays = totalMinutes / (60 * 24);
                            
                            // Use same hedge times as P&L calculation
                            const lastCalculationMinutes = totalMinutes;
                            const hedgeTimes = calculateHedgeTimes(lastCalculationMinutes, hedgeFreq);
                            
                            // Calculate realized volatility
                            const realizedVol = calculateRealizedVolatility(spots, totalDays, hedgeTimes, baseFreq);
                            realizedVols[pair] = realizedVol;
                            
                            console.log(`Calculated realized vol for ${pair}: ${(realizedVol * 100).toFixed(2)}%`);
                        }
                    });

                    console.log(`Realized vols available:`, Object.keys(realizedVols));

                    // Calculate correlations
                    correlationResults = calculateAllCorrelations(
                        analyzedPairs, // analyzed pairs (deduplicated)
                        batchData.currencies, // all available currencies
                        batchData.impliedVols, // implied vols
                        realizedVols, // realized vols (including cross pairs)
                        selectedGroups // selected currency groups
                    );
                    
                    // Calculate correlation matrix via intermediates
                    const correlationMatrix = calculateCorrelationMatrixViaIntermediates(
                        analyzedPairs,
                        batchData.currencies,
                        batchData.impliedVols,
                        realizedVols
                    );
                    
                    // Store globally for display and email
                    window.correlationMatrix = correlationMatrix;
                } else {
                    window.correlationMatrix = null;
                }
            } else {
                window.correlationMatrix = null;
            }

            // Display results with tabs
            displayResultsWithTabs(batchData.results, correlationResults);
        }

        async function calculatePairPnL(pairName, baseFreq, hedgeFreq, optionTenorMinutes, expiryMode) {
            // Use analysis data (which may be filtered)
            const analysisData = window.currentAnalysisData;
            const spots = analysisData.spotPrices[pairName];
            const impliedVol = analysisData.impliedVols[pairName];

            // Calculate time period
            const numPoints = spots.length;
            const totalMinutes = (numPoints - 1) * baseFreq;
            const totalHours = totalMinutes / 60;
            const totalDays = totalHours / 24;

            // Determine option tenor
            let optionTenorYears;
            if (expiryMode === 'custom' && optionTenorMinutes) {
                optionTenorYears = optionTenorMinutes / (365 * 24 * 60);
            } else {
                optionTenorMinutes = totalMinutes;
                optionTenorYears = totalDays / 365;
            }

            // Calculate hedge times
            const lastCalculationMinutes = Math.min(totalMinutes, optionTenorMinutes);
            const hedgeTimes = calculateHedgeTimes(lastCalculationMinutes, hedgeFreq);

            // Calculate realized volatility
            const realizedVol = calculateRealizedVolatility(spots, totalDays, hedgeTimes, baseFreq);

            // Calculate strikes (5 standard strikes only for batch mode)
            const S0 = spots[0];
            const strikes = [
                { name: '10Œî Put', strike: calculateStrikeFromDelta(S0, impliedVol, optionTenorYears, -0.10), type: 'put' },
                { name: '25Œî Put', strike: calculateStrikeFromDelta(S0, impliedVol, optionTenorYears, -0.25), type: 'put' },
                { name: 'ATM Call', strike: S0, type: 'call' },
                { name: '25Œî Call', strike: calculateStrikeFromDelta(S0, impliedVol, optionTenorYears, 0.25), type: 'call' },
                { name: '10Œî Call', strike: calculateStrikeFromDelta(S0, impliedVol, optionTenorYears, 0.10), type: 'call' }
            ];

            // Calculate P&L for each strike
            const strikePnLs = {};
            let totalPnL = 0;

            strikes.forEach(s => {
                const baseNotional = SETTLEMENT_NOTIONAL / s.strike;
                const pnlData = calculateStrikePnL(spots, s.strike, impliedVol, s.type, baseNotional, totalMinutes, hedgeTimes, baseFreq, optionTenorMinutes);
                const finalPnL = pnlData[pnlData.length - 1].portfolioValue;
                strikePnLs[s.name] = {
                    strikePrice: s.strike,
                    finalPnL: finalPnL,
                    pnlData: pnlData // Store for chart viewing
                };
                totalPnL += finalPnL;
            });

            const avgPnL = totalPnL / strikes.length;

            return {
                avgPnL: avgPnL,
                strikes: strikePnLs,
                realizedVol: realizedVol,
                impliedVol: impliedVol,
                volDiff: realizedVol - impliedVol,
                spotData: spots,
                baseFreq: baseFreq,
                hedgeFreq: hedgeFreq,
                totalMinutes: totalMinutes
            };
        }

        // ============ EMAIL EXPORT FUNCTIONS ============

        function calculateGlobalScales(pnlResults, correlationResults) {
            const scales = {
                impliedVol: { min: Infinity, max: -Infinity },
                realizedVol: { min: Infinity, max: -Infinity },
                volDiff: { min: Infinity, max: -Infinity },
                allStrikesPnL: { min: Infinity, max: -Infinity },
                avgPnL: { min: Infinity, max: -Infinity },
                // Symmetric P&L scale around 0 (Excel-style): max absolute P&L across all strike + avg cells
                pnlMaxAbs: 0,
                impliedCorr: { min: Infinity, max: -Infinity },
                realizedCorr: { min: Infinity, max: -Infinity },
                corrDiff: { min: Infinity, max: -Infinity }
            };

            // Process P&L results
            Object.values(pnlResults).forEach(result => {
                if (result.error) return;

                // Vol scales
                scales.impliedVol.min = Math.min(scales.impliedVol.min, result.impliedVol);
                scales.impliedVol.max = Math.max(scales.impliedVol.max, result.impliedVol);

                scales.realizedVol.min = Math.min(scales.realizedVol.min, result.realizedVol);
                scales.realizedVol.max = Math.max(scales.realizedVol.max, result.realizedVol);

                scales.volDiff.min = Math.min(scales.volDiff.min, result.volDiff);
                scales.volDiff.max = Math.max(scales.volDiff.max, result.volDiff);

                // P&L scales - ALL strikes use same scale
                const allPnLs = [
                    result.strikes['10Œî Put']?.finalPnL || 0,
                    result.strikes['25Œî Put']?.finalPnL || 0,
                    result.strikes['ATM Call']?.finalPnL || 0,
                    result.strikes['25Œî Call']?.finalPnL || 0,
                    result.strikes['10Œî Call']?.finalPnL || 0
                ];

                allPnLs.forEach(pnl => {
                    scales.allStrikesPnL.min = Math.min(scales.allStrikesPnL.min, pnl);
                    scales.allStrikesPnL.max = Math.max(scales.allStrikesPnL.max, pnl);
                    scales.pnlMaxAbs = Math.max(scales.pnlMaxAbs, Math.abs(pnl));
                });

                // Average P&L has its own scale
                scales.avgPnL.min = Math.min(scales.avgPnL.min, result.avgPnL);
                scales.avgPnL.max = Math.max(scales.avgPnL.max, result.avgPnL);
                scales.pnlMaxAbs = Math.max(scales.pnlMaxAbs, Math.abs(result.avgPnL));
            });

            // Process correlation results
            Object.values(correlationResults || {}).forEach(group => {
                if (group.correlations) {
                    group.correlations.forEach(corr => {
                        scales.impliedCorr.min = Math.min(scales.impliedCorr.min, corr.impliedCorr);
                        scales.impliedCorr.max = Math.max(scales.impliedCorr.max, corr.impliedCorr);

                        scales.realizedCorr.min = Math.min(scales.realizedCorr.min, corr.realizedCorr);
                        scales.realizedCorr.max = Math.max(scales.realizedCorr.max, corr.realizedCorr);

                        scales.corrDiff.min = Math.min(scales.corrDiff.min, corr.difference);
                        scales.corrDiff.max = Math.max(scales.corrDiff.max, corr.difference);
                    });
                }
            });

            return scales;
        }

        // Email-specific P&L color function (light-mode, email-safe)
        // Uses the same symmetric max-abs logic as the webpage: +X deepest green, -X deepest red.
        function getEmailPnLColor(pnlValue, pnlMaxAbs) {
            const maxAbs = (pnlMaxAbs && !isNaN(pnlMaxAbs) && pnlMaxAbs > 0) ? pnlMaxAbs : 1;
            const abs = Math.abs(pnlValue);
            const t = Math.max(0, Math.min(1, abs / maxAbs));
            const gamma = 0.6;
            const tt = Math.pow(t, gamma);

            // Endpoints tuned for LIGHT email background with dark text
            // - Pale green: (232, 255, 232), Deep green: (16, 124, 16)
            // - Pale red:   (255, 232, 232), Deep red:   (180, 24, 24)
            let r, g, b;
            if (pnlValue > 0) {
                const r0 = 232, g0 = 255, b0 = 232;
                const r1 = 16,  g1 = 124, b1 = 16;
                r = Math.round(r0 + (r1 - r0) * tt);
                g = Math.round(g0 + (g1 - g0) * tt);
                b = Math.round(b0 + (b1 - b0) * tt);
            } else if (pnlValue < 0) {
                const r0 = 255, g0 = 232, b0 = 232;
                const r1 = 180, g1 = 24,  b1 = 24;
                r = Math.round(r0 + (r1 - r0) * tt);
                g = Math.round(g0 + (g1 - g0) * tt);
                b = Math.round(b0 + (b1 - b0) * tt);
            } else {
                // zero: subtle neutral cell (still readable)
                r = 245; g = 245; b = 245;
            }

            return `rgb(${r}, ${g}, ${b})`;
        }

        function getCellColor(value, scale) {
            if (!scale || scale.min === undefined || scale.max === undefined) {
                return 'transparent';
            }
            
            const min = scale.min;
            const max = scale.max;
            
            // Handle edge case
            if (min === max) return 'rgb(128, 128, 128)';
            
            // Clean gradient: Dark Red (most negative) ‚Üí Light Red ‚Üí Neutral Gray ‚Üí Light Green ‚Üí Dark Green (most positive)
            let r, g, b;
            
            // Handle three cases: all negative, all positive, or mixed
            if (max <= 0) {
                // All values are negative or zero
                // Map from min (darkest red) to max (less negative) to gray
                const ratio = (value - min) / (max - min);
                const ratioClamped = Math.max(0, Math.min(1, ratio));
                
                // Interpolate from dark red (139, 0, 0) to lighter red/gray (180, 100, 100)
                r = Math.round(139 + (180 - 139) * ratioClamped);
                g = Math.round(0 + (100 - 0) * ratioClamped);
                b = Math.round(0 + (100 - 0) * ratioClamped);
            } else if (min >= 0) {
                // All values are positive or zero
                // Map from min (grey/light green) to max (darkest green)
                const ratio = (value - min) / (max - min);
                const ratioClamped = Math.max(0, Math.min(1, ratio));
                
                // Interpolate from light grey-green (150, 170, 150) to dark green (0, 100, 0)
                // This ensures even small positive values have visible green color
                r = Math.round(150 + (0 - 150) * ratioClamped);
                g = Math.round(170 + (100 - 170) * ratioClamped);
                b = Math.round(150 + (0 - 150) * ratioClamped);
            } else {
                // Mixed: min < 0 < max
                // Split at 0: negative values go from dark red to gray, positive values go from gray to dark green
                if (value < 0) {
                    // Negative range: Dark Red ‚Üí Gray
                    // Map from min (darkest red) to 0 (gray)
                    const negRatio = (value - min) / (0 - min);
                    const negRatioClamped = Math.max(0, Math.min(1, negRatio));
                    
                    // Interpolate from dark red (139, 0, 0) to medium gray (128, 128, 128)
                    r = Math.round(139 + (128 - 139) * negRatioClamped);
                    g = Math.round(0 + (128 - 0) * negRatioClamped);
                    b = Math.round(0 + (128 - 0) * negRatioClamped);
                } else if (value > 0) {
                    // Positive range: Gray ‚Üí Dark Green
                    // Map from 0 (gray) to max (darkest green)
                    const posRatio = value / max;
                    const posRatioClamped = Math.max(0, Math.min(1, posRatio));
                    
                    // Interpolate from medium gray (128, 128, 128) to dark green (0, 100, 0)
                    r = Math.round(128 + (0 - 128) * posRatioClamped);
                    g = Math.round(128 + (100 - 128) * posRatioClamped);
                    b = Math.round(128 + (0 - 128) * posRatioClamped);
                } else {
                    // Exactly zero: neutral gray
                    r = 128;
                    g = 128;
                    b = 128;
                }
            }
            
            return `rgb(${r}, ${g}, ${b})`;
        }

        // Email-specific color function: uses original color scheme but lightened for dark text
        function getEmailCellColor(value, scale) {
            if (!scale || scale.min === undefined || scale.max === undefined) {
                return '#ffffff';
            }
            
            // Get the original color from getCellColor
            const originalColor = getCellColor(value, scale);
            
            // Extract RGB from the original color
            const rgbMatch = originalColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            if (!rgbMatch) {
                return '#ffffff';
            }
            
            const r = parseInt(rgbMatch[1]);
            const g = parseInt(rgbMatch[2]);
            const b = parseInt(rgbMatch[3]);
            
            // Lighten the color by mixing with white (70% original, 30% white)
            // This preserves the original color scheme but makes it light enough for dark text
            const lightenFactor = 0.7;
            const lightR = Math.round(r * lightenFactor + 255 * (1 - lightenFactor));
            const lightG = Math.round(g * lightenFactor + 255 * (1 - lightenFactor));
            const lightB = Math.round(b * lightenFactor + 255 * (1 - lightenFactor));
            
            return `rgb(${lightR}, ${lightG}, ${lightB})`;
        }

        function getTextColorForBackground(backgroundColor) {
            let r, g, b;
            
            // Try to extract RGB values from rgb() format
            const rgbMatch = backgroundColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            if (rgbMatch) {
                r = parseInt(rgbMatch[1]);
                g = parseInt(rgbMatch[2]);
                b = parseInt(rgbMatch[3]);
            } else {
                // Try hex format
                const rgb = hexToRgb(backgroundColor);
                if (rgb) {
                    r = rgb.r;
                    g = rgb.g;
                    b = rgb.b;
                } else {
                    return '#ffffff'; // Default to white text
                }
            }
            
            // Calculate perceived luminance
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b);
            
            // Threshold adjusted for new muted color palette
            return luminance > 130 ? '#000000' : '#ffffff';
        }

        function interpolateColor(color1Hex, color2Hex, factor) {
            // Clamp factor to [0, 1]
            factor = Math.max(0, Math.min(1, factor));

            const c1 = hexToRgb(color1Hex);
            const c2 = hexToRgb(color2Hex);

            const r = Math.round(c1.r + (c2.r - c1.r) * factor);
            const g = Math.round(c1.g + (c2.g - c1.g) * factor);
            const b = Math.round(c1.b + (c2.b - c1.b) * factor);

            return rgbToHex(r, g, b);
        }

        function hexToRgb(hex) {
            hex = hex.replace('#', '');
            return {
                r: parseInt(hex.substring(0, 2), 16),
                g: parseInt(hex.substring(2, 4), 16),
                b: parseInt(hex.substring(4, 6), 16)
            };
        }

        function rgbToHex(r, g, b) {
            return '#' + [r, g, b]
                .map(x => x.toString(16).padStart(2, '0'))
                .join('');
        }

        function formatVolDecimal(vol) {
            return (vol * 100).toFixed(2) + '%';
        }

        function formatCorrInteger(corr) {
            return Math.round(corr * 100) + '%';
        }

        /**
         * Generate email version of correlation matrix via intermediates
         */
        function generateEmailCorrelationMatrix(correlationMatrix, scales) {
            if (!correlationMatrix || Object.keys(correlationMatrix).length === 0) {
                return '';
            }
            
            const crossPairs = Object.keys(correlationMatrix).sort();
            const allIntermediates = new Set();
            
            crossPairs.forEach(crossPair => {
                Object.keys(correlationMatrix[crossPair].viaIntermediates).forEach(intermediate => {
                    allIntermediates.add(intermediate);
                });
            });
            
            const intermediates = Array.from(allIntermediates).sort((a, b) => {
                return getCurrencyOrder(a) - getCurrencyOrder(b);
            });
            
            if (intermediates.length === 0) {
                return '';
            }
            
            const corrScales = {
                impliedCorr: scales.impliedCorr || { min: -1, max: 1 },
                realizedCorr: scales.realizedCorr || { min: -1, max: 1 },
                corrDiff: scales.corrDiff || { min: -1, max: 1 }
            };
            
            const bestIntermediates = {};
            crossPairs.forEach(crossPair => {
                let bestIntermediate = null;
                let bestDiff = -Infinity;
                
                Object.entries(correlationMatrix[crossPair].viaIntermediates).forEach(([intermediate, data]) => {
                    if (data.difference > bestDiff) {
                        bestDiff = data.difference;
                        bestIntermediate = intermediate;
                    }
                });
                
                if (bestIntermediate) {
                    bestIntermediates[crossPair] = bestIntermediate;
                }
            });
            
            const intermediateAverages = {};
            intermediates.forEach(intermediate => {
                let sumImpl = 0, sumReal = 0, sumDiff = 0, count = 0;
                
                crossPairs.forEach(crossPair => {
                    const data = correlationMatrix[crossPair].viaIntermediates[intermediate];
                    if (data) {
                        sumImpl += data.impliedCorr;
                        sumReal += data.realizedCorr;
                        sumDiff += data.difference;
                        count++;
                    }
                });
                
                if (count > 0) {
                    intermediateAverages[intermediate] = {
                        impliedCorr: sumImpl / count,
                        realizedCorr: sumReal / count,
                        difference: sumDiff / count,
                        count: count
                    };
                }
            });
            
            let html = `
<div style="margin-top: 48px; margin-bottom: 32px;">
    <h3 style="font-size: 16px; font-weight: 600; color: #1f2937; margin-bottom: 16px; padding-bottom: 8px; border-bottom: 2px solid #e5e7eb;">
        CORRELATION MATRIX VIA INTERMEDIATE CURRENCIES
    </h3>
    <p style="font-size: 13px; color: #6b7280; margin-bottom: 16px;">
        Shows correlations of cross pairs calculated via different intermediate currencies. Each cell shows: Implied Corr | Realized Corr | Difference. Best intermediate for each pair is highlighted.
    </p>
    <div style="overflow-x: auto;">
        <table style="width: 100%; border-collapse: collapse; font-family: 'SF Mono', Monaco, monospace; font-size: 11px; min-width: 1000px; background-color: #ffffff;">
            <thead>
                <tr style="border-bottom: 2px solid #e5e7eb; background: #f9fafb;">
                    <th style="padding: 10px; text-align: left; background-color: #f9fafb; position: sticky; left: 0; z-index: 10; border-right: 2px solid #e5e7eb;">Cross Pair</th>`;
            
            intermediates.forEach(intermediate => {
                html += `
                    <th style="padding: 10px; text-align: center; background-color: #f9fafb; min-width: 200px;">
                        <div style="font-weight: 600; margin-bottom: 4px;">Via ${intermediate}</div>
                        <div style="font-size: 9px; color: #6b7280; font-weight: normal;">Impl | Real | Diff</div>
                    </th>`;
            });
            
            html += `
                </tr>
            </thead>
            <tbody>`;
            
            crossPairs.forEach(crossPair => {
                const bestIntermediate = bestIntermediates[crossPair];
                html += `
                <tr style="border-bottom: 1px solid #f3f4f6;">
                    <td style="padding: 10px; font-weight: 600; position: sticky; left: 0; background-color: #ffffff; z-index: 9; border-right: 2px solid #e5e7eb;">${crossPair}</td>`;
                
                intermediates.forEach(intermediate => {
                    const data = correlationMatrix[crossPair].viaIntermediates[intermediate];
                    const isBest = bestIntermediate === intermediate;
                    const emailTextColor = '#1f2937';
                    
                    if (data) {
                        const implBgColor = getEmailCellColor(data.impliedCorr, corrScales.impliedCorr);
                        const realBgColor = getEmailCellColor(data.realizedCorr, corrScales.realizedCorr);
                        const diffBgColor = getEmailCellColor(data.difference, corrScales.corrDiff);
                        
                        html += `
                    <td style="padding: 8px; text-align: center; ${isBest ? 'border: 2px solid #06b6d4;' : ''}">
                        <div style="display: flex; gap: 6px; justify-content: center; align-items: center; flex-wrap: wrap;">
                            <span style="padding: 3px 6px; border-radius: 3px; background-color: ${implBgColor}; color: ${emailTextColor}; font-weight: 500; font-size: 10px;">
                                ${formatCorrInteger(data.impliedCorr)}
                            </span>
                            <span style="padding: 3px 6px; border-radius: 3px; background-color: ${realBgColor}; color: ${emailTextColor}; font-weight: 500; font-size: 10px;">
                                ${formatCorrInteger(data.realizedCorr)}
                            </span>
                            <span style="padding: 3px 6px; border-radius: 3px; background-color: ${diffBgColor}; color: ${emailTextColor}; font-weight: 600; font-size: 10px;">
                                ${data.difference >= 0 ? '+' : ''}${formatCorrInteger(data.difference)}
                            </span>
                        </div>
                    </td>`;
                    } else {
                        html += `
                    <td style="padding: 8px; text-align: center; color: #9ca3af;">‚Äî</td>`;
                    }
                });
                
                html += `
                </tr>`;
            });
            
            html += `
            </tbody>
            <tfoot>
                <tr style="border-top: 2px solid #06b6d4; background: #f3f4f6; font-weight: 700;">
                    <td style="padding: 10px; font-weight: 700; color: #1f2937; position: sticky; left: 0; background-color: #f3f4f6; z-index: 9; border-right: 2px solid #e5e7eb;">AVERAGE</td>`;
            
            intermediates.forEach(intermediate => {
                const avg = intermediateAverages[intermediate];
                const emailTextColor = '#1f2937';
                
                if (avg) {
                    const implBgColor = getEmailCellColor(avg.impliedCorr, corrScales.impliedCorr);
                    const realBgColor = getEmailCellColor(avg.realizedCorr, corrScales.realizedCorr);
                    const diffBgColor = getEmailCellColor(avg.difference, corrScales.corrDiff);
                    
                    html += `
                    <td style="padding: 8px; text-align: center; font-weight: 600;">
                        <div style="display: flex; gap: 6px; justify-content: center; align-items: center; flex-wrap: wrap;">
                            <span style="padding: 3px 6px; border-radius: 3px; background-color: ${implBgColor}; color: ${emailTextColor}; font-size: 10px;">
                                ${formatCorrInteger(avg.impliedCorr)}
                            </span>
                            <span style="padding: 3px 6px; border-radius: 3px; background-color: ${realBgColor}; color: ${emailTextColor}; font-size: 10px;">
                                ${formatCorrInteger(avg.realizedCorr)}
                            </span>
                            <span style="padding: 3px 6px; border-radius: 3px; background-color: ${diffBgColor}; color: ${emailTextColor}; font-size: 10px;">
                                ${avg.difference >= 0 ? '+' : ''}${formatCorrInteger(avg.difference)}
                            </span>
                        </div>
                    </td>`;
                } else {
                    html += `
                    <td style="padding: 8px; text-align: center; color: #9ca3af;">‚Äî</td>`;
                }
            });
            
            html += `
                </tr>
            </tfoot>
        </table>
    </div>
</div>`;
            
            return html;
        }

        function formatPnLRounded(pnl) {
            const roundedK = Math.round(pnl / 1000);
            const sign = roundedK >= 0 ? '+' : '';
            return sign + '$' + roundedK + 'K';
        }

        function formatDateTime(timestamp, timezone = 'EST') {
            const date = new Date(timestamp);
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');

            return `${year}-${month}-${day} ${hours}:${minutes} ${timezone}`;
        }

        function calculateDurationHours(timestamps) {
            // timestamps is the array from uploadedTimestamps
            // First and last elements are the range
            if (!timestamps || timestamps.length === 0) {
                return 0;
            }
            
            const startTime = new Date(timestamps[0]);
            const endTime = new Date(timestamps[timestamps.length - 1]);
            
            const durationMs = endTime - startTime;
            const durationHours = Math.round(durationMs / (1000 * 60 * 60));
            
            return durationHours;
        }

        function generateEmailHeader(config, analyzedPairs, timestamps, currencies) {
            if (!timestamps || timestamps.length === 0) {
                return '<div>Error: No timestamp data available</div>';
            }

            const startTime = new Date(timestamps[0]);
            const endTime = new Date(timestamps[timestamps.length - 1]);
            const durationHours = calculateDurationHours(timestamps);

            const usdCount = analyzedPairs.filter(p => p.includes('USD')).length;
            const crossCount = analyzedPairs.filter(p => !p.includes('USD')).length;

            const rebalFreq = config.rebalancingFrequency || 'Daily';
            // Get option expiry correctly
            let expiryHours;
            if (config.optionExpiryHours !== undefined) {
                expiryHours = config.optionExpiryHours;
            } else if (config.expiryHours !== undefined) {
                expiryHours = config.expiryHours;
            } else if (config.optionExpiry !== undefined) {
                // Try to extract hours from formatted string
                const match = config.optionExpiry.match(/(\d+)\s*hours?/i);
                if (match) {
                    expiryHours = parseInt(match[1]);
                } else {
                    // Fallback: calculate from analysis window
                    expiryHours = Math.round((endTime - startTime) / (1000 * 60 * 60));
                }
            } else {
                // Fallback: calculate from analysis window
                expiryHours = Math.round((endTime - startTime) / (1000 * 60 * 60));
            }
            const expiryText = `${expiryHours} hours`;

            return `
<div style="background: #f9fafb; padding: 24px; margin-bottom: 32px; border: 1px solid #e5e7eb; border-radius: 8px;">
    <h2 style="margin: 0 0 20px 0; font-size: 18px; color: #1f2937; border-bottom: 2px solid #1e40af; padding-bottom: 12px;">
        FX Options P&L, Vol, Correlation Analysis - ${formatDateTime(startTime)} to ${formatDateTime(endTime)}
    </h2>

    <table style="width: 100%; font-family: 'SF Mono', Monaco, monospace; font-size: 13px; border-collapse: collapse;">
        <tr>
            <td style="padding: 6px 12px; width: 33%;"><strong>Analysis Period:</strong></td>
            <td style="padding: 6px 12px; width: 33%;">${formatDateTime(startTime)} to ${formatDateTime(endTime)}</td>
            <td style="padding: 6px 12px; width: 33%;"><strong>Rebalancing:</strong></td>
            <td style="padding: 6px 12px;">Every ${rebalFreq}</td>
        </tr>
        <tr>
            <td style="padding: 6px 12px;"><strong>Duration:</strong></td>
            <td style="padding: 6px 12px;">${durationHours} hours</td>
            <td style="padding: 6px 12px;"><strong>Option Expiry:</strong></td>
            <td style="padding: 6px 12px;">${expiryText}</td>
        </tr>
        <tr>
            <td style="padding: 6px 12px;"><strong>Pairs Analyzed:</strong></td>
            <td style="padding: 6px 12px;">${analyzedPairs.length} pairs (${usdCount} USD, ${crossCount} cross)</td>
            <td style="padding: 6px 12px;"><strong>Base Notional:</strong></td>
            <td style="padding: 6px 12px;">$100M USD equivalent per strike</td>
        </tr>
        <tr>
            <td style="padding: 6px 12px;"><strong>Strikes Analyzed:</strong></td>
            <td colspan="3" style="padding: 6px 12px;">10Œî Put, 25Œî Put, ATM Call, 25Œî Call, 10Œî Call</td>
        </tr>
    </table>
</div>`;
        }

        function generateTop5VolTable(pnlResults, scales) {
            const sorted = Object.entries(pnlResults)
                .filter(([_, data]) => !data.error)
                .map(([pair, data]) => ({
                    pair,
                    impliedVol: data.impliedVol,
                    realizedVol: data.realizedVol,
                    volDifference: data.volDiff,
                    avgPnL: data.avgPnL
                }))
                .sort((a, b) => b.avgPnL - a.avgPnL)
                .slice(0, 5);

            let html = `
<div style="margin-bottom: 32px;">
    <h3 style="font-size: 16px; font-weight: 600; color: #1f2937; margin-bottom: 16px; padding-bottom: 8px; border-bottom: 2px solid #e5e7eb;">
        TOP 5 VOL PERFORMERS (Realized > Implied)
    </h3>
    <table style="width: 100%; border-collapse: collapse; font-family: 'SF Mono', Monaco, monospace; font-size: 13px;">
        <thead>
            <tr style="border-bottom: 2px solid #e5e7eb; background: #f9fafb;">
                <th style="padding: 12px; text-align: left;">Rank</th>
                <th style="padding: 12px; text-align: left;">Pair</th>
                <th style="padding: 12px; text-align: right;">Impl Vol</th>
                <th style="padding: 12px; text-align: right;">Real Vol</th>
                <th style="padding: 12px; text-align: right;">Difference</th>
                <th style="padding: 12px; text-align: right;">Avg P&L</th>
            </tr>
        </thead>
        <tbody>`;

            sorted.forEach((item, idx) => {
                // Calculate background colors (email uses light pastels)
                const implVolBgColor = getEmailCellColor(item.impliedVol, scales.impliedVol);
                const realVolBgColor = getEmailCellColor(item.realizedVol, scales.realizedVol);
                const volDiffBgColor = getEmailCellColor(item.volDifference, scales.volDiff);
                const avgPnLBgColor = getEmailPnLColor(item.avgPnL, scales.pnlMaxAbs);
                
                // Email always uses dark text on light backgrounds
                const emailTextColor = '#1f2937';

                html += `
            <tr style="border-bottom: 1px solid #f3f4f6;">
                <td style="padding: 12px;">${idx + 1}</td>
                <td style="padding: 12px; font-weight: 600;">${item.pair}</td>
                <td style="padding: 12px; text-align: right; background-color: ${implVolBgColor}; color: ${emailTextColor}; font-weight: 500;">
                    ${formatVolDecimal(item.impliedVol)}
                </td>
                <td style="padding: 12px; text-align: right; background-color: ${realVolBgColor}; color: ${emailTextColor}; font-weight: 500;">
                    ${formatVolDecimal(item.realizedVol)}
                </td>
                <td style="padding: 12px; text-align: right; background-color: ${volDiffBgColor}; color: ${emailTextColor}; font-weight: 600;">
                    ${item.volDifference >= 0 ? '+' : ''}${formatVolDecimal(item.volDifference)}
                </td>
                <td style="padding: 12px; text-align: right; background-color: ${avgPnLBgColor}; color: ${emailTextColor}; font-weight: 500;">
                    ${formatPnLRounded(item.avgPnL)}
                </td>
            </tr>`;
            });

            html += `
        </tbody>
    </table>
</div>`;

            return html;
        }

        function generateBottom5VolTable(pnlResults, scales) {
            const sorted = Object.entries(pnlResults)
                .filter(([_, data]) => !data.error)
                .map(([pair, data]) => ({
                    pair,
                    impliedVol: data.impliedVol,
                    realizedVol: data.realizedVol,
                    volDifference: data.volDiff,
                    avgPnL: data.avgPnL
                }))
                .sort((a, b) => a.avgPnL - b.avgPnL)
                .slice(0, 5);

            const totalPairs = Object.keys(pnlResults).filter(p => !pnlResults[p].error).length;

            let html = `
<div style="margin-bottom: 32px;">
    <h3 style="font-size: 16px; font-weight: 600; color: #1f2937; margin-bottom: 16px; padding-bottom: 8px; border-bottom: 2px solid #e5e7eb;">
        BOTTOM 5 VOL PERFORMERS (Realized < Implied)
    </h3>
    <table style="width: 100%; border-collapse: collapse; font-family: 'SF Mono', Monaco, monospace; font-size: 13px;">
        <thead>
            <tr style="border-bottom: 2px solid #e5e7eb; background: #f9fafb;">
                <th style="padding: 12px; text-align: left;">Rank</th>
                <th style="padding: 12px; text-align: left;">Pair</th>
                <th style="padding: 12px; text-align: right;">Impl Vol</th>
                <th style="padding: 12px; text-align: right;">Real Vol</th>
                <th style="padding: 12px; text-align: right;">Difference</th>
                <th style="padding: 12px; text-align: right;">Avg P&L</th>
            </tr>
        </thead>
        <tbody>`;

            sorted.forEach((item, idx) => {
                const rank = totalPairs - 4 + idx;
                // Calculate background colors (email uses light pastels)
                const implVolBgColor = getEmailCellColor(item.impliedVol, scales.impliedVol);
                const realVolBgColor = getEmailCellColor(item.realizedVol, scales.realizedVol);
                const volDiffBgColor = getEmailCellColor(item.volDifference, scales.volDiff);
                const avgPnLBgColor = getEmailPnLColor(item.avgPnL, scales.pnlMaxAbs);
                
                // Email always uses dark text on light backgrounds
                const emailTextColor = '#1f2937';

                html += `
            <tr style="border-bottom: 1px solid #f3f4f6;">
                <td style="padding: 12px;">${rank}</td>
                <td style="padding: 12px; font-weight: 600;">${item.pair}</td>
                <td style="padding: 12px; text-align: right; background-color: ${implVolBgColor}; color: ${emailTextColor}; font-weight: 500;">
                    ${formatVolDecimal(item.impliedVol)}
                </td>
                <td style="padding: 12px; text-align: right; background-color: ${realVolBgColor}; color: ${emailTextColor}; font-weight: 500;">
                    ${formatVolDecimal(item.realizedVol)}
                </td>
                <td style="padding: 12px; text-align: right; background-color: ${volDiffBgColor}; color: ${emailTextColor}; font-weight: 600;">
                    ${item.volDifference >= 0 ? '+' : ''}${formatVolDecimal(item.volDifference)}
                </td>
                <td style="padding: 12px; text-align: right; background-color: ${avgPnLBgColor}; color: ${emailTextColor}; font-weight: 500;">
                    ${formatPnLRounded(item.avgPnL)}
                </td>
            </tr>`;
            });

            html += `
        </tbody>
    </table>
</div>`;

            return html;
        }

        function generateTop5CorrTable(correlationResults, scales) {
            const allCorrelations = [];
            Object.entries(correlationResults || {}).forEach(([currency, data]) => {
                if (data.correlations) {
                    data.correlations.forEach(corr => {
                        allCorrelations.push({
                            currency: currency,
                            ...corr
                        });
                    });
                }
            });

            const sorted = allCorrelations
                .sort((a, b) => b.difference - a.difference)
                .slice(0, 5);

            let html = `
<div style="margin-bottom: 32px;">
    <h3 style="font-size: 16px; font-weight: 600; color: #1f2937; margin-bottom: 16px; padding-bottom: 8px; border-bottom: 2px solid #e5e7eb;">
        TOP 5 CORRELATION PERFORMERS
    </h3>
    <table style="width: 100%; border-collapse: collapse; font-family: 'SF Mono', Monaco, monospace; font-size: 13px;">
        <thead>
            <tr style="border-bottom: 2px solid #e5e7eb; background: #f9fafb;">
                <th style="padding: 12px; text-align: left;">Rank</th>
                <th style="padding: 12px; text-align: left;">Currency</th>
                <th style="padding: 12px; text-align: left;">Pair 1</th>
                <th style="padding: 12px; text-align: left;">Pair 2</th>
                <th style="padding: 12px; text-align: right;">Impl Corr</th>
                <th style="padding: 12px; text-align: right;">Real Corr</th>
                <th style="padding: 12px; text-align: right;">Difference</th>
            </tr>
        </thead>
        <tbody>`;

            sorted.forEach((item, idx) => {
                // Calculate background colors
                const implCorrBgColor = getEmailCellColor(item.impliedCorr, scales.impliedCorr);
                const realCorrBgColor = getEmailCellColor(item.realizedCorr, scales.realizedCorr);
                const corrDiffBgColor = getEmailCellColor(item.difference, scales.corrDiff);
                
                // Email always uses dark text on light backgrounds
                const emailTextColor = '#1f2937';

                html += `
            <tr style="border-bottom: 1px solid #f3f4f6;">
                <td style="padding: 12px;">${idx + 1}</td>
                <td style="padding: 12px; font-weight: 600;">${item.currency}</td>
                <td style="padding: 12px;">${item.pair1}</td>
                <td style="padding: 12px;">${item.pair2}</td>
                <td style="padding: 12px; text-align: right; background-color: ${implCorrBgColor}; color: ${emailTextColor}; font-weight: 500;">
                    ${formatCorrInteger(item.impliedCorr)}
                </td>
                <td style="padding: 12px; text-align: right; background-color: ${realCorrBgColor}; color: ${emailTextColor}; font-weight: 500;">
                    ${formatCorrInteger(item.realizedCorr)}
                </td>
                <td style="padding: 12px; text-align: right; background-color: ${corrDiffBgColor}; color: ${emailTextColor}; font-weight: 600;">
                    ${item.difference >= 0 ? '+' : ''}${formatCorrInteger(item.difference)}
                </td>
            </tr>`;
            });

            html += `
        </tbody>
    </table>
</div>`;

            return html;
        }

        function generateBottom5CorrTable(correlationResults, scales) {
            const allCorrelations = [];
            Object.entries(correlationResults || {}).forEach(([currency, data]) => {
                if (data.correlations) {
                    data.correlations.forEach(corr => {
                        allCorrelations.push({
                            currency: currency,
                            ...corr
                        });
                    });
                }
            });

            const sorted = allCorrelations
                .sort((a, b) => a.difference - b.difference)
                .slice(0, 5);

            const totalCorrs = allCorrelations.length;

            let html = `
<div style="margin-bottom: 32px;">
    <h3 style="font-size: 16px; font-weight: 600; color: #1f2937; margin-bottom: 16px; padding-bottom: 8px; border-bottom: 2px solid #e5e7eb;">
        BOTTOM 5 CORRELATION PERFORMERS
    </h3>
    <table style="width: 100%; border-collapse: collapse; font-family: 'SF Mono', Monaco, monospace; font-size: 13px;">
        <thead>
            <tr style="border-bottom: 2px solid #e5e7eb; background: #f9fafb;">
                <th style="padding: 12px; text-align: left;">Rank</th>
                <th style="padding: 12px; text-align: left;">Currency</th>
                <th style="padding: 12px; text-align: left;">Pair 1</th>
                <th style="padding: 12px; text-align: left;">Pair 2</th>
                <th style="padding: 12px; text-align: right;">Impl Corr</th>
                <th style="padding: 12px; text-align: right;">Real Corr</th>
                <th style="padding: 12px; text-align: right;">Difference</th>
            </tr>
        </thead>
        <tbody>`;

            sorted.forEach((item, idx) => {
                const rank = totalCorrs - idx;
                // Calculate background colors
                const implCorrBgColor = getEmailCellColor(item.impliedCorr, scales.impliedCorr);
                const realCorrBgColor = getEmailCellColor(item.realizedCorr, scales.realizedCorr);
                const corrDiffBgColor = getEmailCellColor(item.difference, scales.corrDiff);
                
                // Email always uses dark text on light backgrounds
                const emailTextColor = '#1f2937';

                html += `
            <tr style="border-bottom: 1px solid #f3f4f6;">
                <td style="padding: 12px;">${rank}</td>
                <td style="padding: 12px; font-weight: 600;">${item.currency}</td>
                <td style="padding: 12px;">${item.pair1}</td>
                <td style="padding: 12px;">${item.pair2}</td>
                <td style="padding: 12px; text-align: right; background-color: ${implCorrBgColor}; color: ${emailTextColor}; font-weight: 500;">
                    ${formatCorrInteger(item.impliedCorr)}
                </td>
                <td style="padding: 12px; text-align: right; background-color: ${realCorrBgColor}; color: ${emailTextColor}; font-weight: 500;">
                    ${formatCorrInteger(item.realizedCorr)}
                </td>
                <td style="padding: 12px; text-align: right; background-color: ${corrDiffBgColor}; color: ${emailTextColor}; font-weight: 600;">
                    ${item.difference >= 0 ? '+' : ''}${formatCorrInteger(item.difference)}
                </td>
            </tr>`;
            });

            html += `
        </tbody>
    </table>
</div>`;

            return html;
        }

        function buildCurrencyGroups(pnlResults, currencies) {
            const groups = {};
            currencies.forEach(currency => {
                groups[currency] = [];
            });

            Object.keys(pnlResults).forEach(pair => {
                if (pnlResults[pair].error) return;
                const ccy1 = pair.substring(0, 3);
                const ccy2 = pair.substring(3, 6);
                if (groups[ccy1]) groups[ccy1].push(pair);
                if (groups[ccy2]) groups[ccy2].push(pair);
            });

            // Debug logging
            console.log('=== EMAIL P&L CURRENCY GROUPS ===');
            console.log('Groups:', Object.keys(groups));
            console.log('USD pairs:', groups['USD']);

            return groups;
        }

        function generateCurrencyPnLSection(currency, pairs, pnlResults, scales) {
            const currencyName = getCurrencyName(currency);

            let html = `
<div style="margin: 16px 0; border-left: 3px solid #06b6d4; padding-left: 16px; background: #f9fafb; padding: 16px;">
    <div style="font-weight: 600; color: #1f2937; margin-bottom: 12px; font-size: 14px;">
        ${currencyName} (${pairs.length} pairs)
    </div>
    <div style="overflow-x: auto;">
        <table style="width: 100%; border-collapse: collapse; font-family: 'SF Mono', Monaco, monospace; font-size: 12px; min-width: 1000px; background-color: #ffffff;">
            <thead>
                <tr style="border-bottom: 2px solid #e5e7eb; background: #f9fafb;">
                    <th style="padding: 10px; text-align: left; background-color: #f9fafb;">Pair</th>
                    <th style="padding: 10px; text-align: right; background-color: #f9fafb;">Impl Vol</th>
                    <th style="padding: 10px; text-align: right; background-color: #f9fafb;">Real Vol</th>
                    <th style="padding: 10px; text-align: right; background-color: #f9fafb;">Vol Diff</th>
                    <th style="padding: 10px; text-align: right; background-color: #f9fafb;">10Œî Put</th>
                    <th style="padding: 10px; text-align: right; background-color: #f9fafb;">25Œî Put</th>
                    <th style="padding: 10px; text-align: right; background-color: #f9fafb;">ATM</th>
                    <th style="padding: 10px; text-align: right; background-color: #f9fafb;">25Œî Call</th>
                    <th style="padding: 10px; text-align: right; background-color: #f9fafb;">10Œî Call</th>
                    <th style="padding: 10px; text-align: right; background-color: #f9fafb;">Avg P&L</th>
                </tr>
            </thead>
            <tbody>`;

            pairs.forEach(pair => {
                const data = pnlResults[pair];
                if (!data || data.error) return;

                // Calculate background colors (email uses light pastels)
                const implVolBgColor = getEmailCellColor(data.impliedVol, scales.impliedVol);
                const realVolBgColor = getEmailCellColor(data.realizedVol, scales.realizedVol);
                const volDiffBgColor = getEmailCellColor(data.volDiff, scales.volDiff);
                const put10BgColor = getEmailPnLColor(data.strikes['10Œî Put']?.finalPnL || 0, scales.pnlMaxAbs);
                const put25BgColor = getEmailPnLColor(data.strikes['25Œî Put']?.finalPnL || 0, scales.pnlMaxAbs);
                const atmBgColor = getEmailPnLColor(data.strikes['ATM Call']?.finalPnL || 0, scales.pnlMaxAbs);
                const call25BgColor = getEmailPnLColor(data.strikes['25Œî Call']?.finalPnL || 0, scales.pnlMaxAbs);
                const call10BgColor = getEmailPnLColor(data.strikes['10Œî Call']?.finalPnL || 0, scales.pnlMaxAbs);
                const avgPnLBgColor = getEmailPnLColor(data.avgPnL, scales.pnlMaxAbs);
                
                // Email always uses dark text on light backgrounds
                const emailTextColor = '#1f2937';

                html += `
                <tr style="border-bottom: 1px solid #f3f4f6; background-color: #ffffff;">
                    <td style="padding: 10px; font-weight: 600; background-color: #ffffff;">${pair}</td>
                    <td style="padding: 10px; text-align: right; background-color: ${implVolBgColor}; color: ${emailTextColor}; font-weight: 500;">
                        ${formatVolDecimal(data.impliedVol)}
                    </td>
                    <td style="padding: 10px; text-align: right; background-color: ${realVolBgColor}; color: ${emailTextColor}; font-weight: 500;">
                        ${formatVolDecimal(data.realizedVol)}
                    </td>
                    <td style="padding: 10px; text-align: right; background-color: ${volDiffBgColor}; color: ${emailTextColor}; font-weight: 500;">
                        ${data.volDiff >= 0 ? '+' : ''}${formatVolDecimal(data.volDiff)}
                    </td>
                    <td style="padding: 10px; text-align: right; background-color: ${put10BgColor}; color: ${emailTextColor}; font-weight: 500;">
                        ${formatPnLRounded(data.strikes['10Œî Put']?.finalPnL || 0)}
                    </td>
                    <td style="padding: 10px; text-align: right; background-color: ${put25BgColor}; color: ${emailTextColor}; font-weight: 500;">
                        ${formatPnLRounded(data.strikes['25Œî Put']?.finalPnL || 0)}
                    </td>
                    <td style="padding: 10px; text-align: right; background-color: ${atmBgColor}; color: ${emailTextColor}; font-weight: 500;">
                        ${formatPnLRounded(data.strikes['ATM Call']?.finalPnL || 0)}
                    </td>
                    <td style="padding: 10px; text-align: right; background-color: ${call25BgColor}; color: ${emailTextColor}; font-weight: 500;">
                        ${formatPnLRounded(data.strikes['25Œî Call']?.finalPnL || 0)}
                    </td>
                    <td style="padding: 10px; text-align: right; background-color: ${call10BgColor}; color: ${emailTextColor}; font-weight: 500;">
                        ${formatPnLRounded(data.strikes['10Œî Call']?.finalPnL || 0)}
                    </td>
                    <td style="padding: 10px; text-align: right; background-color: ${avgPnLBgColor}; color: ${emailTextColor}; font-weight: 600;">
                        ${formatPnLRounded(data.avgPnL)}
                    </td>
                </tr>`;
            });

            // Calculate averages for this currency group
            let sumImplVol = 0, sumRealVol = 0, sumVolDiff = 0;
            let sumATM = 0, sumAvgPnL = 0;
            let validCount = 0;

            pairs.forEach(pair => {
                const data = pnlResults[pair];
                if (!data || data.error) return;
                validCount++;
                sumImplVol += data.impliedVol;
                sumRealVol += data.realizedVol;
                sumVolDiff += data.volDiff;
                sumATM += data.strikes['ATM Call']?.finalPnL || 0;
                sumAvgPnL += data.avgPnL;
            });

            if (validCount > 0) {
                const avgImplVol = sumImplVol / validCount;
                const avgRealVol = sumRealVol / validCount;
                const avgVolDiff = sumVolDiff / validCount;
                const avgATM = sumATM / validCount;
                const avgAvgPnL = sumAvgPnL / validCount;

                // Calculate background colors for averages
                const avgImplVolBgColor = getEmailCellColor(avgImplVol, scales.impliedVol);
                const avgRealVolBgColor = getEmailCellColor(avgRealVol, scales.realizedVol);
                const avgVolDiffBgColor = getEmailCellColor(avgVolDiff, scales.volDiff);
                const avgATMBgColor = getEmailPnLColor(avgATM, scales.pnlMaxAbs);
                const avgAvgPnLBgColor = getEmailPnLColor(avgAvgPnL, scales.pnlMaxAbs);

                // Email always uses dark text on light backgrounds
                const emailTextColor = '#1f2937';

                html += `
            </tbody>
            <tfoot>
                <tr style="border-top: 2px solid #06b6d4; background: #f3f4f6; font-weight: 700;">
                    <td style="padding: 12px; font-weight: 700; color: #1f2937; background-color: #f3f4f6;">AVERAGE</td>
                    <td style="padding: 12px; text-align: right; background-color: ${avgImplVolBgColor}; color: ${emailTextColor}; font-weight: 500;">
                        ${formatVolDecimal(avgImplVol)}
                    </td>
                    <td style="padding: 12px; text-align: right; background-color: ${avgRealVolBgColor}; color: ${emailTextColor}; font-weight: 500;">
                        ${formatVolDecimal(avgRealVol)}
                    </td>
                    <td style="padding: 12px; text-align: right; background-color: ${avgVolDiffBgColor}; color: ${emailTextColor}; font-weight: 500;">
                        ${avgVolDiff >= 0 ? '+' : ''}${formatVolDecimal(avgVolDiff)}
                    </td>
                    <td colspan="2" style="padding: 12px; text-align: center; color: #6b7280; font-style: italic; background-color: #f3f4f6;">
                        ‚Äî
                    </td>
                    <td style="padding: 12px; text-align: right; background-color: ${avgATMBgColor}; color: ${emailTextColor}; font-weight: 500;">
                        ${formatPnLRounded(avgATM)}
                    </td>
                    <td colspan="2" style="padding: 12px; text-align: center; color: #6b7280; font-style: italic; background-color: #f3f4f6;">
                        ‚Äî
                    </td>
                    <td style="padding: 12px; text-align: right; background-color: ${avgAvgPnLBgColor}; color: ${emailTextColor}; font-weight: 600;">
                        ${formatPnLRounded(avgAvgPnL)}
                    </td>
                </tr>
            </tfoot>`;
            } else {
                html += `
            </tbody>`;
            }

            html += `
        </table>
    </div>
</div>`;

            return html;
        }

        function generateCurrencyCorrSection(currency, groupData, scales) {
            if (!groupData || !groupData.correlations || groupData.correlations.length === 0) {
                return '';
            }

            const currencyName = getCurrencyName(currency);

            let html = `
<div style="margin: 16px 0; border-left: 3px solid #06b6d4; padding-left: 16px; background: #f9fafb; padding: 16px;">
    <div style="font-weight: 600; color: #1f2937; margin-bottom: 12px; font-size: 14px;">
        ${currencyName} (${groupData.correlations.length} correlations)
    </div>
    <div style="overflow-x: auto;">
        <table style="width: 100%; border-collapse: collapse; font-family: 'SF Mono', Monaco, monospace; font-size: 12px;">
            <thead>
                <tr style="border-bottom: 2px solid #e5e7eb; background: #f9fafb;">
                    <th style="padding: 10px; text-align: left;">Pair 1</th>
                    <th style="padding: 10px; text-align: left;">Pair 2</th>
                    <th style="padding: 10px; text-align: right;">Impl Corr</th>
                    <th style="padding: 10px; text-align: right;">Real Corr</th>
                    <th style="padding: 10px; text-align: right;">Difference</th>
                </tr>
            </thead>
            <tbody>`;

            groupData.correlations.forEach(corr => {
                // Calculate background colors (email uses light pastels)
                const implCorrBgColor = getEmailCellColor(corr.impliedCorr, scales.impliedCorr);
                const realCorrBgColor = getEmailCellColor(corr.realizedCorr, scales.realizedCorr);
                const corrDiffBgColor = getEmailCellColor(corr.difference, scales.corrDiff);
                
                // Email always uses dark text on light backgrounds
                const emailTextColor = '#1f2937';

                html += `
                <tr style="border-bottom: 1px solid #f3f4f6;">
                    <td style="padding: 10px;">${corr.pair1}</td>
                    <td style="padding: 10px;">${corr.pair2}</td>
                    <td style="padding: 10px; text-align: right; background-color: ${implCorrBgColor}; color: ${emailTextColor}; font-weight: 500;">
                        ${formatCorrInteger(corr.impliedCorr)}
                    </td>
                    <td style="padding: 10px; text-align: right; background-color: ${realCorrBgColor}; color: ${emailTextColor}; font-weight: 500;">
                        ${formatCorrInteger(corr.realizedCorr)}
                    </td>
                    <td style="padding: 10px; text-align: right; background-color: ${corrDiffBgColor}; color: ${emailTextColor}; font-weight: 600;">
                        ${corr.difference >= 0 ? '+' : ''}${formatCorrInteger(corr.difference)}
                    </td>
                </tr>`;
            });

            // Calculate averages for this correlation group
            const correlations = groupData.correlations;
            let sumImplCorr = 0, sumRealCorr = 0, sumCorrDiff = 0;
            
            correlations.forEach(corr => {
                sumImplCorr += corr.impliedCorr;
                sumRealCorr += corr.realizedCorr;
                sumCorrDiff += corr.difference;
            });

            const count = correlations.length;
            const avgImplCorr = sumImplCorr / count;
            const avgRealCorr = sumRealCorr / count;
            const avgCorrDiff = sumCorrDiff / count;

            // Calculate background colors (email uses light pastels)
            const avgImplCorrBgColor = getEmailCellColor(avgImplCorr, scales.impliedCorr);
            const avgRealCorrBgColor = getEmailCellColor(avgRealCorr, scales.realizedCorr);
            const avgCorrDiffBgColor = getEmailCellColor(avgCorrDiff, scales.corrDiff);

            // Email always uses dark text on light backgrounds
            const emailTextColor = '#1f2937';

            html += `
            </tbody>
            <tfoot>
                <tr style="border-top: 2px solid #06b6d4; background: #f3f4f6; font-weight: 700;">
                    <td colspan="2" style="padding: 12px; font-weight: 700; color: #1f2937;">AVERAGE (${count} correlations)</td>
                    <td style="padding: 12px; text-align: right; background-color: ${avgImplCorrBgColor}; color: ${emailTextColor}; font-weight: 500;">
                        ${formatCorrInteger(avgImplCorr)}
                    </td>
                    <td style="padding: 12px; text-align: right; background-color: ${avgRealCorrBgColor}; color: ${emailTextColor}; font-weight: 500;">
                        ${formatCorrInteger(avgRealCorr)}
                    </td>
                    <td style="padding: 12px; text-align: right; background-color: ${avgCorrDiffBgColor}; color: ${emailTextColor}; font-weight: 500;">
                        ${avgCorrDiff >= 0 ? '+' : ''}${formatCorrInteger(avgCorrDiff)}
                    </td>
                </tr>
            </tfoot>
        </table>
    </div>
</div>`;

            return html;
        }

        function restructureCorrelations(correlationResults) {
            // Sort currency blocks by order
            const sortedCurrencies = sortCurrencies(Object.keys(correlationResults || {}));
            
            const restructured = {};
            
            sortedCurrencies.forEach(mainCurrency => {
                const data = correlationResults[mainCurrency];
                if (!data || !data.correlations) return;
                
                // Group correlations by ALL currencies that appear (not just secondary)
                const nestedGroups = {};
                
                data.correlations.forEach(corr => {
                    // Extract currencies from pair names (format: "EURUSD" or "EUR/USD")
                    const pair1 = corr.pair1 || '';
                    const pair2 = corr.pair2 || '';
                    
                    // Extract currencies (handle both "EURUSD" and "EUR/USD" formats)
                    let pair1Currencies = [];
                    let pair2Currencies = [];
                    
                    if (pair1.includes('/')) {
                        pair1Currencies = pair1.split('/').map(c => c.trim());
                    } else if (pair1.length >= 6) {
                        pair1Currencies = [pair1.substring(0, 3).trim(), pair1.substring(3, 6).trim()];
                    }
                    
                    if (pair2.includes('/')) {
                        pair2Currencies = pair2.split('/').map(c => c.trim());
                    } else if (pair2.length >= 6) {
                        pair2Currencies = [pair2.substring(0, 3).trim(), pair2.substring(3, 6).trim()];
                    }
                    
                    // Get all unique currencies mentioned (excluding mainCurrency)
                    const allCurrenciesSet = new Set([...pair1Currencies, ...pair2Currencies]);
                    allCurrenciesSet.delete(mainCurrency);
                    
                    // Add this correlation to ALL secondary currency groups it involves
                    allCurrenciesSet.forEach(secondaryCurrency => {
                        if (!secondaryCurrency) return;
                        
                        if (!nestedGroups[secondaryCurrency]) {
                            nestedGroups[secondaryCurrency] = [];
                        }
                        
                        // Check if this correlation involves the secondary currency
                        // (it appears in at least one of the pairs)
                        const involvesCurrency = 
                            pair1Currencies.includes(secondaryCurrency) || 
                            pair2Currencies.includes(secondaryCurrency);
                        
                        if (involvesCurrency) {
                            // Check for duplicates before adding
                            const isDuplicate = nestedGroups[secondaryCurrency].some(existing =>
                                (existing.pair1 === corr.pair1 && existing.pair2 === corr.pair2) ||
                                (existing.pair1 === corr.pair2 && existing.pair2 === corr.pair1)
                            );
                            
                            if (!isDuplicate) {
                                nestedGroups[secondaryCurrency].push(corr);
                            }
                        }
                    });
                });
                
                // Sort nested groups by currency order
                const sortedNestedGroups = {};
                const sortedSecondaries = sortCurrencies(Object.keys(nestedGroups));
                
                sortedSecondaries.forEach(secondary => {
                    sortedNestedGroups[secondary] = nestedGroups[secondary];
                });
                
                restructured[mainCurrency] = {
                    nestedGroups: sortedNestedGroups,
                    allCorrelations: data.correlations // Keep original for overall summary
                };
            });
            
            return restructured;
        }

        function generateExpandableFullResults(pnlResults, correlationResults, scales, currencies) {
            let html = `
<div style="margin-top: 48px;">
    <div style="margin-bottom: 24px; border: 1px solid #e5e7eb; border-radius: 8px; padding: 12px;">
        <div style="font-weight: 600; font-size: 15px; color: #1f2937; padding: 8px; margin-bottom: 16px;">
            FULL P&L RESULTS
        </div>
        <div style="padding: 16px 0;">`;

            const currencyGroups = buildCurrencyGroups(pnlResults, currencies);

            // Sort currencies by order
            const sortedCurrencies = sortCurrencies(Object.keys(currencyGroups));
            
            sortedCurrencies.forEach(currency => {
                const pairs = currencyGroups[currency];
                if (pairs.length > 0) {
                    html += generateCurrencyPnLSection(currency, pairs, pnlResults, scales);
                }
            });

            html += `
        </div>
    </div>

    <div style="margin-bottom: 24px; border: 1px solid #e5e7eb; border-radius: 8px; padding: 12px;">
        <div style="font-weight: 600; font-size: 15px; color: #1f2937; padding: 8px; margin-bottom: 16px;">
            FULL CORRELATION RESULTS
        </div>
        <div style="padding: 16px 0;">`;

            // Use restructured correlations with nesting
            const restructured = restructureCorrelations(correlationResults);
            
            Object.entries(restructured).forEach(([mainCurrency, data]) => {
                html += `
        <div style="margin: 16px 0; border-left: 3px solid #06b6d4; padding-left: 16px; background: #f9fafb; padding: 16px;">
            <div style="font-weight: 600; color: #1f2937; margin-bottom: 12px; font-size: 14px;">
                ${mainCurrency} CORRELATIONS (${data.allCorrelations.length} total)
            </div>
            <div>`;

                // Nested groups
                Object.entries(data.nestedGroups).forEach(([secondaryCurrency, correlations]) => {
                    const corrArray = Array.isArray(correlations) ? correlations : [];
                    const mainPair = constructMainPair(mainCurrency, secondaryCurrency);
                    html += `
            <div style="margin: 16px 0; padding: 12px; background: #f9fafb; border-radius: 6px;">
                <h4 style="font-size: 13px; font-weight: 600; color: #1f2937; margin-bottom: 12px;">
                    ${mainCurrency}-${secondaryCurrency} (${corrArray.length} correlations)
                </h4>
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse; font-family: 'SF Mono', Monaco, monospace; font-size: 12px;">
                        <thead>
                            <tr style="border-bottom: 2px solid #e5e7eb; background: #ffffff;">
                                <th style="padding: 10px; text-align: left;">Pair 1</th>
                                <th style="padding: 10px; text-align: left;">Pair 2</th>
                                <th style="padding: 10px; text-align: right;">Impl Corr</th>
                                <th style="padding: 10px; text-align: right;">Real Corr</th>
                                <th style="padding: 10px; text-align: right;">Difference</th>
                            </tr>
                        </thead>
                        <tbody>`;

                    corrArray.forEach(corr => {
                        const normalized = normalizeCorrelationForDisplay(corr, mainPair);
                        const implCorrBg = getCellColor(normalized.impliedCorr, scales.impliedCorr);
                        const realCorrBg = getCellColor(normalized.realizedCorr, scales.realizedCorr);
                        const diffBg = getCellColor(normalized.difference, scales.corrDiff);
                        
                        const implCorrText = getTextColorForBackground(implCorrBg);
                        const realCorrText = getTextColorForBackground(realCorrBg);
                        const diffText = getTextColorForBackground(diffBg);

                        html += `
                            <tr style="border-bottom: 1px solid #f3f4f6;">
                                <td style="padding: 10px;">${normalized.pair1}</td>
                                <td style="padding: 10px;">${normalized.pair2}</td>
                                <td style="padding: 10px; text-align: right; background-color: ${implCorrBg}; color: ${implCorrText}; font-weight: 500;">
                                    ${formatCorrInteger(normalized.impliedCorr)}
                                </td>
                                <td style="padding: 10px; text-align: right; background-color: ${realCorrBg}; color: ${realCorrText}; font-weight: 500;">
                                    ${formatCorrInteger(normalized.realizedCorr)}
                                </td>
                                <td style="padding: 10px; text-align: right; background-color: ${diffBg}; color: ${diffText}; font-weight: 500;">
                                    ${normalized.difference >= 0 ? '+' : ''}${formatCorrInteger(normalized.difference)}
                                </td>
                            </tr>`;
                    });

                    // Sub-group summary
                    const subAvgImpl = corrArray.length > 0 ? corrArray.reduce((sum, c) => sum + c.impliedCorr, 0) / corrArray.length : 0;
                    const subAvgReal = corrArray.length > 0 ? corrArray.reduce((sum, c) => sum + c.realizedCorr, 0) / corrArray.length : 0;
                    const subAvgDiff = corrArray.length > 0 ? corrArray.reduce((sum, c) => sum + c.difference, 0) / corrArray.length : 0;

                    const subAvgImplBg = getEmailCellColor(subAvgImpl, scales.impliedCorr);
                    const subAvgRealBg = getEmailCellColor(subAvgReal, scales.realizedCorr);
                    const subAvgDiffBg = getEmailCellColor(subAvgDiff, scales.corrDiff);

                    // Email always uses dark text on light backgrounds
                    const emailTextColor = '#1f2937';

                    html += `
                        </tbody>
                        <tfoot>
                            <tr style="border-top: 2px solid #06b6d4; background: #f3f4f6; font-weight: 600;">
                                <td colspan="2" style="padding: 10px; color: #1f2937;">SUB-GROUP AVERAGE (${corrArray.length})</td>
                                <td style="padding: 10px; text-align: right; background-color: ${subAvgImplBg}; color: ${emailTextColor};">
                                    ${formatCorrInteger(subAvgImpl)}
                                </td>
                                <td style="padding: 10px; text-align: right; background-color: ${subAvgRealBg}; color: ${emailTextColor};">
                                    ${formatCorrInteger(subAvgReal)}
                                </td>
                                <td style="padding: 10px; text-align: right; background-color: ${subAvgDiffBg}; color: ${emailTextColor};">
                                    ${subAvgDiff >= 0 ? '+' : ''}${formatCorrInteger(subAvgDiff)}
                                </td>
                            </tr>
                        </tfoot>
                    </table>
                </div>
            </div>`;
                });

                // Overall block summary
                const uniqueCorrelations = data.allCorrelations;
                const overallAvgImpl = uniqueCorrelations.reduce((sum, c) => sum + c.impliedCorr, 0) / uniqueCorrelations.length;
                const overallAvgReal = uniqueCorrelations.reduce((sum, c) => sum + c.realizedCorr, 0) / uniqueCorrelations.length;
                const overallAvgDiff = uniqueCorrelations.reduce((sum, c) => sum + c.difference, 0) / uniqueCorrelations.length;

                const overallImplBg = getEmailCellColor(overallAvgImpl, scales.impliedCorr);
                const overallRealBg = getEmailCellColor(overallAvgReal, scales.realizedCorr);
                const overallDiffBg = getEmailCellColor(overallAvgDiff, scales.corrDiff);

                // Email always uses dark text on light backgrounds
                const emailTextColor = '#1f2937';

                html += `
            <div style="margin-top: 20px; padding: 16px; background: #f3f4f6; border-left: 3px solid #06b6d4; border-radius: 4px;">
                <div style="font-weight: 700; margin-bottom: 12px; color: #1f2937;">
                    ${mainCurrency} OVERALL AVERAGE (${uniqueCorrelations.length} unique correlations)
                </div>
                <table style="width: 100%; border-collapse: collapse; font-family: 'SF Mono', Monaco, monospace; font-size: 13px;">
                    <tr>
                        <td style="padding: 8px; text-align: center; background-color: ${overallImplBg}; color: ${emailTextColor}; font-weight: 600; border-radius: 4px;">
                            Impl: ${formatCorrInteger(overallAvgImpl)}
                        </td>
                        <td style="width: 8px;"></td>
                        <td style="padding: 8px; text-align: center; background-color: ${overallRealBg}; color: ${emailTextColor}; font-weight: 600; border-radius: 4px;">
                            Real: ${formatCorrInteger(overallAvgReal)}
                        </td>
                        <td style="width: 8px;"></td>
                        <td style="padding: 8px; text-align: center; background-color: ${overallDiffBg}; color: ${emailTextColor}; font-weight: 600; border-radius: 4px;">
                            Diff: ${overallAvgDiff >= 0 ? '+' : ''}${formatCorrInteger(overallAvgDiff)}
                        </td>
                    </tr>
                </table>
            </div>
            </div>
        </div>`;
            });

            html += `
        </div>
    </div>
</div>`;

            return html;
        }

        function generateEmailReport() {
            if (!window.batchAnalysisResults || !window.analyzedPairs) {
                return `<html><body><p>Error: No analysis results available. Please run an analysis first.</p></body></html>`;
            }

            const scales = calculateGlobalScales(window.batchAnalysisResults, window.correlationAnalysisResults);

            let emailHTML = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
    </style>
</head>
<body>

${generateEmailHeader(window.analysisConfig || {}, window.analyzedPairs, window.uploadedTimestamps, window.currencies || [])}

${generateTop5VolTable(window.batchAnalysisResults, scales)}

${generateBottom5VolTable(window.batchAnalysisResults, scales)}

${Object.keys(window.correlationAnalysisResults || {}).length > 0 ? generateTop5CorrTable(window.correlationAnalysisResults, scales) : ''}

${Object.keys(window.correlationAnalysisResults || {}).length > 0 ? generateBottom5CorrTable(window.correlationAnalysisResults, scales) : ''}

${generateExpandableFullResults(window.batchAnalysisResults, window.correlationAnalysisResults, scales, window.currencies || [])}

${/* Correlation matrix section removed from email - only available on webpage */ ''}

<div style="margin-top: 48px; padding-top: 24px; border-top: 2px solid #e5e7eb; text-align: center; color: #6b7280; font-size: 12px;">
    Generated: ${new Date().toLocaleString('en-US', { timeZone: 'America/New_York' })} EST
</div>

</body>
</html>`;

            return emailHTML;
        }

        function stripHTMLTags(html) {
            const tmp = document.createElement('DIV');
            tmp.innerHTML = html;
            return tmp.textContent || tmp.innerText || '';
        }

        async function copyEmailReport() {
            const statusEl = document.getElementById('exportStatusOverview') || document.getElementById('exportStatus');
            
            try {
                const emailHTML = generateEmailReport();
                const plainText = stripHTMLTags(emailHTML);

                // Try modern ClipboardItem API first (Chrome, Edge, newer browsers)
                if (navigator.clipboard && window.ClipboardItem) {
                    try {
                        const htmlBlob = new Blob([emailHTML], { type: 'text/html' });
                        const textBlob = new Blob([plainText], { type: 'text/plain' });
                        
                        const clipboardItem = new ClipboardItem({
                            'text/html': htmlBlob,
                            'text/plain': textBlob
                        });
                        
                        await navigator.clipboard.write([clipboardItem]);
                        
                if (statusEl) {
                    statusEl.innerHTML = '‚úì Email report copied to clipboard! Paste into Outlook/Gmail.';
                    statusEl.style.color = 'var(--green)';
                    setTimeout(() => { statusEl.innerHTML = ''; }, 5000);
                        }
                        return;
                    } catch (clipboardError) {
                        console.warn('ClipboardItem API failed, trying fallback:', clipboardError);
                        // Fall through to fallback method
                    }
                }

                // Fallback: Create a temporary div with the HTML content
                const div = document.createElement('div');
                div.contentEditable = true;
                div.innerHTML = emailHTML;
                div.style.position = 'fixed';
                div.style.left = '-9999px';
                div.style.top = '0';
                document.body.appendChild(div);
                
                const range = document.createRange();
                range.selectNodeContents(div);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
                
                try {
                    const successful = document.execCommand('copy');
                    selection.removeAllRanges();
                    document.body.removeChild(div);
                    
                    if (successful) {
                        if (statusEl) {
                            statusEl.innerHTML = '‚úì Email report copied to clipboard! Paste into Outlook/Gmail.';
                            statusEl.style.color = 'var(--green)';
                            setTimeout(() => { statusEl.innerHTML = ''; }, 5000);
                        }
                    } else {
                        throw new Error('execCommand copy failed');
                    }
                } catch (execError) {
                    selection.removeAllRanges();
                    if (document.body.contains(div)) {
                        document.body.removeChild(div);
                    }
                    throw execError;
                }

            } catch (error) {
                console.error('Copy failed:', error);
                if (statusEl) {
                    statusEl.innerHTML = '‚úó Copy failed. Try Chrome/Edge or right-click and copy. Error: ' + (error.message || error.toString());
                    statusEl.style.color = 'var(--red)';
                }
            }
        }

        function getTop5Vol(pnlResults) {
            return Object.entries(pnlResults)
                .filter(([_, data]) => !data.error)
                .map(([pair, data]) => ({
                    pair,
                    implVol: data.impliedVol,
                    realVol: data.realizedVol,
                    volDiff: data.volDiff,
                    avgPnL: data.avgPnL
                }))
                .sort((a, b) => b.volDiff - a.volDiff)
                .slice(0, 5);
        }

        function getBottom5Vol(pnlResults) {
            return Object.entries(pnlResults)
                .filter(([_, data]) => !data.error)
                .map(([pair, data]) => ({
                    pair,
                    implVol: data.impliedVol,
                    realVol: data.realizedVol,
                    volDiff: data.volDiff,
                    avgPnL: data.avgPnL
                }))
                .sort((a, b) => a.volDiff - b.volDiff)
                .slice(0, 5);
        }

        function getTop5Correlations(correlationResults) {
            const allCorrelations = [];
            Object.entries(correlationResults || {}).forEach(([currency, data]) => {
                if (data.correlations) {
                    data.correlations.forEach(corr => {
                        allCorrelations.push({
                            currency: currency,
                            pair1: corr.pair1,
                            pair2: corr.pair2,
                            impl: corr.impliedCorr,
                            real: corr.realizedCorr,
                            diff: corr.difference
                        });
                    });
                }
            });

            return allCorrelations
                .sort((a, b) => b.diff - a.diff)
                .slice(0, 5);
        }

        function getBottom5Correlations(correlationResults) {
            const allCorrelations = [];
            Object.entries(correlationResults || {}).forEach(([currency, data]) => {
                if (data.correlations) {
                    data.correlations.forEach(corr => {
                        allCorrelations.push({
                            currency: currency,
                            pair1: corr.pair1,
                            pair2: corr.pair2,
                            impl: corr.impliedCorr,
                            real: corr.realizedCorr,
                            diff: corr.difference
                        });
                    });
                }
            });

            // Sort ascending (most negative first)
            return allCorrelations
                .sort((a, b) => a.diff - b.diff)
                .slice(0, 5);
        }

        function generateBloombergChat() {
            if (!window.uploadedTimestamps || window.uploadedTimestamps.length === 0) {
                return 'Error: No timestamp data available';
            }

            const startTime = window.uploadedTimestamps[0];
            const endTime = window.uploadedTimestamps[window.uploadedTimestamps.length - 1];
            const durationHours = calculateDurationHours(window.uploadedTimestamps);
            const rebalFreq = window.analysisConfig?.rebalancingFrequency || 'Daily';
            const expiryText = window.analysisConfig?.optionExpiry || 'Full period';

            const top5Vol = getTop5Vol(window.batchAnalysisResults || {});
            const bottom5Vol = getBottom5Vol(window.batchAnalysisResults || {});
            const top5Corr = getTop5Correlations(window.correlationAnalysisResults || {});
            const bottom5Corr = getBottom5Correlations(window.correlationAnalysisResults || {});
            const formatShortDateTime = (ts) => {
                const d = new Date(ts);
                return `${d.getMonth()+1}/${d.getDate()} ${d.getHours()}:${String(d.getMinutes()).padStart(2,'0')}`;
            };

            let text = `
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
FX Options P&L, Vol, Correlation Analysis
${formatShortDateTime(startTime)} to ${formatShortDateTime(endTime)} EST (${durationHours}h)
Rebal: ${rebalFreq} | Expiry: ${expiryText} | $100M per strike
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

TOP 5 VOL (Real > Impl):
${top5Vol.map((item, i) => 
    `${i+1}. ${item.pair.padEnd(8)} ${(item.volDiff >= 0 ? '+' : '')}${(item.volDiff*100).toFixed(2)}%  (${(item.implVol*100).toFixed(2)}% ‚Üí ${(item.realVol*100).toFixed(2)}%)  ${formatPnLRounded(item.avgPnL)}`
).join('\n')}

BOTTOM 5 VOL (Real < Impl):
${bottom5Vol.map((item, i) => {
    const totalPairs = Object.keys(window.batchAnalysisResults || {}).filter(p => !window.batchAnalysisResults[p].error).length;
    const rank = totalPairs - 4 + i;
    return `${rank}. ${item.pair.padEnd(8)} ${(item.volDiff >= 0 ? '+' : '')}${(item.volDiff*100).toFixed(2)}%  (${(item.implVol*100).toFixed(2)}% ‚Üí ${(item.realVol*100).toFixed(2)}%)  ${formatPnLRounded(item.avgPnL)}`;
}).join('\n')}

${top5Corr.length > 0 ? `TOP 5 CORR:
${top5Corr.map((item, i) => 
    `${i+1}. ${item.currency}: ${item.pair1}-${item.pair2} ${(item.diff >= 0 ? '+' : '')}${Math.round(item.diff*100)}% (${Math.round(item.impl*100)}%‚Üí${Math.round(item.real*100)}%)`
).join('\n')}

` : ''}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Full report in email.
`;

            return text;
        }

        async function copyBloombergChat() {
            try {
                const bbgText = generateBloombergChat();

                await navigator.clipboard.writeText(bbgText);

                const statusEl = document.getElementById('exportStatusOverview') || document.getElementById('exportStatus');
                if (statusEl) {
                    statusEl.innerHTML = '‚úì Bloomberg chat copied! Paste into terminal.';
                    statusEl.style.color = 'var(--green)';
                    setTimeout(() => { statusEl.innerHTML = ''; }, 5000);
                }

            } catch (error) {
                console.error('Copy failed:', error);
                const statusEl = document.getElementById('exportStatusOverview') || document.getElementById('exportStatus');
                if (statusEl) {
                    statusEl.innerHTML = '‚úó Copy failed. Please try again.';
                    statusEl.style.color = 'var(--red)';
                }
            }
        }

        function displayResultsWithTabs(pnlResults, correlationResults) {
            // Store results globally for export functions
            window.batchAnalysisResults = pnlResults;
            window.correlationAnalysisResults = correlationResults || {};
            window.analyzedPairs = Object.keys(pnlResults).filter(pair => !pnlResults[pair].error);
            window.uploadedTimestamps = batchData.timestamps || [];
            
            // Store results for chart modal access
            window.lastPnLResults = pnlResults;
            window.lastTimestamps = batchData.timestamps || [];
            window.currencies = batchData.currencies || [];
            
            // Store analysis config
            const baseFreq = parseInt(document.getElementById('batchBaseFrequency').value);
            const hedgeFreq = parseInt(document.getElementById('batchHedgeFrequency').value);
            const expiryMode = document.querySelector('input[name="batchExpiryMode"]:checked').value;
            let optionTenorMinutes;
            if (expiryMode === 'custom') {
                const customValue = parseFloat(document.getElementById('customExpiryInput').value);
                const customUnit = document.getElementById('customExpiryUnit').value;
                optionTenorMinutes = (customUnit === 'hours') ? customValue * 60 : customValue;
            }
            
            // Map rebalancing frequency
            const rebalFreqMap = {
                60: 'Hourly',
                1440: 'Daily',
                10080: 'Weekly'
            };
            
            // Convert option expiry to hours for display
            let expiryHours;
            let expiryDisplay = 'Full period';
            if (expiryMode === 'custom' && optionTenorMinutes) {
                expiryHours = Math.round(optionTenorMinutes / 60);
                expiryDisplay = `${expiryHours} hours`;
            } else {
                // Calculate from analysis window
                const analysisData = window.currentAnalysisData || batchData;
                if (analysisData.timestamps && analysisData.timestamps.length > 0) {
                    const startTime = new Date(analysisData.timestamps[0]);
                    const endTime = new Date(analysisData.timestamps[analysisData.timestamps.length - 1]);
                    expiryHours = Math.round((endTime - startTime) / (1000 * 60 * 60));
                    expiryDisplay = `${expiryHours} hours (end of series)`;
                }
            }
            
            window.analysisConfig = {
                rebalancingFrequency: rebalFreqMap[hedgeFreq] || `Every ${hedgeFreq} minutes`,
                optionExpiry: expiryDisplay,
                optionExpiryHours: expiryHours
            };
            
            // Sort pairs by avgPnL
            const pairResults = Object.entries(pnlResults)
                .filter(([_, result]) => !result.error)
                .sort((a, b) => b[1].avgPnL - a[1].avgPnL);

            // Generate content for each tab
            const overviewHTML = generateOverviewTab(pairResults, correlationResults);
            const pnlHTML = generatePnLTab(pairResults);
            const corrHTML = generateCorrelationTab(correlationResults);
            const corr2HTML = generateCorrelationMatrixTab(window.correlationMatrix);
            const chartsHTML = generateChartsTab();
            const basketHTML = generateBasketDecompositionTab();

            // Build tabbed interface
            let html = `
                <div class="batch-tabs-container">
                    <div class="batch-tabs">
                        <button class="batch-tab active" data-tab="overview" onclick="switchBatchTab('overview')">
                            üìä Overview
                        </button>
                        <button class="batch-tab" data-tab="pnl" onclick="switchBatchTab('pnl')">
                            üí∞ P&L Analysis
                        </button>
                        <button class="batch-tab" data-tab="correlation" onclick="switchBatchTab('correlation')">
                            üîó Correlation 1
                        </button>
                        <button class="batch-tab" data-tab="correlation2" onclick="switchBatchTab('correlation2')">
                            üîó Correlation 2
                        </button>
                        <button class="batch-tab" data-tab="charts" onclick="switchBatchTab('charts')">
                            üìà Charts
                        </button>
                        <button class="batch-tab" data-tab="basket" onclick="switchBatchTab('basket')">
                            üß∫ Basket Decomposition
                        </button>
                    </div>
                </div>

                <div class="filter-panel">
                    <div class="filter-controls">
                        <div class="filter-group">
                            <label for="pairSearch">Search Pairs</label>
                            <input 
                                type="text" 
                                id="pairSearch" 
                                placeholder="Type pair name (e.g., EURUSD, GBP, JPY...)"
                                oninput="filterResults()"
                            />
                        </div>
                        
                        <div class="filter-group">
                            <label for="currencyFilter">Filter by Currency</label>
                            <select id="currencyFilter" onchange="filterResults()">
                                <option value="">All Currencies</option>
                                <option value="USD">USD Pairs</option>
                                <option value="EUR">EUR Crosses</option>
                                <option value="GBP">GBP Crosses</option>
                                <option value="CHF">CHF Crosses</option>
                                <option value="JPY">JPY Crosses</option>
                                <option value="AUD">AUD Crosses</option>
                                <option value="NZD">NZD Crosses</option>
                                <option value="CAD">CAD Crosses</option>
                            </select>
                        </div>
                        
                        <div class="filter-group" style="flex: 0;">
                            <label>&nbsp;</label>
                            <button class="btn btn-secondary" onclick="clearFilters()">
                                ‚úï Clear
                            </button>
                        </div>
                    </div>
                    
                    <div id="filterStatus" class="filter-status"></div>
                </div>

                <div id="tab-overview" class="batch-tab-panel active">
                    ${overviewHTML}
                </div>

                <div id="tab-pnl" class="batch-tab-panel">
                    ${pnlHTML}
                </div>

                <div id="tab-correlation" class="batch-tab-panel">
                    ${corrHTML}
                </div>

                <div id="tab-correlation2" class="batch-tab-panel">
                    ${corr2HTML}
                </div>

                <div id="tab-charts" class="batch-tab-panel">
                    ${chartsHTML}
                </div>

                <div id="tab-basket" class="batch-tab-panel">
                    ${basketHTML}
                </div>
            `;

            // Update content div instead of replacing entire batchResults
            const contentDiv = document.getElementById('batchResultsContent');
            if (contentDiv) {
                contentDiv.innerHTML = html;
            } else {
                // Fallback: if content div doesn't exist, use batchResults
                document.getElementById('batchResults').innerHTML = html;
            }
            
            // Hide old export buttons (now in Overview tab)
            const exportButtons = document.getElementById('exportButtons');
            if (exportButtons) {
                exportButtons.style.display = 'none';
            }
            
            // Restore collapsed states from previous session
            setTimeout(() => {
                restoreCurrencyBlockStates();
            }, 100);
        }

        // Current active batch tab
        let currentBatchTab = 'overview';

        function switchBatchTab(tabName) {
            currentBatchTab = tabName;
            
            // Hide all tab panels
            document.querySelectorAll('.batch-tab-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            
            // Show selected tab panel
            const selectedPanel = document.getElementById('tab-' + tabName);
            if (selectedPanel) {
                selectedPanel.classList.add('active');
            }
            
            // Update tab button states
            document.querySelectorAll('.batch-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            const selectedTab = document.querySelector('.batch-tab[data-tab="' + tabName + '"]');
            if (selectedTab) {
                selectedTab.classList.add('active');
            }
            
            // Clear filters when switching tabs
            clearFilters();
        }

        // ============================================
        // SEARCH & FILTER FUNCTIONALITY
        // ============================================
        
        // Filter state
        let currentSearchTerm = '';
        let currentCurrencyFilter = '';
        let searchTimeout;

        // Main filter function (debounced)
        function filterResults() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                const searchInput = document.getElementById('pairSearch');
                const currencySelect = document.getElementById('currencyFilter');
                
                currentSearchTerm = searchInput ? searchInput.value.toUpperCase() : '';
                currentCurrencyFilter = currencySelect ? currencySelect.value : '';
                
                filterTables();
                updateFilterStatus();
            }, 200); // Wait 200ms after user stops typing
        }

        // Filter all tables
        function filterTables() {
            // Get all data tables in active tab
            const activeTab = document.querySelector('.batch-tab-panel.active');
            if (!activeTab) return;
            
            const tables = activeTab.querySelectorAll('.data-table');
            let totalVisible = 0;
            let totalRows = 0;
            
            tables.forEach(table => {
                const tbody = table.querySelector('tbody');
                if (!tbody) return;
                
                const rows = tbody.querySelectorAll('tr');
                let visibleCount = 0;
                
                rows.forEach(row => {
                    // Get pair name from first or second cell
                    const cells = row.querySelectorAll('td');
                    let pairName = '';
                    
                    // Try to find a cell that looks like a pair name
                    for (let i = 0; i < Math.min(3, cells.length); i++) {
                        const cellText = cells[i].textContent.trim().toUpperCase();
                        // Check if it looks like a currency pair
                        if (cellText.match(/^[A-Z]{6,7}$/) || cellText.includes('USD') || cellText.includes('EUR') || cellText.includes('GBP')) {
                            pairName = cellText;
                            break;
                        }
                    }
                    
                    // If no pair found, use first cell
                    if (!pairName && cells[0]) {
                        pairName = cells[0].textContent.trim().toUpperCase();
                    }
                    
                    totalRows++;
                    
                    // Check if row matches filters
                    let matchesSearch = true;
                    let matchesCurrency = true;
                    
                    // Search filter
                    if (currentSearchTerm) {
                        matchesSearch = pairName.includes(currentSearchTerm);
                    }
                    
                    // Currency filter
                    if (currentCurrencyFilter) {
                        matchesCurrency = pairName.includes(currentCurrencyFilter);
                    }
                    
                    // Show or hide row
                    if (matchesSearch && matchesCurrency) {
                        row.style.display = '';
                        visibleCount++;
                        totalVisible++;
                    } else {
                        row.style.display = 'none';
                    }
                });
                
                // Handle empty table containers
                const container = table.closest('.currency-group-section, .summary-section, .currency-block, .card');
                if (container && container.querySelector('table') === table) {
                    if (visibleCount === 0 && (currentSearchTerm || currentCurrencyFilter)) {
                        container.style.opacity = '0.3';
                    } else {
                        container.style.opacity = '';
                    }
                }
            });
            
            // Also filter expandable pairs
            const expandablePairs = activeTab.querySelectorAll('.expandable-pair');
            expandablePairs.forEach(pair => {
                const header = pair.querySelector('.pair-header');
                if (!header) return;
                
                const pairName = header.textContent.trim().toUpperCase();
                
                let matchesSearch = !currentSearchTerm || pairName.includes(currentSearchTerm);
                let matchesCurrency = !currentCurrencyFilter || pairName.includes(currentCurrencyFilter);
                
                if (matchesSearch && matchesCurrency) {
                    pair.style.display = '';
                } else {
                    pair.style.display = 'none';
                }
            });
        }

        // Update filter status message
        function updateFilterStatus() {
            const statusDiv = document.getElementById('filterStatus');
            if (!statusDiv) return;
            
            const hasFilters = currentSearchTerm || currentCurrencyFilter;
            
            if (!hasFilters) {
                statusDiv.textContent = '';
                statusDiv.classList.remove('active');
                return;
            }
            
            // Count visible pairs in active tab
            const activeTab = document.querySelector('.batch-tab-panel.active');
            if (!activeTab) return;
            
            let visiblePairs = 0;
            let totalPairs = 0;
            
            const tables = activeTab.querySelectorAll('.data-table tbody');
            tables.forEach(tbody => {
                const rows = tbody.querySelectorAll('tr');
                rows.forEach(row => {
                    totalPairs++;
                    if (row.style.display !== 'none') {
                        visiblePairs++;
                    }
                });
            });
            
            // Build status message
            let message = `Showing ${visiblePairs} of ${totalPairs} rows`;
            
            if (currentSearchTerm) {
                message += ` matching "${currentSearchTerm}"`;
            }
            
            if (currentCurrencyFilter) {
                message += ` in ${currentCurrencyFilter}`;
            }
            
            statusDiv.textContent = message;
            statusDiv.classList.add('active');
        }

        // Clear all filters
        function clearFilters() {
            // Clear input values
            const searchInput = document.getElementById('pairSearch');
            const currencySelect = document.getElementById('currencyFilter');
            
            if (searchInput) searchInput.value = '';
            if (currencySelect) currencySelect.value = '';
            
            // Reset filter state
            currentSearchTerm = '';
            currentCurrencyFilter = '';
            
            // Show all rows in all tabs
            const tables = document.querySelectorAll('.data-table');
            tables.forEach(table => {
                const tbody = table.querySelector('tbody');
                if (!tbody) return;
                
                const rows = tbody.querySelectorAll('tr');
                rows.forEach(row => {
                    row.style.display = '';
                });
                
                // Reset container opacity
                const container = table.closest('.currency-group-section, .summary-section, .currency-block, .card');
                if (container) {
                    container.style.opacity = '';
                }
            });
            
            // Show all expandable pairs
            const expandablePairs = document.querySelectorAll('.expandable-pair');
            expandablePairs.forEach(pair => {
                pair.style.display = '';
            });
            
            // Clear status
            const statusDiv = document.getElementById('filterStatus');
            if (statusDiv) {
                statusDiv.textContent = '';
                statusDiv.classList.remove('active');
            }
        }

        // Keyboard shortcuts for search
        document.addEventListener('keydown', function(e) {
            // Ctrl+F or Cmd+F to focus search
            if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                const searchInput = document.getElementById('pairSearch');
                if (searchInput && document.querySelector('.batch-tab-panel.active')) {
                    e.preventDefault();
                    searchInput.focus();
                    searchInput.select();
                }
            }
            
            // Escape to clear filters when in search box
            if (e.key === 'Escape') {
                const searchInput = document.getElementById('pairSearch');
                if (searchInput && document.activeElement === searchInput) {
                    clearFilters();
                    searchInput.blur();
                }
            }
        });

        // ============================================
        // COLLAPSIBLE CURRENCY BLOCKS
        // ============================================

        // Toggle currency block expand/collapse
        function toggleCurrencyBlock(headerElement) {
            // Get the content container
            const contentElement = headerElement.nextElementSibling;
            
            if (!contentElement || !contentElement.classList.contains('currency-content')) {
                console.warn('Currency content not found');
                return;
            }
            
            // Toggle collapsed state
            const isCollapsed = contentElement.classList.contains('collapsed');
            
            if (isCollapsed) {
                // Expand
                headerElement.classList.remove('collapsed');
                contentElement.classList.remove('collapsed');
            } else {
                // Collapse
                headerElement.classList.add('collapsed');
                contentElement.classList.add('collapsed');
            }
            
            // Save state to localStorage
            saveCurrencyBlockState(headerElement, !isCollapsed);
        }

        // Save collapsed state to localStorage
        function saveCurrencyBlockState(headerElement, isCollapsed) {
            const currencyName = headerElement.querySelector('.currency-name')?.textContent.trim();
            if (!currencyName) return;
            
            // Create a clean key (remove emojis and special chars)
            const cleanKey = currencyName.replace(/[^\w\s-]/g, '').trim().replace(/\s+/g, '_');
            const stateKey = `currencyBlock_${cleanKey}`;
            localStorage.setItem(stateKey, isCollapsed ? 'collapsed' : 'expanded');
        }

        // Restore collapsed states from localStorage
        function restoreCurrencyBlockStates() {
            const headers = document.querySelectorAll('.collapsible');
            
            headers.forEach(header => {
                const currencyName = header.querySelector('.currency-name')?.textContent.trim();
                if (!currencyName) return;
                
                // Create same clean key
                const cleanKey = currencyName.replace(/[^\w\s-]/g, '').trim().replace(/\s+/g, '_');
                const stateKey = `currencyBlock_${cleanKey}`;
                const savedState = localStorage.getItem(stateKey);
                
                if (savedState === 'collapsed') {
                    const contentElement = header.nextElementSibling;
                    if (contentElement && contentElement.classList.contains('currency-content')) {
                        header.classList.add('collapsed');
                        contentElement.classList.add('collapsed');
                    }
                }
            });
        }

        // Expand all currency blocks
        function expandAllBlocks() {
            const activeTab = document.querySelector('.batch-tab-panel.active');
            if (!activeTab) return;
            
            const headers = activeTab.querySelectorAll('.collapsible');
            const contents = activeTab.querySelectorAll('.currency-content');
            
            headers.forEach(header => header.classList.remove('collapsed'));
            contents.forEach(content => content.classList.remove('collapsed'));
            
            // Clear localStorage for expanded blocks
            Object.keys(localStorage).forEach(key => {
                if (key.startsWith('currencyBlock_')) {
                    localStorage.removeItem(key);
                }
            });
        }

        // Collapse all currency blocks
        function collapseAllBlocks() {
            const activeTab = document.querySelector('.batch-tab-panel.active');
            if (!activeTab) return;
            
            const headers = activeTab.querySelectorAll('.collapsible');
            const contents = activeTab.querySelectorAll('.currency-content');
            
            headers.forEach(header => {
                header.classList.add('collapsed');
                const currencyName = header.querySelector('.currency-name')?.textContent.trim();
                if (currencyName) {
                    const cleanKey = currencyName.replace(/[^\w\s-]/g, '').trim().replace(/\s+/g, '_');
                    localStorage.setItem(`currencyBlock_${cleanKey}`, 'collapsed');
                }
            });
            
            contents.forEach(content => content.classList.add('collapsed'));
        }

        // ============================================
        // MODAL CHART SYSTEM
        // ============================================

        // Current chart data
        let currentChartData = null;

        // Open chart modal
        function openChartModal(pair, strikeType) {
            console.log('=== openChartModal ===', pair, strikeType);
            const modal = document.getElementById('chartModal');
            console.log('Modal element:', modal);
            console.log('Modal class before:', modal?.className);
            
            if (!modal) {
                alert('Modal not found');
                return;
            }
            
            // Force display
            modal.style.display = 'flex';
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
            console.log('Modal class after:', modal.className);
            console.log('Modal display:', window.getComputedStyle(modal).display);
            
            // Update title
            const strikeNames = {
                'put10Delta': '10Œî Put',
                'put25Delta': '25Œî Put',
                'atmCall': 'ATM Call',
                'call25Delta': '25Œî Call',
                'call10Delta': '10Œî Call',
                'avgPnL': 'Average P&L'
            };
            
            const titleEl = document.getElementById('modalTitle');
            if (titleEl) {
                titleEl.textContent = `${pair} - ${strikeNames[strikeType] || strikeType}`;
            }
            
            // Display pair info and generate chart if data available
            if (window.lastPnLResults && window.lastPnLResults[pair]) {
                const pairData = window.lastPnLResults[pair];
                // Store current strike type for table row clicks
                window.currentStrikeType = strikeType;
                displayPairInfo(pair, pairData, strikeType);
                displayStrikeBreakdown(pair, pairData, strikeType);
                
                // Generate the interactive chart
                generatePnLChart(pair, strikeType, pairData);
            } else {
                // Show placeholder if no data
                const chartContainer = document.getElementById('chartContainer');
                if (chartContainer) {
                    chartContainer.innerHTML = `
                        <div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #0d0d0d;">
                            <div style="text-align: center; color: #888;">
                                <div style="font-size: 48px; margin-bottom: 12px;">üìà</div>
                                <div style="color: #00ffff; font-size: 16px; margin-bottom: 8px;">No Data Available</div>
                                <div style="font-size: 13px;">Run analysis first to see charts.</div>
                            </div>
                        </div>
                    `;
                }
                
                const infoContainer = document.getElementById('modalPairInfo');
                if (infoContainer) {
                    infoContainer.innerHTML = `
                        <div style="text-align: center; padding: 20px; color: var(--text-secondary);">
                            Pair data will appear after running analysis.
                        </div>
                    `;
                }
            }
        }

        // Close chart modal
        function closeChartModal() {
            console.log('closeChartModal called');
            const modal = document.getElementById('chartModal');
            if (modal) {
                modal.style.display = 'none';
                modal.classList.remove('active');
            }
            // Always restore body scroll
            document.body.style.overflow = '';
            document.body.style.overflowY = 'auto';
        }

        // Load and display chart data
        function loadChartData(pair, strikeType) {
            // Update modal title
            const titleEl = document.getElementById('modalTitle');
            if (titleEl) {
                const strikeNames = {
                    'put10Delta': '10Œî Put',
                    'put25Delta': '25Œî Put',
                    'atmCall': 'ATM Call',
                    'call25Delta': '25Œî Call',
                    'call10Delta': '10Œî Call',
                    'avgPnL': 'Average P&L'
                };
                titleEl.textContent = `${pair} - ${strikeNames[strikeType] || strikeType}`;
            }
            
            // Get pair data from stored results
            const pairData = window.lastPnLResults?.[pair];
            
            if (!pairData) {
                console.error('Pair data not found:', pair);
                document.getElementById('modalPairInfo').innerHTML = 
                    '<div style="color: var(--red);">Error: Pair data not found. Please run analysis first.</div>';
                return;
            }
            
            // Store current data for chart export
            currentChartData = { pair, strikeType, data: pairData };
            
            // Display pair info summary
            displayPairInfo(pair, pairData);
            
            // Generate and display chart
            generatePnLChart(pair, strikeType, pairData);
            
            // Display strike breakdown
            displayStrikeBreakdown(pair, pairData);
        }

        // Display pair info summary
        function displayPairInfo(pair, data, strikeType) {
            const infoContainer = document.getElementById('modalPairInfo');
            if (!infoContainer) return;
            
            // Use volDiff (the actual property name in the data object)
            const volDiff = data.volDiff || 0;
            const volDiffColor = volDiff >= 0 ? 'var(--green)' : 'var(--red)';
            
            // Get the specific strike's P&L instead of average
            const strikeNames = {
                'put10Delta': '10Œî Put',
                'put25Delta': '25Œî Put',
                'atmCall': 'ATM Call',
                'call25Delta': '25Œî Call',
                'call10Delta': '10Œî Call'
            };
            const strikeName = strikeNames[strikeType];
            let strikePnL = null;
            let strikePnLColor = 'var(--text-white)';
            
            if (strikeName && data.strikes && data.strikes[strikeName]) {
                strikePnL = data.strikes[strikeName].finalPnL;
                strikePnLColor = strikePnL >= 0 ? 'var(--green)' : 'var(--red)';
            }
            
            const html = `
                <div class="info-item">
                    <div class="info-label">Pair</div>
                    <div class="info-value">${pair}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Implied Vol</div>
                    <div class="info-value">${formatVolDecimal(data.impliedVol)}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Realized Vol</div>
                    <div class="info-value">${formatVolDecimal(data.realizedVol)}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Vol Difference</div>
                    <div class="info-value" style="color: ${volDiffColor};">
                        ${volDiff >= 0 ? '+' : ''}${formatVolDecimal(volDiff)}
                    </div>
                </div>
                <div class="info-item">
                    <div class="info-label">${strikeName ? strikeName + ' P&L' : 'P&L'}</div>
                    <div class="info-value" style="color: ${strikePnLColor};">
                        ${strikePnL !== null ? formatPnLRounded(strikePnL) : '‚Äî'}
                    </div>
                </div>
            `;
            
            infoContainer.innerHTML = html;
        }

        // Display strike breakdown table
        function displayStrikeBreakdown(pair, data, currentStrikeType) {
            const container = document.getElementById('strikeBreakdown');
            if (!container) return;
            
            const strikes = data.strikes || {};
            const strikeOrder = ['10Œî Put', '25Œî Put', 'ATM Call', '25Œî Call', '10Œî Call'];
            
            // Map strike names to strikeType values
            const strikeTypeMap = {
                '10Œî Put': 'put10Delta',
                '25Œî Put': 'put25Delta',
                'ATM Call': 'atmCall',
                '25Œî Call': 'call25Delta',
                '10Œî Call': 'call10Delta'
            };
            
            let html = `
                <h4 style="margin-bottom: 12px; color: var(--text-white);">Strike Breakdown</h4>
                <table class="strike-breakdown-table">
                    <thead>
                        <tr>
                            <th>Strike</th>
                            <th>Strike Price</th>
                            <th>Final P&L</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            strikeOrder.forEach(strikeName => {
                const strike = strikes[strikeName];
                if (strike) {
                    const pnlColor = strike.finalPnL >= 0 ? 'var(--green)' : 'var(--red)';
                    const strikeType = strikeTypeMap[strikeName];
                    const isCurrent = strikeType === currentStrikeType;
                    const rowStyle = isCurrent ? 'background-color: rgba(0, 255, 255, 0.1); cursor: pointer;' : 'cursor: pointer;';
                    const hoverStyle = 'onmouseover="this.style.backgroundColor=\'rgba(0, 255, 255, 0.15)\'" onmouseout="this.style.backgroundColor=\'' + (isCurrent ? 'rgba(0, 255, 255, 0.1)' : 'transparent') + '\'"';
                    html += `
                        <tr style="${rowStyle}" ${hoverStyle} onclick="switchChartStrike('${pair}', '${strikeType}')">
                            <td style="font-weight: 500;">${strikeName}</td>
                            <td style="font-family: var(--font-mono);">${strike.strikePrice?.toFixed(4) || '‚Äî'}</td>
                            <td style="font-family: var(--font-mono); color: ${pnlColor};">
                                ${formatPnLRounded(strike.finalPnL)}
                            </td>
                        </tr>
                    `;
                }
            });
            
            // Add average P&L row
            const avgPnLColor = data.avgPnL >= 0 ? 'var(--green)' : 'var(--red)';
            html += `
                        <tr style="border-top: 2px solid var(--border); font-weight: 600; cursor: default;">
                            <td style="font-weight: 600;">Average P&L</td>
                            <td style="font-family: var(--font-mono);">‚Äî</td>
                            <td style="font-family: var(--font-mono); color: ${avgPnLColor};">
                                ${formatPnLRounded(data.avgPnL)}
                            </td>
                        </tr>
                    </tbody>
                </table>
            `;
            
            container.innerHTML = html;
        }
        
        // Switch chart to different strike when clicking table row
        function switchChartStrike(pair, strikeType) {
            console.log('Switching chart to:', pair, strikeType);
            if (window.lastPnLResults && window.lastPnLResults[pair]) {
                const pairData = window.lastPnLResults[pair];
                // Update current strike type
                window.currentStrikeType = strikeType;
                
                // Update modal title
                const strikeNames = {
                    'put10Delta': '10Œî Put',
                    'put25Delta': '25Œî Put',
                    'atmCall': 'ATM Call',
                    'call25Delta': '25Œî Call',
                    'call10Delta': '10Œî Call',
                    'avgPnL': 'Average P&L'
                };
                const titleEl = document.getElementById('modalTitle');
                if (titleEl) {
                    titleEl.textContent = `${pair} - ${strikeNames[strikeType] || strikeType}`;
                }
                
                // Update header info with new strike
                displayPairInfo(pair, pairData, strikeType);
                // Update table highlighting
                displayStrikeBreakdown(pair, pairData, strikeType);
                // Regenerate chart
                generatePnLChart(pair, strikeType, pairData);
            }
        }

        // Generate P&L chart using Plotly
        function generatePnLChart(pair, strikeType, data) {
            const chartContainer = document.getElementById('chartContainer');
            if (!chartContainer) {
                console.error('Chart container not found');
                return;
            }
            
            console.log('Generating chart for:', pair, strikeType);
            
            // Map strike type to strike name
            const strikeTypeMap = {
                'put10Delta': '10Œî Put',
                'put25Delta': '25Œî Put',
                'atmCall': 'ATM Call',
                'call25Delta': '25Œî Call',
                'call10Delta': '10Œî Call',
                'avgPnL': 'ATM Call' // Default to ATM for average view
            };
            
            const strikeName = strikeTypeMap[strikeType] || 'ATM Call';
            const strikeData = data.strikes?.[strikeName];
            
            if (!strikeData || !strikeData.pnlData || strikeData.pnlData.length === 0) {
                chartContainer.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #0d0d0d; border: 1px solid #333; border-radius: 4px;">
                        <div style="text-align: center; color: #888;">
                            <div style="font-size: 48px; margin-bottom: 12px;">üìà</div>
                            <div style="color: #ef4444; font-size: 16px; margin-bottom: 8px;">No Chart Data Available</div>
                            <div style="font-size: 13px;">Strike data not found for ${strikeName}</div>
                        </div>
                    </div>
                `;
                return;
            }
            
            const pnlData = strikeData.pnlData;
            
            // Extract data arrays (convert to thousands for readability)
            const timePoints = pnlData.map(p => p.time);
            const premiumValues = pnlData.map(p => p.premium / 1000);
            const optionValues = pnlData.map(p => p.optionValue / 1000);
            const hedgePnLs = pnlData.map(p => p.hedgePnL / 1000);
            const spotPrices = pnlData.map(p => p.spot);
            
            // Verify and recalculate portfolio values from components to ensure correctness
            // Portfolio P&L = Initial Premium Paid + Option Value + Cumulative Delta Hedge P&L
            const portfolioValues = pnlData.map((p, idx) => {
                const calculated = (p.premium + p.optionValue + p.hedgePnL) / 1000;
                const stored = p.portfolioValue / 1000;
                // Verify they match (allow for tiny floating point differences)
                if (Math.abs(calculated - stored) > 0.01) {
                    console.warn(`Portfolio value mismatch at index ${idx}: calculated=${calculated.toFixed(2)}K, stored=${stored.toFixed(2)}K`);
                }
                // Use the calculated value to ensure correctness
                return calculated;
            });
            
            // Get timestamps if available, otherwise use time in hours
            const timestamps = window.lastTimestamps || [];
            let xValues;
            let xAxisTitle;
            
            if (timestamps.length >= pnlData.length) {
                // Use actual timestamps - need to map hedge times to timestamps
                const baseFreq = window.analysisConfig?.baseFrequency || 10;
                xValues = timePoints.map(t => {
                    const idx = Math.round(t / baseFreq);
                    return timestamps[idx] ? new Date(timestamps[idx]) : t / 60;
                });
                xAxisTitle = 'Time';
            } else {
                // Use hours from start
                xValues = timePoints.map(t => t / 60);
                xAxisTitle = 'Hours from Start';
            }
            
            // Professional color palette
            const colors = {
                pnl: '#00ff88',        // Bright green - most visible (Portfolio P&L)
                premium: '#ff6b6b',    // Coral red (Initial Premium Paid)
                option: '#9d4edd',     // Purple (Option Value)
                hedge: '#4ecdc4',      // Teal (Hedge P&L)
                spot: '#ffd93d',       // Gold yellow (Spot Price)
                zero: '#444444'        // Gray for zero line
            };
            
            // Build traces - Portfolio P&L is most prominent
            const traces = [
                // Portfolio P&L (Total = Premium + Option Value + Hedge P&L) - MOST VISIBLE
                {
                    x: xValues,
                    y: portfolioValues,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Portfolio P&L',
                    line: {
                        color: colors.pnl,
                        width: 4
                    },
                    yaxis: 'y',
                    hovertemplate: '<b>Portfolio P&L</b><br>$%{y:,.1f}K<extra></extra>'
                },
                // Initial Premium Paid
                {
                    x: xValues,
                    y: premiumValues,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Initial Premium Paid',
                    line: {
                        color: colors.premium,
                        width: 2,
                        dash: 'dot'
                    },
                    yaxis: 'y',
                    hovertemplate: '<b>Initial Premium Paid</b><br>$%{y:,.1f}K<extra></extra>'
                },
                // Option Value
                {
                    x: xValues,
                    y: optionValues,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Option Value',
                    line: {
                        color: colors.option,
                        width: 2,
                        dash: 'dot'
                    },
                    yaxis: 'y',
                    hovertemplate: '<b>Option Value</b><br>$%{y:,.1f}K<extra></extra>'
                },
                // Hedge P&L (Cumulative Delta Hedging)
                {
                    x: xValues,
                    y: hedgePnLs,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Cumulative Delta Hedge P&L',
                    line: {
                        color: colors.hedge,
                        width: 2,
                        dash: 'dash'
                    },
                    yaxis: 'y',
                    hovertemplate: '<b>Cumulative Delta Hedge P&L</b><br>$%{y:,.1f}K<extra></extra>'
                },
                // Spot Price - Secondary Y axis
                {
                    x: xValues,
                    y: spotPrices,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Spot',
                    line: {
                        color: colors.spot,
                        width: 2
                    },
                    yaxis: 'y2',
                    hovertemplate: '<b>Spot</b><br>%{y:.5f}<extra></extra>'
                }
            ];
            
            // Add zero line reference
            traces.push({
                x: [xValues[0], xValues[xValues.length - 1]],
                y: [0, 0],
                type: 'scatter',
                mode: 'lines',
                name: 'Break-even',
                line: {
                    color: colors.zero,
                    width: 1,
                    dash: 'dot'
                },
                yaxis: 'y',
                showlegend: false,
                hoverinfo: 'skip'
            });
            
            // Calculate axis ranges (include premium in range calculation)
            const pnlMin = Math.min(...portfolioValues, ...premiumValues, ...optionValues, ...hedgePnLs);
            const pnlMax = Math.max(...portfolioValues, ...premiumValues, ...optionValues, ...hedgePnLs);
            const pnlRange = pnlMax - pnlMin;
            const spotMin = Math.min(...spotPrices);
            const spotMax = Math.max(...spotPrices);
            const spotRange = spotMax - spotMin;
            
            // Calculate X-axis range - ensure it starts at 0 (or minimum time value)
            const timeMin = Math.min(...timePoints);
            const timeMax = Math.max(...timePoints);
            const timeRange = timeMax - timeMin;
            // Convert to hours if using hours, otherwise use as-is for timestamps
            let xAxisMin, xAxisMax;
            if (timestamps.length >= pnlData.length) {
                // Using timestamps - let Plotly auto-range but ensure we include all data
                xAxisMin = undefined; // Let Plotly auto-range for timestamps
                xAxisMax = undefined;
            } else {
                // Using hours - explicitly set range starting from 0
                xAxisMin = 0;
                xAxisMax = timeMax / 60 + (timeRange / 60) * 0.05; // Add 5% padding on right
            }
            
            const layout = {
                paper_bgcolor: '#0a0a0a',
                plot_bgcolor: '#0d0d0d',
                font: { 
                    color: '#e0e0e0',
                    family: 'Inter, sans-serif'
                },
                xaxis: {
                    title: {
                        text: xAxisTitle,
                        font: { color: '#888', size: 12 }
                    },
                    gridcolor: '#1a1a1a',
                    zerolinecolor: '#333',
                    tickfont: { color: '#888', size: 10 },
                    showgrid: true,
                    range: xAxisMin !== undefined ? [xAxisMin, xAxisMax] : undefined
                },
                yaxis: {
                    title: {
                        text: 'P&L ($K)',
                        font: { color: colors.pnl, size: 12 }
                    },
                    gridcolor: '#1a1a1a',
                    zerolinecolor: '#444',
                    zerolinewidth: 1,
                    tickfont: { color: '#888', size: 10 },
                    tickformat: ',.0f',
                    range: [pnlMin - pnlRange * 0.1, pnlMax + pnlRange * 0.1],
                    showgrid: true,
                    side: 'left'
                },
                yaxis2: {
                    title: {
                        text: 'Spot Price',
                        font: { color: colors.spot, size: 12 }
                    },
                    tickfont: { color: colors.spot, size: 10 },
                    tickformat: '.4f',
                    range: [spotMin - spotRange * 0.1, spotMax + spotRange * 0.1],
                    overlaying: 'y',
                    side: 'right',
                    showgrid: false
                },
                legend: {
                    orientation: 'h',
                    y: -0.18,
                    x: 0.5,
                    xanchor: 'center',
                    font: { color: '#ffffff', size: 11 },
                    bgcolor: 'rgba(0,0,0,0.5)',
                    bordercolor: '#333',
                    borderwidth: 1
                },
                hovermode: 'x unified',
                hoverlabel: {
                    bgcolor: '#1a1a1a',
                    bordercolor: '#333',
                    font: { color: '#fff', size: 12 }
                },
                margin: { t: 30, b: 80, l: 70, r: 70 },
                shapes: [
                    // Zero line emphasis
                    {
                        type: 'line',
                        x0: 0,
                        x1: 1,
                        xref: 'paper',
                        y0: 0,
                        y1: 0,
                        yref: 'y',
                        line: {
                            color: '#555',
                            width: 1,
                            dash: 'dot'
                        }
                    }
                ],
                annotations: [
                    // Final P&L annotation
                    {
                        x: xValues[xValues.length - 1],
                        y: portfolioValues[portfolioValues.length - 1],
                        xref: 'x',
                        yref: 'y',
                        text: `$${portfolioValues[portfolioValues.length - 1].toFixed(1)}K`,
                        showarrow: true,
                        arrowhead: 2,
                        arrowsize: 1,
                        arrowwidth: 1,
                        arrowcolor: colors.pnl,
                        ax: 40,
                        ay: -20,
                        font: {
                            color: colors.pnl,
                            size: 11,
                            family: 'JetBrains Mono, monospace'
                        },
                        bgcolor: '#0d0d0d',
                        bordercolor: colors.pnl,
                        borderwidth: 1,
                        borderpad: 3
                    }
                ]
            };
            
            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false,
                modeBarButtonsToRemove: ['lasso2d', 'select2d', 'autoScale2d'],
                modeBarButtonsToAdd: [
                    {
                        name: 'Reset Zoom',
                        icon: Plotly.Icons.home,
                        click: function(gd) {
                            Plotly.relayout(gd, {
                                'xaxis.autorange': true,
                                'yaxis.autorange': true,
                                'yaxis2.autorange': true
                            });
                        }
                    }
                ],
                toImageButtonOptions: {
                    format: 'png',
                    filename: `${pair}_${strikeName}_pnl_chart`,
                    height: 600,
                    width: 1200,
                    scale: 2
                }
            };
            
            Plotly.newPlot(chartContainer, traces, layout, config);
            
            // Add custom CSS for better hover experience
            chartContainer.style.cursor = 'crosshair';
        }

        // Export chart as image
        function exportChart() {
            const chartContainer = document.getElementById('chartContainer');
            if (!chartContainer) return;
            
            const pair = currentChartData?.pair || 'chart';
            
            Plotly.downloadImage(chartContainer, {
                format: 'png',
                width: 1200,
                height: 600,
                filename: `${pair}_pnl_chart`
            });
        }

        // ============================================
        // CSP-SAFE EVENT LISTENERS (no inline handlers)
        // ============================================

        document.addEventListener('DOMContentLoaded', function() {
            // Modal close button (X)
            const closeBtn = document.getElementById('modalCloseBtn');
            if (closeBtn) {
                closeBtn.addEventListener('click', function() {
                    closeChartModal();
                });
            }
            
            // Modal close button (footer)
            const closeBtnFooter = document.getElementById('modalCloseBtnFooter');
            if (closeBtnFooter) {
                closeBtnFooter.addEventListener('click', function() {
                    closeChartModal();
                });
            }
            
            // Export chart button
            const exportBtn = document.getElementById('exportChartBtn');
            if (exportBtn) {
                exportBtn.addEventListener('click', function() {
                    exportChart();
                });
            }
            
            // Modal overlay click to close
            const modal = document.getElementById('chartModal');
            if (modal) {
                modal.addEventListener('click', function(e) {
                    // Only close if clicking the overlay, not the content
                    if (e.target === modal) {
                        closeChartModal();
                    }
                });
            }
            
            // Event delegation for chart cell clicks
            document.body.addEventListener('click', function(e) {
                const cell = e.target.closest('.chart-cell');
                
                if (cell) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const pair = cell.getAttribute('data-pair');
                    const strike = cell.getAttribute('data-strike');
                    
                    if (pair && strike) {
                        console.log('Opening chart for:', pair, strike);
                        openChartModal(pair, strike);
                    }
                }
            });
        });

        // Close modal with Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const modal = document.getElementById('chartModal');
                if (modal && modal.classList.contains('active')) {
                    closeChartModal();
                }
            }
        });

        function generateOverviewTab(pairResults, correlationResults) {
            let html = '<h2 style="margin-bottom: 24px;">Analysis Summary</h2>';

            // Calculate scales once for the entire tab - all tables share consistent coloring
            const scales = calculateTabScales(pairResults);

            // Analysis info box
            const analysisData = window.currentAnalysisData || batchData;
            const pairCount = pairResults.length;
            const startTime = analysisData.timestamps?.[0] ? new Date(analysisData.timestamps[0]).toLocaleString() : 'N/A';
            const endTime = analysisData.timestamps?.[analysisData.timestamps.length - 1] ? new Date(analysisData.timestamps[analysisData.timestamps.length - 1]).toLocaleString() : 'N/A';
            
            html += `
                <div class="info-box" style="margin-bottom: 24px;">
                    <p><strong>Pairs Analyzed:</strong> ${pairCount}</p>
                    <p><strong>Period:</strong> ${startTime} ‚Üí ${endTime}</p>
                    <p><strong>Rebalancing:</strong> ${window.analysisConfig?.rebalancingFrequency || 'Hourly'}</p>
                    <p><strong>Option Expiry:</strong> ${window.analysisConfig?.optionExpiry || 'Full period'}</p>
                </div>
            `;
            
            // Top 5 Vol Performers
            const top5Vol = pairResults.slice(0, 5);
            html += `
                <div class="summary-section">
                    <h3>üèÜ Top 5 P&L Performers</h3>
                    ${generateRankingTable(top5Vol, 1, scales)}
                </div>
            `;

            // Bottom 5 Vol Performers
            const bottom5Vol = pairResults.slice(-5).reverse();
            const bottom5StartRank = Math.max(1, pairResults.length - bottom5Vol.length + 1);
            html += `
                <div class="summary-section">
                    <h3>üìâ Bottom 5 P&L Performers</h3>
                    ${generateRankingTable(bottom5Vol, bottom5StartRank, scales)}
                </div>
            `;
            
            // Top 5 Correlations (if available)
            if (correlationResults && Object.keys(correlationResults).length > 0) {
                const allCorrelations = [];
                Object.entries(correlationResults).forEach(([currency, data]) => {
                    if (data.correlations) {
                        data.correlations.forEach(corr => {
                            allCorrelations.push({
                                currency,
                                ...corr,
                                diff: (corr.realizedCorr || 0) - (corr.impliedCorr || 0)
                            });
                        });
                    }
                });
                
                const sortedCorr = allCorrelations.sort((a, b) => b.diff - a.diff);
                const top5Corr = sortedCorr.slice(0, 5);
                const bottom5Corr = sortedCorr.slice(-5).reverse();
                
                if (top5Corr.length > 0) {
                    html += `
                        <div class="summary-section">
                            <h3>üîó Top 5 Correlation Performers</h3>
                            ${generateCorrRankingTable(top5Corr, 1)}
                        </div>
                    `;
                }
                
                if (bottom5Corr.length > 0) {
                    html += `
                        <div class="summary-section">
                            <h3>üìä Bottom 5 Correlation Performers</h3>
                            ${generateCorrRankingTable(bottom5Corr, sortedCorr.length - 4)}
                        </div>
                    `;
                }
            }
            
            // Export buttons
            html += `
                <div class="export-section">
                    <button class="btn btn-primary" onclick="copyEmailReport()">
                        üìã Copy Email Report
                    </button>
                    <button class="btn btn-secondary" onclick="copyBloombergChat()">
                        üí¨ Copy Bloomberg Chat
                    </button>
                    <div id="exportStatusOverview" style="margin-left: 12px; font-size: 13px; color: var(--green);"></div>
                </div>
            `;
            
            return html;
        }

        function generateCorrRankingTable(correlations, startRank) {
            let html = '<table class="data-table"><thead><tr>';
            html += '<th class="sortable-header" onclick="sortTable(this, 0, \'number\')">Rank</th>';
            html += '<th class="sortable-header" onclick="sortTable(this, 1, \'string\')">Currency</th>';
            html += '<th class="sortable-header" onclick="sortTable(this, 2, \'string\')">Pair 1</th>';
            html += '<th class="sortable-header" onclick="sortTable(this, 3, \'string\')">Pair 2</th>';
            html += '<th class="sortable-header numeric-header" onclick="sortTable(this, 4, \'number\')">Impl Corr</th>';
            html += '<th class="sortable-header numeric-header" onclick="sortTable(this, 5, \'number\')">Real Corr</th>';
            html += '<th class="sortable-header numeric-header" onclick="sortTable(this, 6, \'number\')">Diff</th>';
            html += '</tr></thead><tbody>';
            
            correlations.forEach((corr, i) => {
                const diff = corr.diff;
                const diffColor = diff > 0 ? 'var(--green)' : diff < 0 ? 'var(--red)' : 'var(--text-secondary)';
                html += `<tr>
                    <td>${startRank + i}</td>
                    <td>${corr.currency}</td>
                    <td style="font-family: var(--font-mono);">${corr.pair1}</td>
                    <td style="font-family: var(--font-mono);">${corr.pair2}</td>
                    <td class="data-table-numbers">${Math.round((corr.impliedCorr || 0) * 100)}%</td>
                    <td class="data-table-numbers">${Math.round((corr.realizedCorr || 0) * 100)}%</td>
                    <td class="data-table-numbers" style="color: ${diffColor}; font-weight: 600;">
                        ${diff >= 0 ? '+' : ''}${Math.round(diff * 100)}%
                    </td>
                </tr>`;
            });
            
            html += '</tbody></table>';
            return html;
        }

        function generatePnLTab(pairResults) {
            let html = '<h2 style="margin-bottom: 24px;">P&L Analysis by Currency</h2>';

            // Calculate scales once for the entire tab - all tables share consistent coloring
            const scales = calculateTabScales(pairResults);

            // Block controls
            html += `
                <div class="block-controls">
                    <button class="btn btn-secondary" onclick="expandAllBlocks()">‚ñº Expand All</button>
                    <button class="btn btn-secondary" onclick="collapseAllBlocks()">‚ñ∂ Collapse All</button>
                </div>
            `;
            
            // Currency Groups
            const analyzedPairs = [...new Set(pairResults.map(([pair, _]) => pair))];
            const currencyBlocks = buildCurrencyBlocksFromResults(analyzedPairs, batchData.currencies || []);
            const sortedCurrencies = sortCurrencies(Object.keys(currencyBlocks));

            sortedCurrencies.forEach(currency => {
                const pairsInBlock = currencyBlocks[currency];
                const pairsWithResults = pairsInBlock
                    .map(pair => {
                        const result = pairResults.find(([p, _]) => p === pair);
                        return result ? [pair, result[1]] : null;
                    })
                    .filter(r => r !== null);

                if (pairsWithResults.length === 0) return;

                const groupAvg = pairsWithResults.reduce((sum, [_, result]) => sum + result.avgPnL, 0) / pairsWithResults.length;
                const currencyName = getCurrencyName(currency);

                html += `<div class="currency-group-section currency-block">`;
                html += `<div class="currency-header collapsible" onclick="toggleCurrencyBlock(this)">
                    <span class="collapse-icon">‚ñº</span>
                    <span class="currency-name">üí± ${currencyName} (${pairsWithResults.length} pairs)</span>
                </div>`;
                html += `<div class="currency-content">`;
                html += generateCurrencyGroupTable(pairsWithResults, scales);
                html += `<div class="summary-block" style="margin-top: 12px;"><strong>Group Average:</strong> <span style="font-family: var(--font-mono);">${formatThousand(groupAvg)}</span></div>`;
                html += `</div></div>`;
            });

            // Expandable Details
            html += '<h2 style="margin-top: 32px; margin-bottom: 24px;">Pair Details (Click to Expand)</h2>';
            pairResults.forEach(([pair, result]) => {
                const avgColor = getPnLColor(result.avgPnL * 1000, scales.avgPnLMaxAbs);
                html += `<div class="expandable-pair">`;
                html += `<div class="pair-header" onclick="togglePairDetails('${pair}')">`;
                html += `<span style="font-weight: bold; font-size: 16px;">‚ñ∂ ${pair}</span>`;
                html += `<span style="background-color: ${avgColor.bg}; color: ${avgColor.text}; padding: 5px 10px; border-radius: 4px; font-weight: bold;">Avg P&L: ${formatThousand(result.avgPnL)}</span>`;
                html += `</div>`;
                html += `<div class="pair-details" id="details-${pair}">`;

                // Strike P&L Summary Table
                html += '<h4>Strike P&L Summary:</h4>';
                html += '<table style="width: 100%; border-collapse: collapse;"><thead><tr><th></th>';
                ['10Œî Put', '25Œî Put', 'ATM Call', '25Œî Call', '10Œî Call'].forEach(strikeName => {
                    const strikePrice = result.strikes[strikeName].strikePrice;
                    html += `<th>${strikePrice.toFixed(4)}</th>`;
                });
                html += '</tr></thead><tbody><tr><td><strong>Strike</strong></td>';
                ['10Œî Put', '25Œî Put', 'ATM Call', '25Œî Call', '10Œî Call'].forEach(strikeName => {
                    html += `<td>${strikeName}</td>`;
                });
                html += '</tr><tr><td><strong>P&L (k)</strong></td>';
                ['10Œî Put', '25Œî Put', 'ATM Call', '25Œî Call', '10Œî Call'].forEach(strikeName => {
                    const pnl = result.strikes[strikeName].finalPnL;
                    const color = getPnLColor(pnl, scales.strikePnLMaxAbs);
                    html += `<td style="background-color: ${color.bg}; color: ${color.text}; font-weight: bold;">${formatThousand(pnl)}</td>`;
                });
                html += '</tr></tbody></table>';

                // Summary stats
                html += `<div class="info-box" style="margin-top: 15px;">`;
                html += `<strong>Summary:</strong> `;
                html += `Implied Vol: ${(result.impliedVol * 100).toFixed(2)}% | `;
                html += `Realized Vol: ${(result.realizedVol * 100).toFixed(2)}% | `;
                html += `Vol Diff: ${((result.realizedVol - result.impliedVol) * 100).toFixed(2)}%`;
                html += `</div>`;

                html += `</div></div>`;
            });

            return html;
        }

        function generateCorrelationTab(correlationResults) {
            let html = '<h2 style="margin-bottom: 24px;">Correlation Analysis by Currency</h2>';
            
            if (!correlationResults || Object.keys(correlationResults).length === 0) {
                html += '<div class="info-box"><p>No correlation data available. Enable correlation analysis in settings.</p></div>';
                return html;
            }
            
            html += generateCorrelationResults(correlationResults);
            
            return html;
        }

        function generateCorrelationMatrixTab(correlationMatrix) {
            let html = '<h2 style="margin-bottom: 24px;">Correlation Matrix via Intermediate Currencies</h2>';
            
            if (!correlationMatrix || Object.keys(correlationMatrix).length === 0) {
                html += '<div class="info-box"><p>No correlation matrix data available. Enable correlation analysis in settings.</p></div>';
                return html;
            }
            
            // Get currencies from window.batchData if available
            const currencies = window.batchData?.currencies || [];
            html += generateCorrelationMatrixDisplay(correlationMatrix, currencies);
            
            return html;
        }

        function generateChartsTab() {
            return `
                <h2 style="margin-bottom: 24px;">Charts & Visualizations</h2>
                <div class="charts-placeholder">
                    <p style="font-size: 48px; margin-bottom: 16px;">üìà</p>
                    <p>Interactive charts will be added in Phase 3</p>
                    <p style="color: var(--text-muted); margin-top: 8px;">
                        Planned: Vol comparison charts, P&L distribution, Correlation heatmaps
                    </p>
                </div>
            `;
        }

        // ============================================
        // BASKET DECOMPOSITION MODULE (Dynamic)
        // ============================================

        // Market convention order for pair naming
        const MARKET_ORDER = ['EUR', 'GBP', 'AUD', 'NZD', 'USD', 'CAD', 'CHF', 'JPY', 'SGD', 'HKD', 'NOK', 'SEK', 'DKK', 'ZAR', 'MXN', 'TRY', 'PLN', 'CZK', 'HUF', 'ILS', 'INR', 'KRW', 'TWD', 'THB', 'CNH', 'CNY', 'BRL'];

        // Store basket decomposition results globally
        window.basketDecompositionResults = null;
        window.detectedBasketCurrencies = [];
        window.detectedBasketPairs = [];

        function detectCurrenciesFromVols() {
            // Scan batchData.impliedVols to find all currencies present
            const impliedVols = batchData.impliedVols || {};
            const currencySet = new Set();

            Object.keys(impliedVols).forEach(pair => {
                if (pair.length === 6) {
                    currencySet.add(pair.slice(0, 3));
                    currencySet.add(pair.slice(3, 6));
                }
            });

            // Sort by market convention
            const currencies = Array.from(currencySet).sort((a, b) => {
                const idxA = MARKET_ORDER.indexOf(a);
                const idxB = MARKET_ORDER.indexOf(b);
                // Unknown currencies go to end
                const orderA = idxA === -1 ? 999 : idxA;
                const orderB = idxB === -1 ? 999 : idxB;
                return orderA - orderB;
            });

            return currencies;
        }

        function generateAllPairsForCurrencies(currencies) {
            // Generate all possible pairs for the given currencies
            const pairs = [];
            for (let i = 0; i < currencies.length; i++) {
                for (let j = i + 1; j < currencies.length; j++) {
                    const pair = getCanonicalPairName(currencies[i], currencies[j]);
                    pairs.push(pair);
                }
            }
            return pairs;
        }

        function getCanonicalPairName(ccy1, ccy2) {
            // Return pair name in market convention order
            const idx1 = MARKET_ORDER.indexOf(ccy1);
            const idx2 = MARKET_ORDER.indexOf(ccy2);
            const order1 = idx1 === -1 ? 999 : idx1;
            const order2 = idx2 === -1 ? 999 : idx2;

            if (order1 < order2) {
                return ccy1 + ccy2;
            } else {
                return ccy2 + ccy1;
            }
        }

        function findLargestCompleteBasket(allCurrencies) {
            // Find the largest subset of currencies where ALL pairs have data
            // This is essentially finding a maximum clique in a graph where:
            // - Nodes are currencies
            // - Edges exist if we have vol data for that pair

            if (allCurrencies.length <= 1) return allCurrencies;

            // Build adjacency: which currency pairs have data
            const hasData = {};
            allCurrencies.forEach(c1 => {
                hasData[c1] = {};
                allCurrencies.forEach(c2 => {
                    if (c1 !== c2) {
                        const pair = getCanonicalPairName(c1, c2);
                        hasData[c1][c2] = getVolForPair(pair) !== null;
                    }
                });
            });

            // Try subsets from largest to smallest
            // For N currencies, try all subsets of size N, then N-1, etc.
            for (let size = allCurrencies.length; size >= 2; size--) {
                const subsets = getCombinations(allCurrencies, size);

                for (const subset of subsets) {
                    if (isCompleteBasket(subset, hasData)) {
                        return subset;
                    }
                }
            }

            return []; // No valid basket found
        }

        function getCombinations(arr, size) {
            // Generate all combinations of 'size' elements from 'arr'
            if (size === 0) return [[]];
            if (arr.length === 0) return [];

            const result = [];

            function combine(start, current) {
                if (current.length === size) {
                    result.push([...current]);
                    return;
                }
                for (let i = start; i < arr.length; i++) {
                    current.push(arr[i]);
                    combine(i + 1, current);
                    current.pop();
                }
            }

            combine(0, []);
            return result;
        }

        function isCompleteBasket(currencies, hasData) {
            // Check if all pairs in this currency subset have data
            for (let i = 0; i < currencies.length; i++) {
                for (let j = i + 1; j < currencies.length; j++) {
                    if (!hasData[currencies[i]][currencies[j]]) {
                        return false;
                    }
                }
            }
            return true;
        }

        function generateBasketDecompositionTab() {
            // Detect currencies and find largest complete basket
            window.detectedBasketCurrencies = detectCurrenciesFromVols();
            window.validBasketCurrencies = findLargestCompleteBasket(window.detectedBasketCurrencies);

            return `
                <h2 style="margin-bottom: 24px;">üß∫ FX Currency Basket Decomposition</h2>

                <div class="card" style="margin-bottom: 24px;">
                    <h3 class="currency-header">About This Analysis</h3>
                    <p style="margin-bottom: 12px;">
                        This module decomposes FX pair volatilities into contributions from "universal basket" exposures.
                        It automatically detects currencies from your uploaded data and finds the <strong>largest complete basket</strong>
                        (the largest set of currencies where all pairwise vols are available).
                    </p>
                    <p style="color: var(--text-muted);">
                        The analysis constructs a covariance matrix from pair volatilities, then derives
                        basket volatilities and cross-currency correlations.
                    </p>
                </div>

                <div class="card" style="margin-bottom: 24px;">
                    <h3 class="currency-header">Input Status</h3>
                    <div id="basketInputStatus">
                        ${generateBasketInputStatus()}
                    </div>
                    <div style="margin-top: 16px;">
                        <button class="btn btn-primary" onclick="computeBasketDecomposition()" id="computeBasketBtn">
                            üî¨ Compute Decomposition
                        </button>
                    </div>
                </div>

                <div id="basketResults">
                    ${window.basketDecompositionResults ? generateBasketResultsHTML() : '<p style="color: var(--text-muted); text-align: center;">Click "Compute Decomposition" to run the analysis.</p>'}
                </div>
            `;
        }

        function generateBasketInputStatus() {
            const impliedVols = batchData.impliedVols || {};

            // Detect all currencies present in data
            const allCurrencies = detectCurrenciesFromVols();
            window.detectedBasketCurrencies = allCurrencies;

            // Find the largest complete basket
            const validBasket = findLargestCompleteBasket(allCurrencies);
            window.validBasketCurrencies = validBasket;

            const excludedCurrencies = allCurrencies.filter(c => !validBasket.includes(c));

            const requiredPairs = generateAllPairsForCurrencies(validBasket);
            const totalPairsInData = Object.keys(impliedVols).length;
            const basketPairCount = requiredPairs.length;

            const canCompute = validBasket.length >= 2;

            let html = `
                <div style="margin-bottom: 16px;">
                    <strong>Currencies in Data (${allCurrencies.length}):</strong>
                    <div style="margin-top: 8px; display: flex; flex-wrap: wrap; gap: 8px;">
                        ${allCurrencies.map(c => {
                            const isValid = validBasket.includes(c);
                            const style = isValid
                                ? 'background: rgba(34, 197, 94, 0.2); border: 1px solid var(--green);'
                                : 'background: rgba(234, 179, 8, 0.2); border: 1px solid var(--yellow); opacity: 0.7;';
                            return `<span style="${style} padding: 4px 12px; border-radius: 4px; font-family: var(--font-mono);">${c}${isValid ? '' : ' ‚ö†Ô∏è'}</span>`;
                        }).join('')}
                    </div>
                </div>

                <div style="display: flex; gap: 24px; margin-bottom: 16px;">
                    <div>
                        <span style="font-size: 32px; font-weight: bold; color: var(--green);">
                            ${validBasket.length}
                        </span>
                        <span style="color: var(--text-secondary);"> currencies in complete basket</span>
                    </div>
                    <div>
                        <span style="font-size: 32px; font-weight: bold;">${basketPairCount}</span>
                        <span style="color: var(--text-secondary);"> pairs for analysis</span>
                    </div>
                    <div>
                        <span style="font-size: 32px; font-weight: bold; color: var(--text-muted);">${totalPairsInData}</span>
                        <span style="color: var(--text-secondary);"> pairs uploaded</span>
                    </div>
                </div>
            `;

            if (validBasket.length < 2) {
                html += `
                    <div style="background: rgba(239, 68, 68, 0.1); border: 1px solid var(--red); border-radius: 8px; padding: 12px; margin-top: 12px;">
                        <strong style="color: var(--red);">‚ùå Cannot find a complete basket with at least 2 currencies.</strong>
                        <p style="margin-top: 8px; color: var(--text-secondary);">
                            A complete basket requires all pairwise volatilities between the included currencies.
                        </p>
                    </div>
                `;
            } else if (excludedCurrencies.length > 0) {
                html += `
                    <div style="background: rgba(34, 197, 94, 0.1); border: 1px solid var(--green); border-radius: 8px; padding: 12px; margin-top: 12px;">
                        <strong style="color: var(--green);">‚úÖ Found complete basket with ${validBasket.length} currencies - ready to compute!</strong>
                        <div style="margin-top: 8px; font-family: var(--font-mono);">
                            ${validBasket.join(', ')}
                        </div>
                    </div>
                    <div style="background: rgba(234, 179, 8, 0.1); border: 1px solid var(--yellow); border-radius: 8px; padding: 12px; margin-top: 12px;">
                        <strong style="color: var(--yellow);">‚ö†Ô∏è Excluded Currencies (${excludedCurrencies.length}):</strong>
                        <div style="margin-top: 8px; font-family: var(--font-mono); font-size: 13px;">
                            ${excludedCurrencies.join(', ')}
                        </div>
                        <p style="margin-top: 8px; color: var(--text-secondary); font-size: 13px;">
                            These currencies are missing one or more pair vols needed to form a complete basket.
                        </p>
                    </div>
                `;
            } else {
                html += `
                    <div style="background: rgba(34, 197, 94, 0.1); border: 1px solid var(--green); border-radius: 8px; padding: 12px; margin-top: 12px;">
                        <strong style="color: var(--green);">‚úÖ All ${basketPairCount} pairs available for ${validBasket.length} currencies - ready to compute!</strong>
                    </div>
                `;
            }

            return html;
        }

        function getVolForPair(pair) {
            const impliedVols = batchData.impliedVols || {};
            const inversePair = pair.slice(3, 6) + pair.slice(0, 3);

            if (impliedVols[pair] !== undefined) {
                return impliedVols[pair];
            } else if (impliedVols[inversePair] !== undefined) {
                return impliedVols[inversePair];
            }
            return null;
        }

        function computeBasketDecomposition() {
            // Use the pre-computed valid basket (largest complete subset)
            const currencies = window.validBasketCurrencies || findLargestCompleteBasket(detectCurrenciesFromVols());

            if (currencies.length < 2) {
                alert('Cannot find a complete basket with at least 2 currencies.\nA complete basket requires all pairwise volatilities between the included currencies.');
                return;
            }

            try {
                // Step 1: Build the NxN covariance matrix
                const covMatrix = buildCovarianceMatrixDynamic(currencies);

                // Step 2: Calculate basket volatilities for each currency
                const basketVols = calculateBasketVolatilitiesDynamic(currencies, covMatrix);

                // Step 3: Calculate pair decomposition percentages
                const pairDecompositions = calculatePairDecompositionsDynamic(currencies, basketVols);

                // Step 4: Calculate NxN basket correlation matrix
                const basketCorrelations = calculateBasketCorrelationMatrixDynamic(currencies, covMatrix, basketVols);

                // Store results
                window.basketDecompositionResults = {
                    currencies,
                    covMatrix,
                    basketVols,
                    pairDecompositions,
                    basketCorrelations,
                    timestamp: new Date().toISOString()
                };

                // Update the results div
                document.getElementById('basketResults').innerHTML = generateBasketResultsHTML();

            } catch (error) {
                console.error('Basket decomposition error:', error);
                alert('Error computing basket decomposition: ' + error.message);
            }
        }

        function buildCovarianceMatrixDynamic(currencies) {
            // Build NxN covariance matrix for all currencies
            // Using the relationship: For any pair AB, œÉ¬≤(AB) gives us information
            // We'll use direct pair volatilities to build the covariance structure

            const n = currencies.length;
            const cov = Array(n).fill(null).map(() => Array(n).fill(0));

            // For each pair of currencies, get the pair volatility
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    if (i === j) {
                        // Diagonal: we need a "reference" volatility for this currency
                        // Use average of all pairs involving this currency
                        let sumVar = 0;
                        let count = 0;
                        for (let k = 0; k < n; k++) {
                            if (k !== i) {
                                const pair = getCanonicalPairName(currencies[i], currencies[k]);
                                const vol = getVolForPair(pair);
                                if (vol !== null) {
                                    sumVar += vol * vol;
                                    count++;
                                }
                            }
                        }
                        cov[i][i] = count > 0 ? sumVar / count : 0;
                    } else if (j > i) {
                        // Off-diagonal: derive covariance from triangle relationship
                        // For currencies i, j: Cov(i,j) can be derived if we have a third currency k
                        // œÉ¬≤(ij) = Var(i) + Var(j) - 2*Cov(i,j)
                        // Cov(i,j) = (Var(i) + Var(j) - œÉ¬≤(ij)) / 2

                        const pair = getCanonicalPairName(currencies[i], currencies[j]);
                        const pairVol = getVolForPair(pair);

                        if (pairVol !== null) {
                            const varI = cov[i][i];
                            const varJ = cov[j][j];
                            const pairVar = pairVol * pairVol;

                            // Covariance from the variance relationship
                            const covariance = (varI + varJ - pairVar) / 2;
                            cov[i][j] = covariance;
                            cov[j][i] = covariance;
                        }
                    }
                }
            }

            return cov;
        }

        function getUsdSign(currency) {
            // Returns +1 if the standard pair is CCY/USD (CCY goes up when pair goes up)
            // Returns -1 if the standard pair is USD/CCY (CCY goes down when pair goes up)
            const positiveConvention = ['EUR', 'GBP', 'AUD', 'NZD'];
            return positiveConvention.includes(currency) ? 1 : -1;
        }

        function calculateBasketVolatilitiesDynamic(currencies, covMatrix) {
            // For each currency, calculate its "basket volatility"
            // This represents the volatility of a portfolio that is long 1 unit of that currency
            // against an equal-weighted basket of all other currencies

            const basketVols = {};
            const n = currencies.length;

            currencies.forEach((ccy, i) => {
                // Basket variance for currency i:
                // Var(basket_i) = (1/(n-1)) * Œ£_j Var(i/j) where j ‚â† i

                let sumVar = 0;
                let count = 0;

                currencies.forEach((ccy2, j) => {
                    if (i === j) return;

                    const pair = getCanonicalPairName(ccy, ccy2);
                    const pairVol = getVolForPair(pair);
                    if (pairVol !== null) {
                        sumVar += pairVol * pairVol;
                        count++;
                    }
                });

                // Average over all pairs
                const basketVar = count > 0 ? sumVar / count : 0;
                basketVols[ccy] = Math.sqrt(basketVar);
            });

            return basketVols;
        }

        function calculatePairDecompositionsDynamic(currencies, basketVols) {
            // For each pair, calculate what percentage of variance comes from each currency
            const decompositions = {};
            const allPairs = generateAllPairsForCurrencies(currencies);

            allPairs.forEach(pair => {
                const ccy1 = pair.slice(0, 3);
                const ccy2 = pair.slice(3, 6);
                const pairVol = getVolForPair(pair);

                if (pairVol === null) return;
                if (!basketVols[ccy1] || !basketVols[ccy2]) return;

                const pairVar = pairVol * pairVol;
                const basketVar1 = basketVols[ccy1] * basketVols[ccy1];
                const basketVar2 = basketVols[ccy2] * basketVols[ccy2];

                // Simple decomposition: proportion of basket variance
                const totalBasketVar = basketVar1 + basketVar2;

                if (totalBasketVar > 0) {
                    decompositions[pair] = {
                        ccy1: ccy1,
                        ccy2: ccy2,
                        pct1: (basketVar1 / totalBasketVar) * 100,
                        pct2: (basketVar2 / totalBasketVar) * 100,
                        pairVol: pairVol * 100, // Convert to percentage
                        basketVol1: basketVols[ccy1] * 100,
                        basketVol2: basketVols[ccy2] * 100
                    };
                }
            });

            return decompositions;
        }

        function calculateBasketCorrelationMatrixDynamic(currencies, covMatrix, basketVols) {
            // Calculate NxN correlation matrix between basket exposures
            const correlations = {};
            const n = currencies.length;

            // Initialize correlation matrix
            currencies.forEach(ccy1 => {
                correlations[ccy1] = {};
                currencies.forEach(ccy2 => {
                    if (ccy1 === ccy2) {
                        correlations[ccy1][ccy2] = 1.0;
                    } else {
                        correlations[ccy1][ccy2] = 0;
                    }
                });
            });

            // For each pair of currencies, calculate implied correlation
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    const ccy1 = currencies[i];
                    const ccy2 = currencies[j];

                    const vol1 = basketVols[ccy1];
                    const vol2 = basketVols[ccy2];

                    if (vol1 > 0 && vol2 > 0) {
                        // Get the direct pair volatility
                        const pair = getCanonicalPairName(ccy1, ccy2);
                        const pairVol = getVolForPair(pair);

                        if (pairVol !== null) {
                            // Implied correlation: œÅ = (œÉ1¬≤ + œÉ2¬≤ - œÉpair¬≤) / (2 * œÉ1 * œÉ2)
                            let rho = (vol1 * vol1 + vol2 * vol2 - pairVol * pairVol) / (2 * vol1 * vol2);

                            // Clamp to valid correlation range
                            rho = Math.max(-1, Math.min(1, rho));

                            correlations[ccy1][ccy2] = rho;
                            correlations[ccy2][ccy1] = rho;
                        }
                    }
                }
            }

            return correlations;
        }

        function getBasisPair(ccy) {
            // Get the USD basis pair for a currency
            if (ccy === 'USD') return null;

            const positiveConvention = ['EUR', 'GBP', 'AUD', 'NZD'];
            if (positiveConvention.includes(ccy)) {
                return ccy + 'USD';
            } else {
                return 'USD' + ccy;
            }
        }

        function generateBasketResultsHTML() {
            const results = window.basketDecompositionResults;
            if (!results) return '';

            const currencies = results.currencies || window.detectedBasketCurrencies || [];
            const n = currencies.length;

            let html = '';

            // Table 1: Basket Volatilities
            html += `
                <div class="card" style="margin-bottom: 24px;">
                    <h3 class="currency-header">üìä Basket Volatilities (${n} currencies)</h3>
                    <p style="margin-bottom: 16px; color: var(--text-secondary);">
                        Annualized volatility of each currency's "basket" exposure against all others.
                    </p>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Currency</th>
                                <th>Basket Vol (%)</th>
                                <th>Relative Rank</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            // Sort currencies by basket vol
            const sortedCurrencies = currencies.slice().sort((a, b) =>
                (results.basketVols[b] || 0) - (results.basketVols[a] || 0)
            );

            sortedCurrencies.forEach((ccy, rank) => {
                const vol = (results.basketVols[ccy] || 0) * 100;
                const volColor = vol > 10 ? 'var(--red)' : vol > 7 ? 'var(--yellow)' : 'var(--green)';
                html += `
                    <tr>
                        <td><strong>${ccy}</strong></td>
                        <td style="color: ${volColor}; font-weight: bold;">${vol.toFixed(2)}%</td>
                        <td>#${rank + 1}</td>
                    </tr>
                `;
            });

            html += `
                        </tbody>
                    </table>
                </div>
            `;

            // Table 2: Pair Decompositions - Grouped by Currency
            html += `
                <div class="card" style="margin-bottom: 24px;">
                    <h3 class="currency-header">üîÄ Pair Decomposition by Currency</h3>
                    <p style="margin-bottom: 16px; color: var(--text-secondary);">
                        Percentage of pair variance attributable to each constituent currency's basket exposure.
                        Pairs are grouped by currency, with the group currency always shown on the left.
                    </p>
            `;

            // Group pairs by each currency
            currencies.forEach(groupCcy => {
                // Find all pairs involving this currency
                const pairsForCurrency = [];

                Object.entries(results.pairDecompositions).forEach(([pair, decomp]) => {
                    if (decomp.ccy1 === groupCcy || decomp.ccy2 === groupCcy) {
                        // Determine if we need to swap the presentation
                        const needsSwap = decomp.ccy2 === groupCcy;

                        pairsForCurrency.push({
                            displayPair: needsSwap ? (groupCcy + decomp.ccy1) : pair,
                            pairVol: decomp.pairVol,
                            leftCcy: groupCcy,
                            rightCcy: needsSwap ? decomp.ccy1 : decomp.ccy2,
                            leftPct: needsSwap ? decomp.pct2 : decomp.pct1,
                            rightPct: needsSwap ? decomp.pct1 : decomp.pct2,
                            leftBasketVol: needsSwap ? decomp.basketVol2 : decomp.basketVol1,
                            rightBasketVol: needsSwap ? decomp.basketVol1 : decomp.basketVol2
                        });
                    }
                });

                // Sort by pair vol descending
                pairsForCurrency.sort((a, b) => b.pairVol - a.pairVol);

                // Calculate group average basket contribution
                const avgContribution = pairsForCurrency.length > 0
                    ? pairsForCurrency.reduce((sum, p) => sum + p.leftPct, 0) / pairsForCurrency.length
                    : 0;

                const currencyName = getCurrencyName(groupCcy);

                html += `
                    <div class="currency-group-section" style="margin-bottom: 24px;">
                        <h4 class="currency-header" style="border-left: 3px solid var(--cyan);">
                            üí± ${currencyName} (${pairsForCurrency.length} pairs)
                            <span style="font-weight: normal; font-size: 13px; color: var(--text-secondary); margin-left: 12px;">
                                Avg ${groupCcy} contribution: ${avgContribution.toFixed(1)}%
                            </span>
                        </h4>
                        <table class="data-table">
                            <thead>
                                <tr>
                                    <th>Pair</th>
                                    <th>Pair Vol</th>
                                    <th>${groupCcy} %</th>
                                    <th>Counter CCY</th>
                                    <th>Counter %</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                pairsForCurrency.forEach(p => {
                    const bar1Width = Math.min(p.leftPct, 100).toFixed(0);
                    const bar2Width = Math.min(p.rightPct, 100).toFixed(0);

                    html += `
                        <tr>
                            <td><strong>${p.displayPair}</strong></td>
                            <td>${p.pairVol.toFixed(2)}%</td>
                            <td>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <div style="background: var(--cyan); width: ${bar1Width}px; height: 16px; border-radius: 2px;"></div>
                                    <span>${p.leftPct.toFixed(1)}%</span>
                                </div>
                            </td>
                            <td>${p.rightCcy}</td>
                            <td>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <div style="background: var(--yellow); width: ${bar2Width}px; height: 16px; border-radius: 2px;"></div>
                                    <span>${p.rightPct.toFixed(1)}%</span>
                                </div>
                            </td>
                        </tr>
                    `;
                });

                html += `
                            </tbody>
                        </table>
                    </div>
                `;
            });

            html += `</div>`;

            // Table 3: NxN Correlation Matrix
            html += `
                <div class="card" style="margin-bottom: 24px;">
                    <h3 class="currency-header">üîó ${n}√ó${n} Basket Correlation Matrix</h3>
                    <p style="margin-bottom: 16px; color: var(--text-secondary);">
                        Implied correlations between currency basket exposures.
                    </p>
                    <div style="overflow-x: auto;">
                        <table class="data-table correlation-matrix">
                            <thead>
                                <tr>
                                    <th></th>
                                    ${currencies.map(c => `<th>${c}</th>`).join('')}
                                </tr>
                            </thead>
                            <tbody>
            `;

            currencies.forEach(ccy1 => {
                html += `<tr><td><strong>${ccy1}</strong></td>`;
                currencies.forEach(ccy2 => {
                    const corr = (results.basketCorrelations[ccy1] && results.basketCorrelations[ccy1][ccy2]) || 0;
                    const color = getCorrelationColor(corr);
                    html += `<td style="background-color: ${color}; text-align: center;">${corr.toFixed(2)}</td>`;
                });
                html += '</tr>';
            });

            html += `
                            </tbody>
                        </table>
                    </div>
                </div>
            `;

            // Timestamp
            html += `
                <p style="text-align: center; color: var(--text-muted); font-size: 12px;">
                    Computed at: ${new Date(results.timestamp).toLocaleString()}
                </p>
            `;

            return html;
        }

        function getCorrelationColor(corr) {
            // Blue for negative, red for positive, white for zero
            if (Math.abs(corr) < 0.01) return 'transparent';

            const intensity = Math.abs(corr);
            const alpha = 0.1 + intensity * 0.6;

            if (corr > 0) {
                return `rgba(34, 197, 94, ${alpha})`; // Green for positive
            } else {
                return `rgba(239, 68, 68, ${alpha})`; // Red for negative
            }
        }

        function generatePnLResults(pairResults) {
            let html = '';

            // Calculate scales once for consistent coloring across all tables in this view
            const scales = calculateTabScales(pairResults);

            // Top 5 / Bottom 5 Rankings
            const top5 = pairResults.slice(0, 5);
            const bottom5 = pairResults.slice(-5).reverse();
            const bottom5StartRank = Math.max(1, pairResults.length - bottom5.length + 1);

            html += `
            <div class="card">
                <h3 class="currency-header" style="text-align: center;">üèÜ TOP 5 PERFORMERS</h3>
                ${generateRankingTable(top5, 1, scales)}
            </div>

            <div class="card">
                <h3 class="currency-header" style="text-align: center; border-left: 3px solid var(--red);">üìâ BOTTOM 5 PERFORMERS</h3>
                ${generateRankingTable(bottom5, bottom5StartRank, scales)}
            </div>`;

            // Currency Groups
            const analyzedPairs = [...new Set(pairResults.map(([pair, _]) => pair))]; // Remove duplicates
            const currencyBlocks = buildCurrencyBlocksFromResults(analyzedPairs, batchData.currencies || []);
            // Sort currencies by order (G10 first, then EM)
            const sortedCurrencies = sortCurrencies(Object.keys(currencyBlocks));

            // Debug logging
            console.log('=== P&L BLOCK DEBUG ===');
            console.log('Sorted currencies for P&L:', sortedCurrencies);
            console.log('USD in list?', sortedCurrencies.includes('USD'));
            console.log('USD group:', currencyBlocks['USD']);

            html += '<div id="currencyGroupsContent">';
            sortedCurrencies.forEach(currency => {
                const pairsInBlock = currencyBlocks[currency];
                const pairsWithResults = pairsInBlock
                    .map(pair => {
                        const result = pairResults.find(([p, _]) => p === pair);
                        return result ? [pair, result[1]] : null;
                    })
                    .filter(r => r !== null);

                // Show block even if only 1 pair (P&L doesn't need minimum like correlations)
                if (pairsWithResults.length === 0) return;

                const groupAvg = pairsWithResults.reduce((sum, [_, result]) => sum + result.avgPnL, 0) / pairsWithResults.length;
                const currencyName = getCurrencyName(currency);

                html += `<div class="currency-group-section">`;
                html += `<h3 class="currency-header">üí± ${currencyName} (${pairsWithResults.length} pairs)</h3>`;
                html += generateCurrencyGroupTable(pairsWithResults, scales);
                html += `<div class="summary-block" style="margin-top: 12px;"><strong>Group Average:</strong> <span style="font-family: var(--font-mono);">${formatThousand(groupAvg)}</span></div>`;
                html += `</div>`;
            });
            html += '</div>';

            // Expandable Details
            html += '<div id="expandableDetailsContent">';
            pairResults.forEach(([pair, result]) => {
                const avgColor = getPnLColor(result.avgPnL * 1000, scales.avgPnLMaxAbs);
                html += `<div class="expandable-pair">`;
                html += `<div class="pair-header" onclick="togglePairDetails('${pair}')">`;
                html += `<span style="font-weight: bold; font-size: 16px;">‚ñ∂ ${pair}</span>`;
                html += `<span style="background-color: ${avgColor.bg}; color: ${avgColor.text}; padding: 5px 10px; border-radius: 4px; font-weight: bold;">Avg P&L: ${formatThousand(result.avgPnL)}</span>`;
                html += `</div>`;
                html += `<div class="pair-details" id="details-${pair}">`;

                // Strike P&L Summary Table
                html += '<h4>Strike P&L Summary:</h4>';
                html += '<table style="width: 100%; border-collapse: collapse;"><thead><tr><th></th>';
                ['10Œî Put', '25Œî Put', 'ATM Call', '25Œî Call', '10Œî Call'].forEach(strikeName => {
                    const strikePrice = result.strikes[strikeName].strikePrice;
                    html += `<th>${strikePrice.toFixed(4)}</th>`;
                });
                html += '</tr></thead><tbody><tr><td><strong>Strike</strong></td>';
                ['10Œî Put', '25Œî Put', 'ATM Call', '25Œî Call', '10Œî Call'].forEach(strikeName => {
                    html += `<td>${strikeName}</td>`;
                });
                html += '</tr><tr><td><strong>P&L (k)</strong></td>';
                ['10Œî Put', '25Œî Put', 'ATM Call', '25Œî Call', '10Œî Call'].forEach(strikeName => {
                    const pnl = result.strikes[strikeName].finalPnL;
                    const color = getPnLColor(pnl, scales.strikePnLMaxAbs);
                    html += `<td style="background-color: ${color.bg}; color: ${color.text}; font-weight: bold;">${formatThousand(pnl)}</td>`;
                });
                html += '</tr></tbody></table>';

                // Summary stats
                html += `<div style="margin-top: 15px; padding: 10px; background-color: #f9f9f9; border-radius: 4px;">`;
                html += `<strong>Summary:</strong> `;
                html += `Avg P&L: ${formatThousand(result.avgPnL)} | `;
                html += `Impl Vol: ${(result.impliedVol * 100).toFixed(2)}% | `;
                html += `Real Vol: ${(result.realizedVol * 100).toFixed(2)}% | `;
                html += `Vol Diff: ${result.volDiff >= 0 ? '+' : ''}${(result.volDiff * 100).toFixed(2)}%`;
                html += `</div>`;

                // View Charts button
                html += `<button style="margin-top: 15px;" onclick="showBatchPairCharts('${pair}')">View P&L Charts</button>`;

                html += `</div>`;
                html += `</div>`;
            });
            html += '</div>';

            return html;
        }

        function generateCorrelationResults(correlationResults) {
            if (!correlationResults || Object.keys(correlationResults).length === 0) {
                return `
                <div class="alert alert-warning">
                    <strong>No correlation data available.</strong>
                    <p>Correlation analysis requires at least 2 pairs per currency group and cross pair volatilities.</p>
                </div>`;
            }

            let html = '';

            // Top 5 / Bottom 5
            html += generateTopBottomCorrelations(correlationResults);

            // Block controls
            html += `
                <div class="block-controls" style="margin-top: 24px;">
                    <button class="btn btn-secondary" onclick="expandAllBlocks()">‚ñº Expand All</button>
                    <button class="btn btn-secondary" onclick="collapseAllBlocks()">‚ñ∂ Collapse All</button>
                </div>
            `;

            // Individual currency group tables
            // Use restructured correlations with nesting
            const restructured = restructureCorrelations(correlationResults);
            
            Object.entries(restructured).forEach(([mainCurrency, data]) => {
                html += `
            <div class="currency-correlation-block currency-block" style="margin-bottom: 32px; padding: 0;">
                <div class="currency-header collapsible" onclick="toggleCurrencyBlock(this)" style="font-size: 16px; margin-bottom: 0;">
                    <span class="collapse-icon">‚ñº</span>
                    <span class="currency-name">üîó ${mainCurrency} CORRELATIONS (${data.allCorrelations.length} total)</span>
                </div>
                <div class="currency-content" style="padding-top: 16px;">`;

                // Nested groups - with collapsible sub-groups
                Object.entries(data.nestedGroups).forEach(([secondaryCurrency, correlations]) => {
                    const corrArray = Array.isArray(correlations) ? correlations : [];
                    const mainPair = constructMainPair(mainCurrency, secondaryCurrency);
                    
                    // Normalize correlations to ensure mainPair is always Pair 1
                    const normalizedCorrs = corrArray.map(corr => normalizeCorrelationForDisplay(corr, mainPair));
                    
                    html += `
                <div class="nested-correlation-group" style="margin: 12px 0; padding: 0;">
                    <div class="collapsible" onclick="toggleCurrencyBlock(this)" style="font-size: 14px; padding: 8px 12px; background: var(--bg-elevated); border-radius: 4px; margin-bottom: 0;">
                        <span class="collapse-icon">‚ñº</span>
                        <span class="currency-name">${mainCurrency}-${secondaryCurrency} Correlations (${corrArray.length})</span>
                    </div>
                    <div class="currency-content" style="padding-top: 8px;">`;
                    
                    // Use existing generateCurrencyCorrelationTable but with normalized correlations
                    const tempGroupData = { 
                        correlations: normalizedCorrs,
                        avgImpliedCorr: corrArray.length > 0 ? corrArray.reduce((sum, c) => sum + c.impliedCorr, 0) / corrArray.length : 0,
                        avgRealizedCorr: corrArray.length > 0 ? corrArray.reduce((sum, c) => sum + c.realizedCorr, 0) / corrArray.length : 0,
                        avgDifference: corrArray.length > 0 ? corrArray.reduce((sum, c) => sum + c.difference, 0) / corrArray.length : 0,
                        count: corrArray.length
                    };
                    html += generateCurrencyCorrelationTable(`${mainCurrency}-${secondaryCurrency}`, tempGroupData);
                    html += `</div></div>`;
                });

                // Overall block summary
                const uniqueCorrelations = data.allCorrelations;
                const overallAvgImpl = uniqueCorrelations.reduce((sum, c) => sum + c.impliedCorr, 0) / uniqueCorrelations.length;
                const overallAvgReal = uniqueCorrelations.reduce((sum, c) => sum + c.realizedCorr, 0) / uniqueCorrelations.length;
                const overallAvgDiff = uniqueCorrelations.reduce((sum, c) => sum + c.difference, 0) / uniqueCorrelations.length;

                html += `
                <div class="overall-summary" style="margin-top: 20px; padding: 12px 16px; background: var(--bg-elevated); border-left: 3px solid var(--cyan); border-radius: 4px;">
                    <div style="font-weight: 600; font-size: 14px; color: var(--cyan); margin-bottom: 12px;">
                        ${mainCurrency} OVERALL AVERAGE (${uniqueCorrelations.length} unique correlations)
                    </div>
                    <div class="summary-bar" style="display: flex; gap: 16px; justify-content: space-around;">
                        <div class="summary-item">
                            <div class="summary-label">Avg Impl Corr</div>
                            <div class="summary-value">${formatCorrelation(overallAvgImpl)}</div>
                        </div>
                        <div class="summary-item">
                            <div class="summary-label">Avg Real Corr</div>
                            <div class="summary-value">${formatCorrelation(overallAvgReal)}</div>
                        </div>
                        <div class="summary-item">
                            <div class="summary-label">Avg Difference</div>
                            <div class="summary-value ${overallAvgDiff >= 0 ? 'pnl-positive' : 'pnl-negative'}">${formatCorrelationDiff(overallAvgDiff)}</div>
                        </div>
                    </div>
                </div>
                </div>
            </div>`;
            });

            return html;
        }

        function generateTopBottomCorrelations(correlationResults) {
            // Flatten all correlations
            const allCorrelations = [];

            Object.keys(correlationResults).forEach(currency => {
                correlationResults[currency].correlations.forEach(corr => {
                    allCorrelations.push({
                        ...corr,
                        currency: currency
                    });
                });
            });

            // Sort by difference (descending)
            allCorrelations.sort((a, b) => b.difference - a.difference);

            const top5 = allCorrelations.slice(0, 5);
            const bottom5 = allCorrelations.slice(-5).reverse();

            let html = `
            <div class="card">
                <div class="section-header">
                    <h2>üèÜ TOP 5 CORRELATION PERFORMERS (Largest Positive Difference)</h2>
                </div>
                <table class="data-table">
                    <thead>
                        <tr>
                            <th class="sortable-header" onclick="sortTable(this, 0, 'number')">Rank</th>
                            <th class="sortable-header" onclick="sortTable(this, 1, 'string')">Currency</th>
                            <th class="sortable-header" onclick="sortTable(this, 2, 'string')">Pair 1</th>
                            <th class="sortable-header" onclick="sortTable(this, 3, 'string')">Pair 2</th>
                            <th class="sortable-header numeric-header" onclick="sortTable(this, 4, 'number')">Impl Corr</th>
                            <th class="sortable-header numeric-header" onclick="sortTable(this, 5, 'number')">Real Corr</th>
                            <th class="sortable-header numeric-header" onclick="sortTable(this, 6, 'number')">Difference</th>
                        </tr>
                    </thead>
                    <tbody>`;

            top5.forEach((corr, idx) => {
                html += `
                    <tr>
                        <td>${idx + 1}</td>
                        <td><strong>${corr.currency}</strong></td>
                        <td>${corr.pair1}</td>
                        <td>${corr.pair2}</td>
                        <td class="data-table-numbers">${formatCorrelation(corr.impliedCorr)}</td>
                        <td class="data-table-numbers">${formatCorrelation(corr.realizedCorr)}</td>
                        <td class="data-table-numbers ${corr.difference >= 0 ? 'pnl-positive' : 'pnl-negative'}">
                            ${formatCorrelationDiff(corr.difference)}
                        </td>
                    </tr>`;
            });

            html += `
                    </tbody>
                </table>
            </div>

            <div class="card">
                <div class="section-header">
                    <h2>üìâ BOTTOM 5 CORRELATION PERFORMERS (Smallest/Most Negative Difference)</h2>
                </div>
                <table class="data-table">
                    <thead>
                        <tr>
                            <th class="sortable-header" onclick="sortTable(this, 0, 'number')">Rank</th>
                            <th class="sortable-header" onclick="sortTable(this, 1, 'string')">Currency</th>
                            <th class="sortable-header" onclick="sortTable(this, 2, 'string')">Pair 1</th>
                            <th class="sortable-header" onclick="sortTable(this, 3, 'string')">Pair 2</th>
                            <th class="sortable-header numeric-header" onclick="sortTable(this, 4, 'number')">Impl Corr</th>
                            <th class="sortable-header numeric-header" onclick="sortTable(this, 5, 'number')">Real Corr</th>
                            <th class="sortable-header numeric-header" onclick="sortTable(this, 6, 'number')">Difference</th>
                        </tr>
                    </thead>
                    <tbody>`;

            const startRank = Math.max(1, allCorrelations.length - 4); // Rank from bottom

            bottom5.forEach((corr, idx) => {
                html += `
                    <tr>
                        <td>${startRank + idx}</td>
                        <td><strong>${corr.currency}</strong></td>
                        <td>${corr.pair1}</td>
                        <td>${corr.pair2}</td>
                        <td class="data-table-numbers">${formatCorrelation(corr.impliedCorr)}</td>
                        <td class="data-table-numbers">${formatCorrelation(corr.realizedCorr)}</td>
                        <td class="data-table-numbers ${corr.difference >= 0 ? 'pnl-positive' : 'pnl-negative'}">
                            ${formatCorrelationDiff(corr.difference)}
                        </td>
                    </tr>`;
            });

            html += `
                    </tbody>
                </table>
            </div>`;

            return html;
        }

        function generateCurrencyCorrelationTable(currency, groupData) {
            const currencyName = getCurrencyName(currency);
            const correlations = [...groupData.correlations]; // Copy to avoid mutating original

            // Sort by difference descending
            correlations.sort((a, b) => b.difference - a.difference);

            let html = `
            <div class="card">
                <div class="section-header">
                    <h2>üí± ${currencyName} Correlations</h2>
                </div>
                <table class="data-table">
                    <thead>
                        <tr>
                            <th class="sortable-header" onclick="sortTable(this, 0, 'string')">Pair 1</th>
                            <th class="sortable-header" onclick="sortTable(this, 1, 'string')">Pair 2</th>
                            <th class="sortable-header numeric-header" onclick="sortTable(this, 2, 'number')">Impl Corr</th>
                            <th class="sortable-header numeric-header" onclick="sortTable(this, 3, 'number')">Real Corr</th>
                            <th class="sortable-header numeric-header" onclick="sortTable(this, 4, 'number')">Difference</th>
                        </tr>
                    </thead>
                    <tbody>`;

            correlations.forEach(corr => {
                html += `
                    <tr>
                        <td>${corr.pair1}</td>
                        <td>${corr.pair2}</td>
                        <td class="data-table-numbers">${formatCorrelation(corr.impliedCorr)}</td>
                        <td class="data-table-numbers">${formatCorrelation(corr.realizedCorr)}</td>
                        <td class="data-table-numbers ${corr.difference >= 0 ? 'pnl-positive' : 'pnl-negative'}">
                            ${formatCorrelationDiff(corr.difference)}
                        </td>
                    </tr>`;
            });

            html += `
                    </tbody>
                </table>

                <div class="summary-bar" style="margin-top: 20px;">
                    <div class="summary-item">
                        <div class="summary-label">Avg Impl Corr</div>
                        <div class="summary-value">${formatCorrelation(groupData.avgImpliedCorr)}</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-label">Avg Real Corr</div>
                        <div class="summary-value">${formatCorrelation(groupData.avgRealizedCorr)}</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-label">Avg Difference</div>
                        <div class="summary-value ${groupData.avgDifference >= 0 ? 'positive' : 'negative'}">
                            ${formatCorrelationDiff(groupData.avgDifference)}
                        </div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-label">Correlations</div>
                        <div class="summary-value">${groupData.count}</div>
                    </div>
                </div>
            </div>`;

            return html;
        }

        function displayRankings(pairResults) {
            const top5 = pairResults.slice(0, 5);
            const bottom5 = pairResults.slice(-5).reverse();

            // Calculate correct start rank for bottom 5
            // If there are 33 pairs, bottom 5 should start at rank 29 (33 - 5 + 1)
            // If there are 3 pairs, bottom 5 should start at rank 1 (not -1)
            const bottom5StartRank = Math.max(1, pairResults.length - bottom5.length + 1);

            // Calculate scales once using ALL pairs for consistent coloring across both tables
            const scales = calculateTabScales(pairResults);

            document.getElementById('top5Table').innerHTML = generateRankingTable(top5, 1, scales);
            document.getElementById('bottom5Table').innerHTML = generateRankingTable(bottom5, bottom5StartRank, scales);
        }

        function generateRankingTable(pairs, startRank, scales) {
            // scales: { strikePnLMaxAbs, avgPnLMaxAbs } - pre-calculated at tab level for consistent coloring

            let html = '<div class="card" style="overflow-x: auto;"><table class="data-table" style="min-width: 900px; font-size: 13px;"><thead><tr>';
            html += '<th class="sortable-header" onclick="sortTable(this, 0, \'number\')">Rank</th>';
            html += '<th class="sortable-header" onclick="sortTable(this, 1, \'string\')">Pair</th>';
            html += '<th class="sortable-header numeric-header" onclick="sortTable(this, 2, \'number\')">Avg P&L</th>';
            html += '<th class="sortable-header numeric-header" onclick="sortTable(this, 3, \'number\')">10Œî Put</th>';
            html += '<th class="sortable-header numeric-header" onclick="sortTable(this, 4, \'number\')">25Œî Put</th>';
            html += '<th class="sortable-header numeric-header" onclick="sortTable(this, 5, \'number\')">ATM Call</th>';
            html += '<th class="sortable-header numeric-header" onclick="sortTable(this, 6, \'number\')">25Œî Call</th>';
            html += '<th class="sortable-header numeric-header" onclick="sortTable(this, 7, \'number\')">10Œî Call</th>';
            // Separator between P&L and Vol columns
            html += '<th class="sortable-header numeric-header" onclick="sortTable(this, 8, \'number\')" style="border-left: 2px solid var(--border-strong);">Impl Vol</th>';
            html += '<th class="sortable-header numeric-header" onclick="sortTable(this, 9, \'number\')">Real Vol</th>';
            html += '<th class="sortable-header numeric-header" onclick="sortTable(this, 10, \'number\')">Vol Diff</th>';
            html += '</tr></thead><tbody>';

            // Strike type mapping for data attributes
            const strikeTypeMap = {
                '10Œî Put': 'put10Delta',
                '25Œî Put': 'put25Delta',
                'ATM Call': 'atmCall',
                '25Œî Call': 'call25Delta',
                '10Œî Call': 'call10Delta'
            };

            pairs.forEach(([pair, result], idx) => {
                const rank = startRank + idx;
                const avgColor = getPnLColor(result.avgPnL * 1000, scales?.avgPnLMaxAbs);

                html += '<tr>';
                html += `<td>${rank}</td>`;
                html += `<td style="font-weight: bold;">${pair}</td>`;
                html += `<td style="text-align: center; width: 110px;">
                    <span class="chart-cell" style="display: inline-block; min-width: 70px; padding: 4px 8px; border-radius: 3px; font-family: 'SF Mono', Monaco, monospace; text-align: center; background-color: ${avgColor.bg}; color: ${avgColor.text}; font-weight: 700; font-size: 12px; cursor: pointer;"
                          data-pair="${pair}" data-strike="avgPnL" title="Click to view chart">${formatThousand(result.avgPnL)}</span>
                </td>`;

                // Individual strike P&Ls
                ['10Œî Put', '25Œî Put', 'ATM Call', '25Œî Call', '10Œî Call'].forEach(strikeName => {
                    const pnl = result.strikes[strikeName].finalPnL;
                    const color = getPnLColor(pnl, scales?.strikePnLMaxAbs);
                    const strikeType = strikeTypeMap[strikeName];
                    html += `<td style="text-align: center; width: 110px;">
                        <span class="chart-cell" style="display: inline-block; min-width: 70px; padding: 4px 8px; border-radius: 3px; font-family: 'SF Mono', Monaco, monospace; text-align: center; background-color: ${color.bg}; color: ${color.text}; font-weight: 500; font-size: 12px; cursor: pointer;"
                              data-pair="${pair}" data-strike="${strikeType}" title="Click to view chart">${formatThousand(pnl)}</span>
                    </td>`;
                });

                // Vol columns (plain numbers, sortable)
                html += `<td class="data-table-numbers" style="border-left: 2px solid var(--border-strong);">${(result.impliedVol * 100).toFixed(2)}%</td>`;
                html += `<td class="data-table-numbers">${(result.realizedVol * 100).toFixed(2)}%</td>`;
                html += `<td class="data-table-numbers">${result.volDiff >= 0 ? '+' : ''}${(result.volDiff * 100).toFixed(2)}%</td>`;
                html += '</tr>';
            });

            html += '</tbody></table></div>';
            return html;
        }

        function setGlobalPnLMaxAbsFromPairResults(pairResults) {
            // pairResults is expected to be an array of [pair, result] tuples
            if (!Array.isArray(pairResults) || pairResults.length === 0) {
                window.globalPnLMaxAbs = 1;
                return;
            }
            let maxAbs = 0;
            pairResults.forEach(([_, result]) => {
                if (!result) return;
                const avgPnL = (result.avgPnL || 0) * 1000;
                maxAbs = Math.max(maxAbs, Math.abs(avgPnL));
                const strikes = result.strikes || {};
                ['10Œî Put', '25Œî Put', 'ATM Call', '25Œî Call', '10Œî Call'].forEach(strikeName => {
                    const pnl = strikes[strikeName]?.finalPnL;
                    if (pnl === undefined || pnl === null) return;
                    maxAbs = Math.max(maxAbs, Math.abs(pnl));
                });
            });
            window.globalPnLMaxAbs = maxAbs > 0 ? maxAbs : 1;
        }

        // Calculate separate scales for a tab: individual strike P&Ls vs average P&L
        // This allows avg P&L to have its own color intensity independent of individual strikes
        function calculateTabScales(pairResults) {
            let strikePnLMaxAbs = 0;  // For individual strikes (10Œî Put, 25Œî Put, ATM, 25Œî Call, 10Œî Call)
            let avgPnLMaxAbs = 0;     // For average P&L column

            pairResults.forEach(([_, result]) => {
                if (!result) return;

                // Average P&L scale (note: avgPnL is in units, multiply by 1000 for display)
                avgPnLMaxAbs = Math.max(avgPnLMaxAbs, Math.abs((result.avgPnL || 0) * 1000));

                // Individual strike P&L scale
                const strikes = result.strikes || {};
                ['10Œî Put', '25Œî Put', 'ATM Call', '25Œî Call', '10Œî Call'].forEach(strikeName => {
                    const pnl = strikes[strikeName]?.finalPnL;
                    if (pnl !== undefined && pnl !== null) {
                        strikePnLMaxAbs = Math.max(strikePnLMaxAbs, Math.abs(pnl));
                    }
                });
            });

            return {
                strikePnLMaxAbs: strikePnLMaxAbs > 0 ? strikePnLMaxAbs : 1,
                avgPnLMaxAbs: avgPnLMaxAbs > 0 ? avgPnLMaxAbs : 1
            };
        }

        function displayCurrencyGroups(pairResults) {
            // Get all analyzed pairs (remove duplicates)
            const analyzedPairs = [...new Set(pairResults.map(([pair, _]) => pair))];
            
            // Build currency blocks from results - show ALL pairs containing each currency
            const currencyBlocks = buildCurrencyBlocksFromResults(analyzedPairs, batchData.currencies || []);

            // Generate HTML for each non-empty group
            let html = '';
            
            // Sort currencies by number of pairs (descending)
            const sortedCurrencies = Object.keys(currencyBlocks).sort((a, b) =>
                currencyBlocks[b].length - currencyBlocks[a].length
            );

            sortedCurrencies.forEach(currency => {
                const pairsInBlock = currencyBlocks[currency];
                
                // Get results for these pairs
                const pairsWithResults = pairsInBlock
                    .map(pair => {
                        const result = pairResults.find(([p, _]) => p === pair);
                        return result ? [pair, result[1]] : null;
                    })
                    .filter(r => r !== null);

                if (pairsWithResults.length === 0) return;

                // Calculate group average
                const groupAvg = pairsWithResults.reduce((sum, [_, result]) => sum + result.avgPnL, 0) / pairsWithResults.length;
                const currencyName = getCurrencyName(currency);

                html += `<div class="currency-group-section">`;
                html += `<h3 class="currency-header">üí± ${currencyName} (${pairsWithResults.length} pairs)</h3>`;
                html += generateCurrencyGroupTable(pairsWithResults);
                html += `<div class="summary-block" style="margin-top: 12px;"><strong>Group Average:</strong> <span style="font-family: var(--font-mono);">${formatThousand(groupAvg)}</span></div>`;
                html += `</div>`;
            });

            document.getElementById('currencyGroupsContent').innerHTML = html;
        }

        function buildCurrencyBlocksFromResults(analyzedPairs, currencies) {
            const blocks = {};

            // For each currency, find ALL pairs that include it
            currencies.forEach(currency => {
                const pairsInBlock = analyzedPairs.filter(pair =>
                    pair.includes(currency)
                );

                if (pairsInBlock.length > 0) {
                    blocks[currency] = pairsInBlock;
                }
            });

            // Debug logging
            console.log('=== P&L CURRENCY GROUPS ===');
            console.log('Analyzed pairs:', analyzedPairs);
            console.log('Currencies:', currencies);
            console.log('Currency blocks:', Object.keys(blocks));
            console.log('USD pairs:', blocks['USD']);

            return blocks;
        }

        function generateCurrencyGroupTableForResults(pairs, scales) {
            // This version takes pairs as [pair, result] tuples
            // scales: { strikePnLMaxAbs, avgPnLMaxAbs } - pre-calculated for consistent coloring
            let html = '<table class="data-table" style="width: 100%; border-collapse: collapse; margin: 10px 0;"><thead><tr>';
            html += '<th class="sortable-header" onclick="sortTable(this, 0, \'string\')">Pair</th>';
            html += '<th class="sortable-header numeric-header" onclick="sortTable(this, 1, \'number\')">Avg P&L</th>';
            html += '<th class="sortable-header numeric-header" onclick="sortTable(this, 2, \'number\')">10Œî Put</th>';
            html += '<th class="sortable-header numeric-header" onclick="sortTable(this, 3, \'number\')">25Œî Put</th>';
            html += '<th class="sortable-header numeric-header" onclick="sortTable(this, 4, \'number\')">ATM Call</th>';
            html += '<th class="sortable-header numeric-header" onclick="sortTable(this, 5, \'number\')">25Œî Call</th>';
            html += '<th class="sortable-header numeric-header" onclick="sortTable(this, 6, \'number\')">10Œî Call</th>';
            html += '<th class="sortable-header numeric-header" onclick="sortTable(this, 7, \'number\')">Real Vol</th>';
            html += '<th class="sortable-header numeric-header" onclick="sortTable(this, 8, \'number\')">Impl Vol</th>';
            html += '<th class="sortable-header numeric-header" onclick="sortTable(this, 9, \'number\')">Vol Diff</th>';
            html += '</tr></thead><tbody>';

            // Strike type mapping for data attributes
            const strikeTypeMap = {
                '10Œî Put': 'put10Delta',
                '25Œî Put': 'put25Delta',
                'ATM Call': 'atmCall',
                '25Œî Call': 'call25Delta',
                '10Œî Call': 'call10Delta'
            };

            pairs.forEach(([pair, result]) => {
                const avgColor = getPnLColor(result.avgPnL * 1000, scales?.avgPnLMaxAbs);

                html += '<tr>';
                html += `<td style="font-weight: bold;">${pair}</td>`;
                html += `<td class="data-table-numbers chart-cell" style="background-color: ${avgColor.bg}; color: ${avgColor.text}; font-weight: bold;" data-pair="${pair}" data-strike="avgPnL" title="Click to view chart">${formatThousand(result.avgPnL)}</td>`;

                ['10Œî Put', '25Œî Put', 'ATM Call', '25Œî Call', '10Œî Call'].forEach(strikeName => {
                    const pnl = result.strikes[strikeName].finalPnL;
                    const color = getPnLColor(pnl, scales?.strikePnLMaxAbs);
                    const strikeType = strikeTypeMap[strikeName];
                    html += `<td class="data-table-numbers chart-cell" style="background-color: ${color.bg}; color: ${color.text};" data-pair="${pair}" data-strike="${strikeType}" title="Click to view chart">${formatThousand(pnl)}</td>`;
                });

                html += `<td class="data-table-numbers">${(result.realizedVol * 100).toFixed(2)}%</td>`;
                html += `<td class="data-table-numbers">${(result.impliedVol * 100).toFixed(2)}%</td>`;
                html += `<td class="data-table-numbers">${result.volDiff >= 0 ? '+' : ''}${(result.volDiff * 100).toFixed(2)}%</td>`;
                html += '</tr>';
            });

            html += '</tbody></table>';
            return html;
        }

        function generateCurrencyGroupTable(pairs, scales) {
            // scales: { strikePnLMaxAbs, avgPnLMaxAbs } - pre-calculated at tab level for consistent coloring

            const strikeTypeMap = {
                '10Œî Put': 'put10Delta',
                '25Œî Put': 'put25Delta',
                'ATM Call': 'atmCall',
                '25Œî Call': 'call25Delta',
                '10Œî Call': 'call10Delta'
            };
            
            // Calculate scales for Real Vol, Impl Vol, Vol Diff
            let realVolMin = Infinity, realVolMax = -Infinity;
            let implVolMin = Infinity, implVolMax = -Infinity;
            let volDiffMin = Infinity, volDiffMax = -Infinity;
            
            pairs.forEach(([pair, result]) => {
                const realVol = result.realizedVol * 100;
                const implVol = result.impliedVol * 100;
                const volDiff = result.volDiff * 100;
                
                realVolMin = Math.min(realVolMin, realVol);
                realVolMax = Math.max(realVolMax, realVol);
                implVolMin = Math.min(implVolMin, implVol);
                implVolMax = Math.max(implVolMax, implVol);
                volDiffMin = Math.min(volDiffMin, volDiff);
                volDiffMax = Math.max(volDiffMax, volDiff);
            });
            
            const volScales = {
                realVol: { min: realVolMin, max: realVolMax },
                implVol: { min: implVolMin, max: implVolMax },
                volDiff: { min: volDiffMin, max: volDiffMax }
            };
            
            let html = `
            <div class="card" style="overflow-x: auto;">
                <table class="data-table" style="min-width: 800px; font-size: 13px;">
                    <thead>
                        <tr>
                            <th class="sortable-header" onclick="sortTable(this, 0, 'string')" style="position: sticky; left: 0; background: var(--bg-elevated); z-index: 10; padding: 8px 10px; text-align: left; border-right: 2px solid var(--border);">Pair</th>
                            <th class="sortable-header numeric-header" onclick="sortTable(this, 1, 'number')" style="padding: 8px 10px; text-align: center; min-width: 100px; background: var(--bg-elevated);">Avg P&L</th>`;

            // Strike headers
            ['10Œî Put', '25Œî Put', 'ATM Call', '25Œî Call', '10Œî Call'].forEach(strikeName => {
                const idxMap = { '10Œî Put': 2, '25Œî Put': 3, 'ATM Call': 4, '25Œî Call': 5, '10Œî Call': 6 };
                html += `<th class="sortable-header numeric-header" onclick="sortTable(this, ${idxMap[strikeName]}, 'number')" style="padding: 8px 10px; text-align: center; min-width: 100px; background: var(--bg-elevated);">${strikeName}</th>`;
            });

            html += `
                            <th class="sortable-header numeric-header" onclick="sortTable(this, 7, 'number')" style="padding: 8px 10px; text-align: center; min-width: 100px; background: var(--bg-elevated); border-left: 2px solid var(--border-strong);">Impl Vol</th>
                            <th class="sortable-header numeric-header" onclick="sortTable(this, 8, 'number')" style="padding: 8px 10px; text-align: center; min-width: 100px; background: var(--bg-elevated);">Real Vol</th>
                            <th class="sortable-header numeric-header" onclick="sortTable(this, 9, 'number')" style="padding: 8px 10px; text-align: center; min-width: 100px; background: var(--bg-elevated);">Vol Diff</th>
                        </tr>
                    </thead>
                    <tbody>`;

            pairs.forEach(([pair, result]) => {
                const avgColor = getPnLColor(result.avgPnL * 1000, scales?.avgPnLMaxAbs);

                html += `
                        <tr>
                            <td style="position: sticky; left: 0; background: var(--bg-main); z-index: 9; padding: 6px 10px; font-weight: 600; border-right: 2px solid var(--border); font-size: 13px;">${pair}</td>
                            <td style="padding: 6px 8px; text-align: center; width: 100px;">
                                <span class="chart-cell" style="display: inline-block; min-width: 70px; padding: 4px 8px; border-radius: 3px; font-family: 'SF Mono', Monaco, monospace; text-align: center; background-color: ${avgColor.bg}; color: ${avgColor.text}; font-weight: 600; font-size: 12px; cursor: pointer;" data-pair="${pair}" data-strike="avgPnL" title="Click to view chart">${formatThousand(result.avgPnL)}</span>
                            </td>`;

                ['10Œî Put', '25Œî Put', 'ATM Call', '25Œî Call', '10Œî Call'].forEach(strikeName => {
                    const pnl = result.strikes[strikeName].finalPnL;
                    const color = getPnLColor(pnl, scales?.strikePnLMaxAbs);
                    const strikeType = strikeTypeMap[strikeName];
                    html += `
                            <td style="padding: 6px 8px; text-align: center; width: 100px;">
                                <span class="chart-cell" style="display: inline-block; min-width: 70px; padding: 4px 8px; border-radius: 3px; font-family: 'SF Mono', Monaco, monospace; text-align: center; background-color: ${color.bg}; color: ${color.text}; font-weight: 500; font-size: 12px; cursor: pointer;" data-pair="${pair}" data-strike="${strikeType}" title="Click to view chart">${formatThousand(pnl)}</span>
                            </td>`;
                });
                
                // Vol columns with color coding
                const realVolColor = getCellColor(result.realizedVol * 100, volScales.realVol);
                const implVolColor = getCellColor(result.impliedVol * 100, volScales.implVol);
                const volDiffColor = getCellColor(result.volDiff * 100, volScales.volDiff);
                const realVolText = getTextColorForBackground(realVolColor);
                const implVolText = getTextColorForBackground(implVolColor);
                const volDiffText = getTextColorForBackground(volDiffColor);
                
                html += `
                            <td style="padding: 6px 8px; text-align: center; width: 100px; border-left: 2px solid var(--border-strong);">
                                <span style="display: inline-block; min-width: 70px; padding: 4px 8px; border-radius: 3px; font-family: 'SF Mono', Monaco, monospace; text-align: center; background-color: ${implVolColor}; color: ${implVolText}; font-weight: 500; font-size: 12px;">${(result.impliedVol * 100).toFixed(2)}%</span>
                            </td>
                            <td style="padding: 6px 8px; text-align: center; width: 100px;">
                                <span style="display: inline-block; min-width: 70px; padding: 4px 8px; border-radius: 3px; font-family: 'SF Mono', Monaco, monospace; text-align: center; background-color: ${realVolColor}; color: ${realVolText}; font-weight: 500; font-size: 12px;">${(result.realizedVol * 100).toFixed(2)}%</span>
                            </td>
                            <td style="padding: 6px 8px; text-align: center; width: 100px; ">
                                <span style="display: inline-block; min-width: 70px; padding: 4px 8px; border-radius: 3px; font-family: 'SF Mono', Monaco, monospace; text-align: center; background-color: ${volDiffColor}; color: ${volDiffText}; font-weight: 600; font-size: 12px;">${result.volDiff >= 0 ? '+' : ''}${(result.volDiff * 100).toFixed(2)}%</span>
                            </td>
                        </tr>`;
            });

            html += `
                    </tbody>
                </table>
            </div>`;
            return html;
        }

        function displayExpandableDetails(pairResults, scales) {
            // scales: { strikePnLMaxAbs, avgPnLMaxAbs } - optional, will be calculated if not provided
            const effectiveScales = scales || calculateTabScales(pairResults);
            let html = '';

            pairResults.forEach(([pair, result]) => {
                const avgColor = getPnLColor(result.avgPnL * 1000, effectiveScales.avgPnLMaxAbs);

                html += `<div class="expandable-pair">`;
                html += `<div class="pair-header" onclick="togglePairDetails('${pair}')">`;
                html += `<span style="font-weight: bold; font-size: 16px;">‚ñ∂ ${pair}</span>`;
                html += `<span style="background-color: ${avgColor.bg}; color: ${avgColor.text}; padding: 5px 10px; border-radius: 4px; font-weight: bold;">Avg P&L: ${formatThousand(result.avgPnL)}</span>`;
                html += `</div>`;
                html += `<div class="pair-details" id="details-${pair}">`;

                // Strike P&L Summary Table
                html += '<h4>Strike P&L Summary:</h4>';
                html += '<table style="width: 100%; border-collapse: collapse;"><thead><tr><th></th>';

                ['10Œî Put', '25Œî Put', 'ATM Call', '25Œî Call', '10Œî Call'].forEach(strikeName => {
                    const strikePrice = result.strikes[strikeName].strikePrice;
                    html += `<th>${strikePrice.toFixed(4)}</th>`;
                });
                html += '</tr></thead><tbody><tr><td><strong>Strike</strong></td>';

                ['10Œî Put', '25Œî Put', 'ATM Call', '25Œî Call', '10Œî Call'].forEach(strikeName => {
                    html += `<td>${strikeName}</td>`;
                });
                html += '</tr><tr><td><strong>P&L (k)</strong></td>';

                ['10Œî Put', '25Œî Put', 'ATM Call', '25Œî Call', '10Œî Call'].forEach(strikeName => {
                    const pnl = result.strikes[strikeName].finalPnL;
                    const color = getPnLColor(pnl, effectiveScales.strikePnLMaxAbs);
                    html += `<td style="background-color: ${color.bg}; color: ${color.text}; font-weight: bold;">${formatThousand(pnl)}</td>`;
                });
                html += '</tr></tbody></table>';

                // Summary stats
                html += `<div style="margin-top: 15px; padding: 10px; background-color: #f9f9f9; border-radius: 4px;">`;
                html += `<strong>Summary:</strong> `;
                html += `Avg P&L: ${formatThousand(result.avgPnL)} | `;
                html += `Impl Vol: ${(result.impliedVol * 100).toFixed(2)}% | `;
                html += `Real Vol: ${(result.realizedVol * 100).toFixed(2)}% | `;
                html += `Vol Diff: ${result.volDiff >= 0 ? '+' : ''}${(result.volDiff * 100).toFixed(2)}%`;
                html += `</div>`;

                // View Charts button
                html += `<button style="margin-top: 15px;" onclick="showBatchPairCharts('${pair}')">View P&L Charts</button>`;

                html += `</div>`;
                html += `</div>`;
            });

            document.getElementById('expandableDetailsContent').innerHTML = html;
        }

        function togglePairDetails(pair) {
            const detailsDiv = document.getElementById(`details-${pair}`);
            const header = detailsDiv.previousElementSibling;
            const arrow = header.querySelector('span:first-child');

            if (detailsDiv.classList.contains('expanded')) {
                detailsDiv.classList.remove('expanded');
                arrow.textContent = `‚ñ∂ ${pair}`;
            } else {
                detailsDiv.classList.add('expanded');
                arrow.textContent = `‚ñº ${pair}`;
            }
        }

        // Sort table by column
        function sortTable(header, columnIndex, dataType) {
            // Get the table
            const table = header.closest('table');
            const tbody = table.querySelector('tbody');
            if (!tbody) return;
            
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            // Determine sort direction
            const isAscending = header.classList.contains('sort-asc');
            const isDescending = header.classList.contains('sort-desc');
            
            let sortDirection;
            if (isAscending) {
                sortDirection = 'desc';
            } else if (isDescending) {
                sortDirection = 'asc';
            } else {
                sortDirection = 'asc';
            }
            
            // Remove sort classes from all headers in this table
            const allHeaders = table.querySelectorAll('th');
            allHeaders.forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });
            
            // Add sort class to clicked header
            header.classList.add('sort-' + sortDirection);
            
            // Sort rows
            rows.sort((a, b) => {
                const cellA = a.children[columnIndex];
                const cellB = b.children[columnIndex];
                
                if (!cellA || !cellB) return 0;
                
                let valueA = cellA.textContent.trim();
                let valueB = cellB.textContent.trim();
                
                if (dataType === 'number') {
                    // Remove currency symbols, commas, percentage signs, k suffix
                    valueA = parseFloat(valueA.replace(/[$,k%+\s]/g, '')) || 0;
                    valueB = parseFloat(valueB.replace(/[$,k%+\s]/g, '')) || 0;
                    
                    if (sortDirection === 'asc') {
                        return valueA - valueB;
                    } else {
                        return valueB - valueA;
                    }
                } else {
                    // String comparison
                    if (sortDirection === 'asc') {
                        return valueA.localeCompare(valueB);
                    } else {
                        return valueB.localeCompare(valueA);
                    }
                }
            });
            
            // Remove all rows from tbody
            while (tbody.firstChild) {
                tbody.removeChild(tbody.firstChild);
            }
            
            // Re-append sorted rows
            rows.forEach(row => {
                tbody.appendChild(row);
            });
            
            // Highlight sorted column
            highlightSortedColumn(table, columnIndex);
        }

        // Highlight the sorted column
        function highlightSortedColumn(table, columnIndex) {
            // Remove previous highlights from all cells
            const allCells = table.querySelectorAll('td, th');
            allCells.forEach(cell => {
                cell.classList.remove('sorted-column');
            });
            
            // Only highlight the header cell, NOT the body cells
            // Body cells have their own color-coded backgrounds that must be preserved
            const headerRow = table.querySelector('thead tr');
            if (headerRow) {
                const headerCell = headerRow.children[columnIndex];
                if (headerCell) {
                    headerCell.classList.add('sorted-column');
                }
            }
            
            // DO NOT highlight tbody cells - they have their own colors
        }

        function showBatchPairCharts(pair) {
            const result = batchData.results[pair];
            if (!result) {
                alert('Data not available for ' + pair);
                return;
            }

            // Create modal if it doesn't exist
            let modal = document.getElementById('batchChartModal');
            if (!modal) {
                const modalHTML = `
                    <div id="batchChartModal" class="modal">
                        <div class="modal-content" style="width: 95%; max-width: 1600px;">
                            <div class="modal-header">
                                <h2 id="batchChartTitle"></h2>
                                <span class="close" onclick="closeBatchChartModal()">&times;</span>
                            </div>
                            <div id="batchChartsContainer" style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-top: 20px;">
                                <!-- Charts will be added here -->
                            </div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
                modal = document.getElementById('batchChartModal');
            }

            // Set title
            document.getElementById('batchChartTitle').textContent = `P&L Path Charts - ${pair}`;

            // Clear previous charts
            const container = document.getElementById('batchChartsContainer');
            container.innerHTML = '';

            // Prepare spot time points for all strikes
            const allSpotTimes = [];
            const allSpotPrices = result.spotData;
            for (let i = 0; i < allSpotPrices.length; i++) {
                allSpotTimes.push(i * result.baseFreq);
            }

            // Create a chart for each strike
            const strikeNames = ['10Œî Put', '25Œî Put', 'ATM Call', '25Œî Call', '10Œî Call'];

            strikeNames.forEach(strikeName => {
                const strikeData = result.strikes[strikeName];
                if (!strikeData || !strikeData.pnlData) return;

                // Extract time series data
                const pnlData = strikeData.pnlData;
                const timePoints = pnlData.map(p => p.time);
                const premiumValues = pnlData.map(p => p.premium / 1000);
                const optionValues = pnlData.map(p => p.optionValue / 1000);
                const hedgePnLs = pnlData.map(p => p.hedgePnL / 1000);
                const portfolioValues = pnlData.map(p => p.portfolioValue / 1000);

                // Create canvas container
                const chartDiv = document.createElement('div');
                chartDiv.innerHTML = `
                    <h3 style="text-align: center; margin-bottom: 10px;">${strikeName} (Strike: ${strikeData.strikePrice.toFixed(4)})</h3>
                    <canvas id="chart_${pair}_${strikeName.replace(/[^a-zA-Z0-9]/g, '_')}" width="800" height="500"></canvas>
                `;
                container.appendChild(chartDiv);

                // Draw chart
                const canvasId = `chart_${pair}_${strikeName.replace(/[^a-zA-Z0-9]/g, '_')}`;
                const canvas = document.getElementById(canvasId);
                drawCustomChart(canvas, timePoints, premiumValues, optionValues, hedgePnLs, portfolioValues, allSpotTimes, allSpotPrices);
            });

            // Show modal
            modal.style.display = 'block';
        }

        function closeBatchChartModal() {
            const modal = document.getElementById('batchChartModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // Close modal when clicking outside
        window.addEventListener('click', function(event) {
            const modal = document.getElementById('batchChartModal');
            if (event.target === modal) {
                closeBatchChartModal();
            }
        });

        // ============ STRIKE CALCULATION - EXACT CODE ============

        function erf(x) {
            const sign = x >= 0 ? 1 : -1;
            x = Math.abs(x);
            const a1 = 0.254829592;
            const a2 = -0.284496736;
            const a3 = 1.421413741;
            const a4 = -1.453152027;
            const a5 = 1.061405429;
            const p = 0.3275911;
            const t = 1.0 / (1.0 + p * x);
            const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
            return sign * y;
        }

        function normalCDF(x) {
            return 0.5 * (1 + erf(x / Math.sqrt(2)));
        }

        function inverseNormalCDF(p) {
            if (p <= 0 || p >= 1) throw new Error('p must be between 0 and 1');

            const a = [
                -3.969683028665376e+01, 2.209460984245205e+02,
                -2.759285104469687e+02, 1.383577518672690e+02,
                -3.066479806614716e+01, 2.506628277459239e+00
            ];
            const b = [
                -5.447609879822406e+01, 1.615858368580409e+02,
                -1.556989798598866e+02, 6.680131188771972e+01,
                -1.328068155288572e+01
            ];
            const c = [
                -7.784894002430293e-03, -3.223964580411365e-01,
                -2.400758277161838e+00, -2.549732539343734e+00,
                4.374664141464968e+00, 2.938163982698783e+00
            ];
            const d = [
                7.784695709041462e-03, 3.224671290700398e-01,
                2.445134137142996e+00, 3.754408661907416e+00
            ];

            const pLow = 0.02425;
            const pHigh = 1 - pLow;

            let q, r, result;

            if (p < pLow) {
                q = Math.sqrt(-2 * Math.log(p));
                result = (((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) /
                         ((((d[0] * q + d[1]) * q + d[2]) * q + d[3]) * q + 1);
            } else if (p <= pHigh) {
                q = p - 0.5;
                r = q * q;
                result = (((((a[0] * r + a[1]) * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * q /
                         (((((b[0] * r + b[1]) * r + b[2]) * r + b[3]) * r + b[4]) * r + 1);
            } else {
                q = Math.sqrt(-2 * Math.log(1 - p));
                result = -(((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) /
                          ((((d[0] * q + d[1]) * q + d[2]) * q + d[3]) * q + 1);
            }

            return result;
        }

        function calculateStrikeFromDelta(spot, annualVol, timeYears, targetDelta) {
            const volSqrtT = annualVol * Math.sqrt(timeYears);
            const varianceAdj = 0.5 * annualVol * annualVol * timeYears;
            const d1Input = (targetDelta < 0) ? (targetDelta + 1.0) : targetDelta;
            const d1 = inverseNormalCDF(d1Input);
            const logMoneyness = d1 * volSqrtT - varianceAdj;
            const strike = spot * Math.exp(-logMoneyness);
            return strike;
        }

        // ============ END STRIKE CALCULATION CODE ============

        function normCDF(x) {
            return normalCDF(x);
        }

        function blackScholesCall(S, K, T, sigma) {
            if (T <= 0) {
                return Math.max(S - K, 0);
            }

            const sqrtT = Math.sqrt(T);
            const d1 = (Math.log(S / K) + (0.5 * sigma * sigma * T)) / (sigma * sqrtT);
            const d2 = d1 - sigma * sqrtT;

            return S * normCDF(d1) - K * normCDF(d2);
        }

        function blackScholesPut(S, K, T, sigma) {
            if (T <= 0) {
                return Math.max(K - S, 0);
            }

            const sqrtT = Math.sqrt(T);
            const d1 = (Math.log(S / K) + (0.5 * sigma * sigma * T)) / (sigma * sqrtT);
            const d2 = d1 - sigma * sqrtT;

            return K * normCDF(-d2) - S * normCDF(-d1);
        }

        function callDelta(S, K, T, sigma) {
            if (T <= 0) {
                return S > K ? 1 : 0;
            }

            const sqrtT = Math.sqrt(T);
            const d1 = (Math.log(S / K) + (0.5 * sigma * sigma * T)) / (sigma * sqrtT);

            return normCDF(d1);
        }

        function putDelta(S, K, T, sigma) {
            return callDelta(S, K, T, sigma) - 1;
        }

        function formatThousand(value) {
            const thousands = value / 1_000;
            const absThousands = Math.abs(thousands);
            const sign = thousands < 0 ? '-' : '';
            const formatted = absThousands.toFixed(1).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            return sign + formatted + 'k';
        }

        function formatMillion(value) {
            const millions = value / 1_000_000;
            const absMillion = Math.abs(millions);
            const sign = millions < 0 ? '-' : '';
            const formatted = absMillion.toFixed(1);
            return sign + formatted + 'm';
        }

        function formatNumber(value, decimals = 4) {
            return value.toFixed(decimals);
        }

        // ============ P&L COLOR CODING ============

        function getPnLColor(pnl, explicitMaxAbs) {
            // Symmetric, sign-preserving gradient around 0 using the provided or global max abs P&L.
            // No greys for non-zero values: positives are always green-tinted, negatives always red-tinted.
            // explicitMaxAbs: if provided, use this; otherwise fall back to window.globalPnLMaxAbs
            const maxAbs = (explicitMaxAbs && !isNaN(explicitMaxAbs) && explicitMaxAbs > 0)
                ? explicitMaxAbs
                : ((window.globalPnLMaxAbs && !isNaN(window.globalPnLMaxAbs)) ? window.globalPnLMaxAbs : 1);
            const abs = Math.abs(pnl);
            const t = Math.max(0, Math.min(1, abs / maxAbs));
            
            // Apply a gentle gamma so low values are still visibly tinted
            const gamma = 0.6;
            const tt = Math.pow(t, gamma);
            
            // Color endpoints:
            // - Deep green: (0, 100, 0)
            // - Pale green: (210, 255, 210)
            // - Deep red:   (139, 0, 0)
            // - Pale red:   (255, 210, 210)
            let r, g, b;
            if (pnl > 0) {
                const r0 = 210, g0 = 255, b0 = 210; // pale green
                const r1 = 0,   g1 = 100, b1 = 0;   // deep green
                r = Math.round(r0 + (r1 - r0) * tt);
                g = Math.round(g0 + (g1 - g0) * tt);
                b = Math.round(b0 + (b1 - b0) * tt);
            } else if (pnl < 0) {
                const r0 = 255, g0 = 210, b0 = 210; // pale red
                const r1 = 139, g1 = 0,   b1 = 0;   // deep red
                r = Math.round(r0 + (r1 - r0) * tt);
                g = Math.round(g0 + (g1 - g0) * tt);
                b = Math.round(b0 + (b1 - b0) * tt);
            } else {
                // Exactly zero: keep neutral (very dark) so it doesn't look ‚Äúmissing‚Äù
                r = 70; g = 70; b = 70;
            }
            
            const bgColor = `rgb(${r}, ${g}, ${b})`;
            const textColor = getTextColorForBackground(bgColor);
            return { bg: bgColor, text: textColor };
        }

        // ============ CUSTOM STRIKES MANAGEMENT ============

        function addCustomStrike() {
            const container = document.getElementById('customStrikesContainer');
            const currentCount = container.children.length;

            if (currentCount >= MAX_CUSTOM_STRIKES) {
                showValidationMessage('Maximum 5 custom strikes allowed', 'warning');
                return;
            }

            const rowId = `custom-strike-${customStrikeCounter++}`;
            const row = document.createElement('div');
            row.className = 'custom-strike-row';
            row.id = rowId;

            row.innerHTML = `
                <input type="number" class="custom-strike-value" step="0.0001" placeholder="Value">
                <select class="custom-strike-mode" onchange="toggleCallPutDropdown('${rowId}')">
                    <option value="strike">Strike Price</option>
                    <option value="delta">Delta</option>
                </select>
                <select class="custom-strike-type hidden">
                    <option value="call">Call</option>
                    <option value="put">Put</option>
                </select>
                <button class="secondary" onclick="removeCustomStrike('${rowId}')">Remove</button>
            `;

            container.appendChild(row);
            updateCustomStrikeCount();
        }

        function removeCustomStrike(rowId) {
            const row = document.getElementById(rowId);
            if (row) {
                row.remove();
                updateCustomStrikeCount();
            }
        }

        function toggleCallPutDropdown(rowId) {
            const row = document.getElementById(rowId);
            const mode = row.querySelector('.custom-strike-mode').value;
            const typeDropdown = row.querySelector('.custom-strike-type');

            if (mode === 'delta') {
                typeDropdown.classList.remove('hidden');
            } else {
                typeDropdown.classList.add('hidden');
            }
        }

        function updateCustomStrikeCount() {
            const container = document.getElementById('customStrikesContainer');
            const count = container.children.length;
            document.getElementById('customStrikeCount').textContent = `Custom Strikes: ${count}/${MAX_CUSTOM_STRIKES}`;

            const addBtn = document.getElementById('addCustomStrikeBtn');
            addBtn.disabled = count >= MAX_CUSTOM_STRIKES;
        }

        // ============ OPTION EXPIRY TOGGLE ============

        function toggleExpiryMode() {
            const customRadio = document.querySelector('input[name="expiryMode"][value="custom"]');
            const customInput = document.getElementById('customExpiryValue');
            const customUnit = document.getElementById('customExpiryUnit');
            const calculationsDiv = document.getElementById('expiryCalculations');

            if (customRadio.checked) {
                customInput.disabled = false;
                customUnit.disabled = false;
                calculationsDiv.style.display = 'block';
                updateExpiryCalculations();
            } else {
                customInput.disabled = true;
                customUnit.disabled = true;
                calculationsDiv.style.display = 'none';
            }
        }

        function updateExpiryCalculations() {
            // This will be called during calculate() to show spot series length
            // and time remaining. Placeholder for now.
            const customExpiryValue = parseFloat(document.getElementById('customExpiryValue').value);
            const customExpiryUnit = document.getElementById('customExpiryUnit').value;
            if (!isNaN(customExpiryValue)) {
                document.getElementById('spotSeriesLengthDisplay').textContent = '‚Ä¢ Spot Series Length: (will calculate when you click Calculate)';
                document.getElementById('timeRemainingDisplay').textContent = '‚Ä¢ Time Remaining at End: (will calculate when you click Calculate)';
            }
        }

        function parseCustomStrikes(initialSpot, sigma, timeYears) {
            const container = document.getElementById('customStrikesContainer');
            const customStrikes = [];

            for (let i = 0; i < container.children.length; i++) {
                const row = container.children[i];
                const value = parseFloat(row.querySelector('.custom-strike-value').value);
                const mode = row.querySelector('.custom-strike-mode').value;
                const type = row.querySelector('.custom-strike-type').value;

                if (isNaN(value) || value <= 0) {
                    showValidationMessage(`Custom strike ${i + 1}: Please enter a valid positive value`, 'error');
                    return null;
                }

                let strike, optionType, label;

                if (mode === 'strike') {
                    // Strike Price mode: auto-determine Call/Put
                    strike = value;
                    optionType = (strike < initialSpot) ? 'put' : 'call';
                    label = `Custom: ${strike.toFixed(4)} ${optionType.charAt(0).toUpperCase() + optionType.slice(1)}`;
                } else {
                    // Delta mode
                    if (value < 0 || value > 100) {
                        showValidationMessage(`Custom strike ${i + 1}: Delta must be between 0 and 100`, 'error');
                        return null;
                    }

                    const deltaDecimal = value / 100;
                    optionType = type; // User selected
                    const targetDelta = (optionType === 'put') ? -deltaDecimal : deltaDecimal;

                    // Calculate strike using delta
                    strike = calculateStrikeFromDelta(initialSpot, sigma, timeYears, targetDelta);
                    label = `Custom: ${value}Œî ${optionType.charAt(0).toUpperCase() + optionType.slice(1)} (Strike: ${strike.toFixed(4)})`;
                }

                customStrikes.push({
                    name: label,
                    strike: strike,
                    type: optionType,
                    isCustom: true
                });
            }

            return customStrikes;
        }

        // ============ END CUSTOM STRIKES MANAGEMENT ============

        function generateTestData() {
            const initialSpot = parseFloat(document.getElementById('initialSpot').value);
            if (isNaN(initialSpot) || initialSpot <= 0) {
                showValidationMessage('Please enter a valid initial spot price', 'error');
                return;
            }

            const hoursOfData = parseFloat(document.getElementById('hoursOfData').value);
            if (isNaN(hoursOfData) || hoursOfData <= 0) {
                showValidationMessage('Please enter valid hours of data (e.g., 1, 24, 48)', 'error');
                return;
            }

            const baseFreq = parseInt(document.getElementById('baseFrequency').value);

            // Calculate number of points: hours * 60 / base_freq + 1
            // Example: 24 hours, base=10 ‚Üí 24 * 60 / 10 + 1 = 144 + 1 = 145 points
            const totalMinutes = hoursOfData * 60;
            const numIntervals = Math.floor(totalMinutes / baseFreq);
            const numPoints = numIntervals + 1;

            if (numPoints < MIN_POINTS) {
                showValidationMessage(`Hours too small. Minimum ${MIN_POINTS} points needed (${((MIN_POINTS - 1) * baseFreq / 60).toFixed(2)} hours)`, 'error');
                return;
            }

            if (numPoints > MAX_POINTS) {
                showValidationMessage(`Hours too large. Maximum ${MAX_POINTS} points allowed (${((MAX_POINTS - 1) * baseFreq / 60).toFixed(0)} hours)`, 'error');
                return;
            }

            const spots = [initialSpot];
            let currentSpot = initialSpot;

            // Generate random walk data
            for (let i = 1; i < numPoints; i++) {
                // Random move: ¬±0.01% to ¬±0.05% per interval
                const randomMove = (Math.random() - 0.5) * 0.0008 * currentSpot;
                currentSpot = currentSpot + randomMove;
                spots.push(currentSpot);
            }

            // Fill textarea
            document.getElementById('spotSeries').value = spots.map(s => s.toFixed(4)).join('\n');
            showValidationMessage(`Test data generated successfully (${numPoints} values at ${baseFreq}-minute intervals, ${hoursOfData} hours)`, 'verification');
        }

        function showValidationMessage(message, type = 'verification') {
            const div = document.getElementById('validation-message');
            div.innerHTML = `<div class="${type}">${message}</div>`;
        }

        function parseSpotSeries() {
            const text = document.getElementById('spotSeries').value.trim();
            if (!text) {
                showValidationMessage('Please enter spot price series', 'error');
                return null;
            }

            const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 0);

            if (lines.length < MIN_POINTS) {
                showValidationMessage(`Error: Minimum ${MIN_POINTS} values required, got ${lines.length}`, 'error');
                return null;
            }

            if (lines.length > MAX_POINTS) {
                showValidationMessage(`Error: Maximum ${MAX_POINTS} values allowed, got ${lines.length}`, 'error');
                return null;
            }

            const spots = [];
            for (let i = 0; i < lines.length; i++) {
                const value = parseFloat(lines[i]);
                if (isNaN(value) || value <= 0) {
                    showValidationMessage(`Error: Invalid value at line ${i + 1}: "${lines[i]}"`, 'error');
                    return null;
                }
                spots.push(value);
            }

            return spots;
        }

        function calculateHedgeTimes(totalMinutes, hedgeFrequency) {
            // Calculate all hedge times: [0, hedge_freq, 2*hedge_freq, ...]
            // Stop when hedge_time <= total_minutes
            const hedgeTimes = [];
            let hedgeTime = 0;
            while (hedgeTime <= totalMinutes) {
                hedgeTimes.push(hedgeTime);
                hedgeTime += hedgeFrequency;
            }
            return hedgeTimes;
        }

        function calculateRealizedVolatility(spotPrices, totalDays, hedgeTimes, baseFreq) {
            // Calculate returns at hedging frequency
            // Get spot prices only at hedge times (and final time if not aligned)

            const spotsAtHedgeTimes = [];
            const numDataPoints = spotPrices.length;
            const totalMinutes = (numDataPoints - 1) * baseFreq;

            // Add spots at all hedge times
            for (const hedgeTime of hedgeTimes) {
                const spotIndex = hedgeTime / baseFreq;
                if (spotIndex < numDataPoints) {
                    spotsAtHedgeTimes.push(spotPrices[spotIndex]);
                }
            }

            // If final time is not a hedge time, include it
            const lastHedgeTime = hedgeTimes[hedgeTimes.length - 1];
            if (lastHedgeTime < totalMinutes) {
                spotsAtHedgeTimes.push(spotPrices[numDataPoints - 1]);
            }

            // Calculate log returns between consecutive hedge spots
            const returns = [];
            for (let i = 1; i < spotsAtHedgeTimes.length; i++) {
                returns.push(Math.log(spotsAtHedgeTimes[i] / spotsAtHedgeTimes[i-1]));
            }

            // Calculate total period variance (sum of squared returns, NOT divided by n)
            // This represents variance over the entire period
            const varianceTotalPeriod = returns.reduce((sum, r) => sum + r*r, 0);

            // Annualize based on actual days covered
            // Example: 1 day ‚Üí multiply by 365, 2 days ‚Üí multiply by 182.5, etc.
            const annualizedVariance = varianceTotalPeriod * (365 / totalDays);

            // Get volatility
            const realizedVol = Math.sqrt(annualizedVariance);

            return realizedVol; // Returns decimal (e.g., 0.3507 for 35.07%)
        }

        function calculateStrikePnL(spots, strike, sigma, optionType, baseNotional, totalMinutes, hedgeTimes, baseFreq, optionTenorMinutes) {
            let results = [];
            let cumulativeHedge = 0;
            let weightedSumHedge = 0;
            let avgSpot = 0;
            let realizedPnL = 0;
            let previousDelta = 0;
            let lastHedgePnL = 0; // Track last hedge P&L for final row if needed
            let lastCumulativeHedge = 0; // Track last cumulative hedge position
            let lastAvgSpot = 0; // Track last weighted avg spot

            // Calculate premium at t=0 using OPTION TENOR
            const T0 = optionTenorMinutes / (365 * 24 * 60); // Initial time to expiry in years
            const premium = optionType === 'call'
                ? blackScholesCall(spots[0], strike, T0, sigma)
                : blackScholesPut(spots[0], strike, T0, sigma);
            const premiumPaid = -premium * baseNotional;

            // Only process hedge times
            for (let hedgeIdx = 0; hedgeIdx < hedgeTimes.length; hedgeIdx++) {
                const hedgeTime = hedgeTimes[hedgeIdx];
                const spotIndex = hedgeTime / baseFreq;
                const spot = spots[spotIndex];

                // Time remaining in years (based on OPTION EXPIRY, not spot series length)
                const minutesRemaining = optionTenorMinutes - hedgeTime;

                // If option has expired, stop calculations
                if (minutesRemaining < 0) {
                    break;
                }

                const T = minutesRemaining / (365 * 24 * 60);

                // Calculate option value and delta
                const optionValue = optionType === 'call'
                    ? blackScholesCall(spot, strike, T, sigma)
                    : blackScholesPut(spot, strike, T, sigma);

                const delta = optionType === 'call'
                    ? callDelta(spot, strike, T, sigma)
                    : putDelta(spot, strike, T, sigma);

                // Calculate incremental hedge
                let incrementalHedge;
                if (hedgeIdx === 0) {
                    incrementalHedge = -delta * baseNotional;
                } else {
                    const deltaChange = delta - previousDelta;
                    incrementalHedge = -deltaChange * baseNotional;
                }

                // Update cumulative hedge with realized/unrealized P&L tracking
                const prevCumHedge = cumulativeHedge;
                const prevAvgSpot = avgSpot;
                const newCumHedge = prevCumHedge + incrementalHedge;

                if (prevCumHedge === 0) {
                    cumulativeHedge = newCumHedge;
                    weightedSumHedge = newCumHedge * spot;
                    avgSpot = spot;
                } else if (newCumHedge === 0) {
                    realizedPnL += prevCumHedge * (spot - prevAvgSpot);
                    cumulativeHedge = 0;
                    weightedSumHedge = 0;
                    avgSpot = 0;
                } else if (Math.sign(prevCumHedge) !== Math.sign(newCumHedge)) {
                    realizedPnL += prevCumHedge * (spot - prevAvgSpot);
                    cumulativeHedge = newCumHedge;
                    weightedSumHedge = newCumHedge * spot;
                    avgSpot = spot;
                } else if (Math.abs(newCumHedge) < Math.abs(prevCumHedge)) {
                    const closedAmount = prevCumHedge - newCumHedge;
                    realizedPnL += closedAmount * (spot - prevAvgSpot);
                    cumulativeHedge = newCumHedge;
                    weightedSumHedge = newCumHedge * prevAvgSpot;
                    avgSpot = prevAvgSpot;
                } else {
                    cumulativeHedge = newCumHedge;
                    weightedSumHedge += incrementalHedge * spot;
                    avgSpot = weightedSumHedge / cumulativeHedge;
                }

                const unrealizedPnL = cumulativeHedge !== 0 ? cumulativeHedge * (spot - avgSpot) : 0;
                const hedgePnL = realizedPnL + unrealizedPnL;
                const portfolioValue = premiumPaid + (optionValue * baseNotional) + hedgePnL;

                // Save state for potential final row mark-to-market calculation
                lastHedgePnL = hedgePnL;
                lastCumulativeHedge = cumulativeHedge;
                lastAvgSpot = avgSpot;

                results.push({
                    time: hedgeTime,
                    spot: spot,
                    delta: delta,
                    incrementalHedge: incrementalHedge,
                    cumulativeHedge: cumulativeHedge,
                    avgSpot: avgSpot,
                    realizedPnL: realizedPnL,
                    unrealizedPnL: unrealizedPnL,
                    hedgePnL: hedgePnL,
                    optionValue: optionValue * baseNotional,
                    premium: premiumPaid,
                    portfolioValue: portfolioValue,
                    isHedgeTime: true
                });

                previousDelta = delta;
            }

            // Check if we need to add a final row
            const lastHedgeTime = hedgeTimes[hedgeTimes.length - 1];
            const optionExpiryTime = optionTenorMinutes;

            // Determine the effective final time (min of spot series end and option expiry)
            const effectiveFinalTime = Math.min(totalMinutes, optionExpiryTime);

            if (lastHedgeTime < effectiveFinalTime) {
                // Add final row with mark-to-market
                // Use spot at effective final time (which might be before end of series if option expires early)
                const finalSpotIndex = Math.floor(effectiveFinalTime / baseFreq);
                const finalSpot = spots[finalSpotIndex];

                // Calculate time remaining at effective final time
                const minutesRemainingAtFinal = optionExpiryTime - effectiveFinalTime;
                const T = Math.max(0, minutesRemainingAtFinal / (365 * 24 * 60));

                const optionValue = optionType === 'call'
                    ? blackScholesCall(finalSpot, strike, T, sigma)
                    : blackScholesPut(finalSpot, strike, T, sigma);

                // CRITICAL FIX: Mark-to-market hedge P&L at CURRENT spot (finalSpot)
                // Hedge position stays same as last hedge, but revalue at current spot
                // Formula: Hedge_P&L = Cumulative_Hedge √ó (Current_Spot - Weighted_Avg_Spot)
                const unrealizedPnL = lastCumulativeHedge !== 0
                    ? lastCumulativeHedge * (finalSpot - lastAvgSpot)
                    : 0;
                const hedgePnL = realizedPnL + unrealizedPnL;

                // Portfolio value uses mark-to-market hedge P&L
                const portfolioValue = premiumPaid + (optionValue * baseNotional) + hedgePnL;

                results.push({
                    time: effectiveFinalTime,
                    spot: finalSpot,
                    delta: null, // No delta calculation at non-hedge time
                    incrementalHedge: null,
                    cumulativeHedge: lastCumulativeHedge, // Show position from last hedge
                    avgSpot: lastAvgSpot, // Show avg spot from last hedge
                    realizedPnL: realizedPnL,
                    unrealizedPnL: unrealizedPnL,
                    hedgePnL: hedgePnL, // Mark-to-market at current spot
                    optionValue: optionValue * baseNotional,
                    premium: premiumPaid,
                    portfolioValue: portfolioValue,
                    isHedgeTime: false
                });
            }

            return results;
        }

        function calculate() {
            console.log("=== CALCULATION START ===");

            // Parse and validate spot series
            console.log("Parsing spot series...");
            const spots = parseSpotSeries();
            if (!spots) {
                console.log("Spot parsing failed, aborting");
                return;
            }
            console.log("Spots parsed successfully:", spots.length, "values");
            console.log("First spot:", spots[0], "Last spot:", spots[spots.length - 1]);

            // Read frequencies
            const baseFreq = parseInt(document.getElementById('baseFrequency').value);
            const hedgeFreq = parseInt(document.getElementById('hedgeFrequency').value);
            console.log("Base frequency:", baseFreq, "minutes");
            console.log("Hedge frequency:", hedgeFreq, "minutes");

            // Validate: hedging frequency must be >= base frequency
            if (hedgeFreq < baseFreq) {
                showValidationMessage('Error: Hedging frequency must be greater than or equal to base data frequency', 'error');
                console.log("Validation failed: hedgeFreq < baseFreq");
                return;
            }

            // Calculate time period from number of data points
            const numPoints = spots.length;
            const numIntervals = numPoints - 1;
            const totalMinutes = numIntervals * baseFreq;
            const totalHours = totalMinutes / 60;
            const totalDays = totalHours / 24;
            const spotSeriesTimeYears = totalDays / 365;

            console.log("Spot series time period:", totalMinutes, "minutes =", totalHours, "hours =", totalDays, "days");

            // Get option expiry settings
            const expiryMode = document.querySelector('input[name="expiryMode"]:checked').value;
            let optionTenorHours, optionTenorYears, optionTenorMinutes, lastCalculationMinutes;

            if (expiryMode === 'custom') {
                const customExpiryValue = parseFloat(document.getElementById('customExpiryValue').value);
                const customExpiryUnit = document.getElementById('customExpiryUnit').value;

                if (isNaN(customExpiryValue) || customExpiryValue <= 0) {
                    showValidationMessage('Error: Option expiry must be a positive number', 'error');
                    return;
                }

                // Convert to minutes based on unit
                optionTenorMinutes = (customExpiryUnit === 'hours') ? customExpiryValue * 60 : customExpiryValue;
                optionTenorHours = optionTenorMinutes / 60;
                optionTenorYears = optionTenorMinutes / (365 * 24 * 60);

                // Update display
                lastCalculationMinutes = Math.min(totalMinutes, optionTenorMinutes);
                const timeRemainingHours = (optionTenorMinutes - totalMinutes) / 60;

                document.getElementById('spotSeriesLengthDisplay').textContent = `‚Ä¢ Spot Series Length: ${totalHours.toFixed(1)} hours`;
                if (timeRemainingHours > 0) {
                    document.getElementById('timeRemainingDisplay').textContent = `‚Ä¢ Time Remaining at End: ${timeRemainingHours.toFixed(1)} hours`;
                    document.getElementById('expiryWarning').textContent = `‚ö†Ô∏è Analysis ends with ${timeRemainingHours.toFixed(1)}h remaining. Option has not expired.`;
                    document.getElementById('expiryWarning').style.color = '#ff6600';
                } else if (timeRemainingHours < 0) {
                    const expiryTime = optionTenorMinutes;
                    document.getElementById('timeRemainingDisplay').textContent = `‚Ä¢ Time Remaining at End: 0 hours (expires at ${(expiryTime / 60).toFixed(1)}h)`;
                    document.getElementById('expiryWarning').textContent = `‚ö†Ô∏è Option expires at ${(expiryTime / 60).toFixed(1)}h. Analysis stops at expiry.`;
                    document.getElementById('expiryWarning').style.color = '#ff0000';
                } else {
                    document.getElementById('timeRemainingDisplay').textContent = `‚Ä¢ Time Remaining at End: 0 hours (expires at end)`;
                    document.getElementById('expiryWarning').textContent = '';
                }

                console.log("Option tenor:", optionTenorHours, "hours =", optionTenorYears, "years");
                console.log("Last calculation time:", lastCalculationMinutes, "minutes");
            } else {
                // Standard mode: option expires at end of spot series
                optionTenorHours = totalHours;
                optionTenorMinutes = totalMinutes;
                optionTenorYears = spotSeriesTimeYears;
                lastCalculationMinutes = totalMinutes;
                console.log("Standard mode: option expires at end of spot series");
            }

            // Calculate hedge times (up to lastCalculationMinutes)
            const hedgeTimes = calculateHedgeTimes(lastCalculationMinutes, hedgeFreq);
            console.log("Hedge times:", hedgeTimes.length, "points -", hedgeTimes);

            showValidationMessage(
                `‚úì Validated ${numPoints} spot prices at ${baseFreq}-minute intervals, representing ${totalMinutes} minutes (${totalHours.toFixed(1)} hours) of data. Hedging every ${hedgeFreq} minutes (${hedgeTimes.length} hedge points).`,
                'verification'
            );

            const volPercent = parseFloat(document.getElementById('vol').value);
            const sigma = volPercent / 100;
            console.log("Volatility:", volPercent + "%", "Sigma:", sigma);

            // Calculate realized volatility from spot series at hedging frequency
            console.log("Calculating realized volatility...");
            const realizedVol = calculateRealizedVolatility(spots, totalDays, hedgeTimes, baseFreq);
            const realizedVolPercent = realizedVol * 100;
            console.log("Realized volatility:", realizedVolPercent.toFixed(2) + "%");

            // Calculate strikes at inception
            const S0 = spots[0];
            const T0 = optionTenorYears; // Use OPTION TENOR for strike calculation, not spot series length
            console.log("Initial spot (S0):", S0, "Option tenor (T0):", T0, "years");

            console.log("Calculating standard strikes...");
            const standardStrikes = [
                { name: '10Œî Put', strike: calculateStrikeFromDelta(S0, sigma, T0, -0.10), type: 'put', isCustom: false },
                { name: '25Œî Put', strike: calculateStrikeFromDelta(S0, sigma, T0, -0.25), type: 'put', isCustom: false },
                { name: 'ATM Call', strike: S0, type: 'call', isCustom: false },
                { name: '25Œî Call', strike: calculateStrikeFromDelta(S0, sigma, T0, 0.25), type: 'call', isCustom: false },
                { name: '10Œî Call', strike: calculateStrikeFromDelta(S0, sigma, T0, 0.10), type: 'call', isCustom: false }
            ];
            console.log("Standard strikes calculated:", standardStrikes.map(s => `${s.name}: ${s.strike.toFixed(4)}`).join(', '));

            // Parse and add custom strikes
            console.log("Parsing custom strikes...");
            const customStrikes = parseCustomStrikes(S0, sigma, T0);
            if (customStrikes === null) {
                console.log("Custom strike parsing failed, aborting");
                return;
            }
            console.log("Custom strikes parsed:", customStrikes.length, "strikes");
            if (customStrikes.length > 0) {
                console.log("Custom strikes:", customStrikes.map(s => `${s.name}: ${s.strike.toFixed(4)}`).join(', '));
            }

            // Combine standard and custom strikes
            const strikes = [...standardStrikes, ...customStrikes];
            console.log("Total strikes:", strikes.length);

            // Calculate P&L for each strike with base notional = 100M / strike
            console.log("Starting P&L calculations for all strikes...");
            const allResults = strikes.map((s, idx) => {
                console.log(`Calculating strike ${idx + 1}/${strikes.length}: ${s.name} (${s.strike.toFixed(4)})`);
                const baseNotional = SETTLEMENT_NOTIONAL / s.strike;
                console.log(`  Base notional: ${(baseNotional / 1_000_000).toFixed(1)}M`);

                const result = {
                    name: s.name,
                    strike: s.strike,
                    type: s.type,
                    baseNotional: baseNotional,
                    isCustom: s.isCustom || false,
                    results: calculateStrikePnL(spots, s.strike, sigma, s.type, baseNotional, totalMinutes, hedgeTimes, baseFreq, optionTenorMinutes)
                };
                console.log(`  Calculated ${result.results.length} time points`);
                return result;
            });
            console.log("P&L calculations complete for all strikes");

            // Sort all results by strike price (ascending) for better display organization
            console.log("Sorting results by strike price...");
            allResults.sort((a, b) => a.strike - b.strike);
            console.log("Results sorted:", allResults.map(r => `${r.name}: ${r.strike.toFixed(4)}`).join(', '));

            console.log("Calling displayResults...");
            try {
                displayResults(allResults, strikes, spots, volPercent, realizedVolPercent, totalHours, totalDays, numPoints, baseFreq, hedgeFreq, hedgeTimes.length, optionTenorHours, expiryMode);
            } catch (error) {
                console.error("ERROR in displayResults:", error);
                console.error("Stack trace:", error.stack);
            }
            console.log("=== CALCULATION END ===");
        }

        function displayResults(allResults, strikes, spots, impliedVolPercent, realizedVolPercent, totalHours, totalDays, numPoints, baseFreq, hedgeFreq, numHedgePoints, optionTenorHours, expiryMode) {
            console.log("=== DISPLAY RESULTS START ===");
            console.log("allResults:", allResults.length, "strikes");

            // Diagnostic check
            if (!allResults || allResults.length === 0) {
                console.error("ERROR: No results to display!");
                return;
            }

            // Check DOM elements exist
            const strikesInfoDiv = document.getElementById('strikes-info');
            const summaryDiv = document.getElementById('summary');
            const resultsDiv = document.getElementById('results');

            console.log("DOM elements:", {
                'strikes-info': !!strikesInfoDiv,
                'summary': !!summaryDiv,
                'results': !!resultsDiv
            });

            if (!strikesInfoDiv || !summaryDiv || !resultsDiv) {
                console.error("ERROR: Required DOM elements not found!");
                return;
            }

            // Calculate spot range
            const initialSpot = spots[0];
            const finalSpot = spots[spots.length - 1];
            const volDifference = realizedVolPercent - impliedVolPercent;
            const volDifferenceSign = volDifference >= 0 ? '+' : '';
            const totalMinutes = (numPoints - 1) * baseFreq;

            // Display Analysis Summary
            console.log("Building analysis summary...");
            let analysisHTML = '<div class="verification"><strong>Analysis Summary:</strong><br>';
            analysisHTML += `‚Ä¢ Data Points: ${numPoints}<br>`;
            analysisHTML += `‚Ä¢ Base Data Frequency: ${baseFreq} minutes<br>`;
            analysisHTML += `‚Ä¢ Total Time Period: ${totalMinutes} minutes (${totalHours.toFixed(1)} hours)<br>`;

            // Add option expiry information
            if (expiryMode === 'custom') {
                analysisHTML += `‚Ä¢ <strong>Option Tenor: ${optionTenorHours.toFixed(1)} hours</strong> (custom expiry)<br>`;
                const timeRemainingHours = optionTenorHours - totalHours;
                if (timeRemainingHours > 0) {
                    analysisHTML += `‚Ä¢ Time Remaining at End: ${timeRemainingHours.toFixed(1)} hours (long-dated option)<br>`;
                } else if (timeRemainingHours < 0) {
                    analysisHTML += `‚Ä¢ Time Remaining at End: 0 hours - <strong>Option expires at ${optionTenorHours.toFixed(1)}h</strong> (short-dated option)<br>`;
                } else {
                    analysisHTML += `‚Ä¢ Time Remaining at End: 0 hours (expires at end)<br>`;
                }
            } else {
                analysisHTML += `‚Ä¢ Option Tenor: ${optionTenorHours.toFixed(1)} hours (expires at end of spot series)<br>`;
            }

            analysisHTML += `‚Ä¢ Hedging Frequency: ${hedgeFreq} minutes<br>`;
            analysisHTML += `‚Ä¢ Number of Hedges: ${numHedgePoints}<br>`;
            analysisHTML += `‚Ä¢ Spot Range: ${formatNumber(initialSpot)} ‚Üí ${formatNumber(finalSpot)}<br>`;
            analysisHTML += `‚Ä¢ Implied Volatility: ${impliedVolPercent.toFixed(2)}%<br>`;
            analysisHTML += `‚Ä¢ <strong>Realized Volatility: ${realizedVolPercent.toFixed(2)}%</strong><br>`;
            analysisHTML += `‚Ä¢ Realized vs Implied: ${volDifferenceSign}${volDifference.toFixed(2)} percentage points`;
            analysisHTML += '</div>';
            strikesInfoDiv.innerHTML = analysisHTML;
            console.log("Analysis summary set");

            // Display calculated strikes
            console.log("Building strikes HTML...");
            let strikesHTML = '<div class="verification" style="margin-top: 10px;"><strong>Calculated Strikes (with t=0 Delta):</strong><br>';
            allResults.forEach((r, idx) => {
                const initialDelta = r.results[0].delta;
                strikesHTML += `${r.name}: Strike = ${formatNumber(r.strike)}, Œî = ${formatNumber(initialDelta, 3)}`;
                if (idx < allResults.length - 1) strikesHTML += ' | ';
            });
            strikesHTML += '<br><strong>Verification:</strong> Strikes ordered: 10Œî Put &lt; 25Œî Put &lt; ATM &lt; 25Œî Call &lt; 10Œî Call</div>';
            console.log("Strikes HTML length:", strikesHTML.length);
            strikesInfoDiv.innerHTML += strikesHTML;
            console.log("Strikes HTML appended, div has", strikesInfoDiv.children.length, "children");

            // Create summary table - COLUMN-BASED LAYOUT (strikes as columns)
            console.log("Building summary table...");
            let summaryHTML = '<h2>Strike P&L Summary</h2>';

            // Calculate statistics for summary line
            let totalPnL = 0;
            const finalPnLs = [];
            allResults.forEach(r => {
                const finalPnL = r.results[r.results.length - 1].portfolioValue;
                finalPnLs.push(finalPnL);
                totalPnL += finalPnL;
            });
            const averagePnL = totalPnL / allResults.length;
            // volDifference and volDifferenceSign already calculated above (lines 1023-1024)

            // Store allResults globally for chart access
            window.strikeResultsData = allResults;
            window.chartMetadata = {
                spots: spots,
                impliedVolPercent: impliedVolPercent,
                baseFreq: baseFreq,
                hedgeFreq: hedgeFreq,
                totalMinutes: totalMinutes,
                optionTenorHours: optionTenorHours,
                expiryMode: expiryMode
            };

            // Build transposed table - strikes as columns
            summaryHTML += '<div class="strike-summary-container">';
            summaryHTML += '<table class="strike-summary"><thead><tr>';
            summaryHTML += '<th></th>'; // Empty corner cell

            // Header row: strike prices (will be made clickable via event listeners)
            allResults.forEach((r, idx) => {
                summaryHTML += `<th data-strike-idx="${idx}" class="strike-header" title="Click to view P&L chart">${formatNumber(r.strike)}</th>`;
            });
            summaryHTML += '</tr></thead><tbody>';

            // Row 1: Strike (standardized delta labels) - will be clickable
            summaryHTML += '<tr><td class="row-label"><strong>Strike</strong></td>';
            allResults.forEach((r, idx) => {
                // Get initial delta from first time point
                const initialDelta = r.results[0].delta;

                // Convert to 0-100 integer scale
                const deltaInt = Math.round(Math.abs(initialDelta) * 100);

                // Capitalize option type
                const optionTypeLabel = r.type.charAt(0).toUpperCase() + r.type.slice(1);

                // Create standardized label: "[Delta]Œî [Put/Call]"
                const strikeLabel = `${deltaInt}Œî ${optionTypeLabel}`;

                summaryHTML += `<td data-strike-idx="${idx}" class="strike-cell" title="Click to view P&L chart">${strikeLabel}</td>`;
            });
            summaryHTML += '</tr>';

            // Row 2: Final P&L (with color coding) - clickable
            // Calculate max absolute P&L for consistent color scaling within this single-pair view
            const singlePairMaxAbs = Math.max(...finalPnLs.map(pnl => Math.abs(pnl))) || 1;
            summaryHTML += '<tr><td class="row-label"><strong>Final P&L (k)</strong></td>';
            allResults.forEach((r, idx) => {
                const finalPnL = finalPnLs[idx];
                const pnlColors = getPnLColor(finalPnL, singlePairMaxAbs);
                summaryHTML += `<td data-strike-idx="${idx}" class="strike-cell" title="Click to view P&L chart" style="background-color: ${pnlColors.bg}; color: ${pnlColors.text}; font-weight: bold;">${formatThousand(finalPnL)}</td>`;
            });
            summaryHTML += '</tr>';

            summaryHTML += '</tbody></table>';
            summaryHTML += '</div>'; // Close strike-summary-container

            // Add summary statistics line
            summaryHTML += '<div class="summary-stats">';
            summaryHTML += '<strong>Summary:</strong> ';
            summaryHTML += `Average P&L: ${formatThousand(averagePnL)} | `;
            summaryHTML += `Implied Vol: ${impliedVolPercent.toFixed(2)}% | `;
            summaryHTML += `Realized Vol: ${realizedVolPercent.toFixed(2)}% | `;
            summaryHTML += `Vol Diff: ${volDifferenceSign}${volDifference.toFixed(2)}%`;
            summaryHTML += '</div>';

            console.log("Summary HTML length:", summaryHTML.length);
            summaryDiv.innerHTML = summaryHTML;
            console.log("Summary table HTML set, div has", summaryDiv.children.length, "children");

            // Attach click event listeners to strike columns
            console.log("Attaching click handlers to strike columns...");

            // Get all strike headers
            const strikeHeaders = summaryDiv.querySelectorAll('.strike-header');
            console.log("Found", strikeHeaders.length, "strike headers");

            strikeHeaders.forEach(header => {
                const strikeIdx = parseInt(header.getAttribute('data-strike-idx'));
                console.log("Attaching handler to header for strike", strikeIdx);
                header.addEventListener('click', function(e) {
                    console.log("Header clicked for strike index:", strikeIdx);
                    showStrikeChart(strikeIdx);
                });
            });

            // Get all strike cells
            const strikeCells = summaryDiv.querySelectorAll('.strike-cell');
            console.log("Found", strikeCells.length, "strike cells");

            strikeCells.forEach(cell => {
                const strikeIdx = parseInt(cell.getAttribute('data-strike-idx'));
                console.log("Attaching handler to cell for strike", strikeIdx);
                cell.addEventListener('click', function(e) {
                    console.log("Cell clicked for strike index:", strikeIdx);
                    showStrikeChart(strikeIdx);
                });
            });

            console.log("Click handlers attached successfully");

            // Create individual tables for each strike
            console.log("Building individual strike tables...");
            let resultsHTML = '';

            allResults.forEach((strikeData, idx) => {
                console.log(`  Building table for strike ${idx + 1}: ${strikeData.name}`);
                const numRows = strikeData.results.length;
                resultsHTML += `<div class="strike-section">`;
                const headerStyle = strikeData.isCustom ? 'style="color: var(--cyan); font-weight: bold;"' : '';
                resultsHTML += `<div class="strike-header" ${headerStyle}>Strike: ${formatNumber(strikeData.strike)} (${strikeData.name}) - ${numRows} Rows (Hedge Times + Final)</div>`;

                // Verification at t=0
                const t0Portfolio = strikeData.results[0].portfolioValue;
                const isValid = Math.abs(t0Portfolio) < 1;
                resultsHTML += `<div class="verification ${isValid ? '' : 'warning'}" style="font-size: 11px; padding: 8px;">`;
                resultsHTML += `<strong>t=0 Verification:</strong> Portfolio = ${formatThousand(t0Portfolio)} `;
                resultsHTML += isValid ? '‚úì' : '‚úó ERROR';
                resultsHTML += '</div>';

                // Table wrapper for scrolling
                resultsHTML += '<div class="strike-table-wrapper">';
                resultsHTML += '<table class="strike-table"><thead><tr>';
                resultsHTML += '<th>Time (min)</th><th>Spot</th><th>Delta</th>';
                resultsHTML += '<th>Incr Hedge (m)</th><th>Cum Hedge (m)</th><th>Avg Spot</th>';
                resultsHTML += '<th>Hedge P&L (k)</th><th>Option Value (k)</th><th>Premium (k)</th><th>Portfolio Value (k)</th>';
                resultsHTML += '</tr></thead><tbody>';

                strikeData.results.forEach(r => {
                    resultsHTML += '<tr>';
                    resultsHTML += `<td>${r.time}</td>`;
                    resultsHTML += `<td>${formatNumber(r.spot)}</td>`;
                    // Handle null values for non-hedge times (delta and incremental hedge only)
                    resultsHTML += `<td>${r.delta !== null ? formatNumber(r.delta, 3) : '--'}</td>`;
                    resultsHTML += `<td>${r.incrementalHedge !== null ? formatMillion(r.incrementalHedge) : '--'}</td>`;
                    // Cumulative hedge and avg spot are shown even at final time (from last hedge)
                    resultsHTML += `<td>${r.cumulativeHedge !== null ? formatMillion(r.cumulativeHedge) : '--'}</td>`;
                    resultsHTML += `<td>${r.avgSpot !== null && r.avgSpot !== 0 ? formatNumber(r.avgSpot) : '--'}</td>`;
                    // Hedge P&L is always shown (mark-to-market at current spot)
                    resultsHTML += `<td>${formatThousand(r.hedgePnL)}</td>`;
                    resultsHTML += `<td>${formatThousand(r.optionValue)}</td>`;
                    resultsHTML += `<td>${formatThousand(r.premium)}</td>`;
                    resultsHTML += `<td>${formatThousand(r.portfolioValue)}</td>`;
                    resultsHTML += '</tr>';
                });

                resultsHTML += '</tbody></table></div></div>';
            });

            console.log("Setting results HTML...");
            console.log("Results HTML length:", resultsHTML.length, "characters");
            console.log("First 200 chars of results HTML:", resultsHTML.substring(0, 200));
            resultsDiv.innerHTML = resultsHTML;
            console.log("Results HTML set successfully");
            console.log("resultsDiv now has", resultsDiv.children.length, "child elements");
            console.log("=== DISPLAY RESULTS COMPLETE ===");
        }

        // ============ CUSTOM CHART DRAWING (NO EXTERNAL DEPENDENCIES) ============

        function drawCustomChart(canvas, timePoints, premiumValues, optionValues, hedgePnLs, portfolioValues, allSpotTimes, allSpotPrices) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Margins - increased right margin for secondary Y-axis
            const margin = {top: 40, right: 90, bottom: 60, left: 70};
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            // Find min/max for P&L scaling (left Y-axis)
            const allPnLValues = [...premiumValues, ...optionValues, ...hedgePnLs, ...portfolioValues];
            const minPnL = Math.min(...allPnLValues);
            const maxPnL = Math.max(...allPnLValues);
            const pnlRange = maxPnL - minPnL;
            const pnlPadding = pnlRange * 0.1;

            // Find min/max for spot scaling (right Y-axis)
            const minSpot = Math.min(...allSpotPrices);
            const maxSpot = Math.max(...allSpotPrices);
            const spotRange = maxSpot - minSpot;
            const spotPadding = spotRange * 0.1;

            const minTime = Math.min(...timePoints);
            const maxTime = Math.max(...timePoints);
            const timeRange = maxTime - minTime;

            // Scale functions
            const xScale = (time) => margin.left + ((time - minTime) / timeRange) * chartWidth;
            const yScalePnL = (val) => margin.top + chartHeight - ((val - (minPnL - pnlPadding)) / (pnlRange + 2 * pnlPadding)) * chartHeight;
            const yScaleSpot = (val) => margin.top + chartHeight - ((val - (minSpot - spotPadding)) / (spotRange + 2 * spotPadding)) * chartHeight;

            // Draw background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, width, height);

            // Draw grid lines (for left Y-axis only)
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            const numYLines = 8;
            for (let i = 0; i <= numYLines; i++) {
                const y = margin.top + (i / numYLines) * chartHeight;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(width - margin.right, y);
                ctx.stroke();

                // Left Y-axis labels (P&L)
                const val = maxPnL + pnlPadding - (i / numYLines) * (pnlRange + 2 * pnlPadding);
                ctx.fillStyle = '#666';
                ctx.font = '11px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(val.toFixed(0) + 'k', margin.left - 10, y + 4);
            }

            // Right Y-axis labels (Spot Price)
            for (let i = 0; i <= numYLines; i++) {
                const y = margin.top + (i / numYLines) * chartHeight;
                const val = maxSpot + spotPadding - (i / numYLines) * (spotRange + 2 * spotPadding);
                ctx.fillStyle = '#666';
                ctx.font = '11px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(val.toFixed(4), width - margin.right + 10, y + 4);
            }

            // X-axis labels
            const numXLabels = 6;
            for (let i = 0; i <= numXLabels; i++) {
                const time = minTime + (i / numXLabels) * timeRange;
                const x = xScale(time);
                ctx.fillStyle = '#666';
                ctx.font = '11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(Math.round(time), x, height - margin.bottom + 20);
            }

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            // Left Y-axis
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, height - margin.bottom);
            // X-axis
            ctx.lineTo(width - margin.right, height - margin.bottom);
            // Right Y-axis
            ctx.lineTo(width - margin.right, margin.top);
            ctx.stroke();

            // Helper function to draw line on P&L scale
            function drawPnLLine(data, times, color, lineWidth = 1, dashed = false, stepped = false) {
                ctx.strokeStyle = color;
                ctx.lineWidth = lineWidth;
                if (dashed) ctx.setLineDash([5, 5]);
                else ctx.setLineDash([]);

                ctx.beginPath();
                for (let i = 0; i < times.length; i++) {
                    const x = xScale(times[i]);
                    const y = yScalePnL(data[i]);

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        if (stepped) {
                            // Step function: horizontal then vertical
                            ctx.lineTo(x, yScalePnL(data[i-1]));
                            ctx.lineTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Helper function to draw spot line on spot scale
            function drawSpotLine(spotData, spotTimes, color, lineWidth = 1.5) {
                ctx.strokeStyle = color;
                ctx.lineWidth = lineWidth;
                ctx.setLineDash([]);

                ctx.beginPath();
                for (let i = 0; i < spotTimes.length; i++) {
                    const x = xScale(spotTimes[i]);
                    const y = yScaleSpot(spotData[i]);

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            }

            // Draw spot price line FIRST (background)
            drawSpotLine(allSpotPrices, allSpotTimes, 'rgb(128, 128, 128)', 1.5);

            // Draw P&L lines (adjusted widths - thinner for emphasis on portfolio)
            drawPnLLine(premiumValues, timePoints, 'rgb(255, 99, 132)', 1, true); // Premium (1px, dashed)
            drawPnLLine(optionValues, timePoints, 'rgb(54, 162, 235)', 1); // Option Value (1px)
            drawPnLLine(hedgePnLs, timePoints, 'rgb(255, 206, 86)', 1, false, true); // Hedge P&L (1px, stepped)
            drawPnLLine(portfolioValues, timePoints, 'rgb(75, 192, 192)', 3); // Portfolio Value (3px, BOLD)

            // Add axis labels
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Time (minutes)', width / 2, height - 15);

            // Left Y-axis label
            ctx.save();
            ctx.translate(20, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('P&L (thousands)', 0, 0);
            ctx.restore();

            // Right Y-axis label
            ctx.save();
            ctx.translate(width - 20, height / 2);
            ctx.rotate(Math.PI / 2);
            ctx.fillText('Spot Price', 0, 0);
            ctx.restore();

            // Draw legend
            const legends = [
                { color: 'rgb(255, 99, 132)', text: 'Premium Paid', dashed: true, width: 1 },
                { color: 'rgb(54, 162, 235)', text: 'Option Value', dashed: false, width: 1 },
                { color: 'rgb(255, 206, 86)', text: 'Hedge P&L', dashed: false, width: 1 },
                { color: 'rgb(75, 192, 192)', text: 'Total Portfolio Value', dashed: false, width: 3 },
                { color: 'rgb(128, 128, 128)', text: 'Spot Price (right axis)', dashed: false, width: 1.5 }
            ];

            const legendX = margin.left + 20;
            const legendY = margin.top + 10;

            legends.forEach((legend, i) => {
                const y = legendY + i * 22;

                // Draw line sample
                ctx.strokeStyle = legend.color;
                ctx.lineWidth = legend.width;
                if (legend.dashed) ctx.setLineDash([5, 5]);
                else ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(legendX, y);
                ctx.lineTo(legendX + 40, y);
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw text
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(legend.text, legendX + 50, y + 4);
            });
        }

        // ============ INTERACTIVE CHART FUNCTIONS ============

        function showStrikeChart(strikeIndex) {
            console.log("=== showStrikeChart called ===");
            console.log("Strike index:", strikeIndex);

            const strikeData = window.strikeResultsData[strikeIndex];
            const metadata = window.chartMetadata;

            if (!strikeData || !metadata) {
                console.error("Strike data not available");
                return;
            }

            console.log("Data validated, proceeding with custom chart generation...");

            // Prepare chart data
            const timePoints = [];
            const premiumValues = [];
            const optionValues = [];
            const hedgePnLs = [];
            const portfolioValues = [];

            // Extract data from results
            strikeData.results.forEach(point => {
                timePoints.push(point.time);
                premiumValues.push(point.premium / 1000); // Convert to thousands
                optionValues.push(point.optionValue / 1000);
                hedgePnLs.push(point.hedgePnL / 1000);
                portfolioValues.push(point.portfolioValue / 1000);
            });

            // Calculate statistics
            const initialPortfolio = portfolioValues[0];
            const finalPortfolio = portfolioValues[portfolioValues.length - 1];
            const maxPortfolio = Math.max(...portfolioValues);
            const minPortfolio = Math.min(...portfolioValues);
            const maxTime = timePoints[portfolioValues.indexOf(maxPortfolio)];
            const minTime = timePoints[portfolioValues.indexOf(minPortfolio)];

            // Get strike label
            const initialDelta = strikeData.results[0].delta;
            const deltaInt = Math.round(Math.abs(initialDelta) * 100);
            const optionTypeLabel = strikeData.type.charAt(0).toUpperCase() + strikeData.type.slice(1);
            const strikeLabel = `${deltaInt}Œî ${optionTypeLabel}`;

            // Build chart title with option tenor info
            let chartTitle = `P&L Path - ${strikeLabel} (Strike: ${formatNumber(strikeData.strike)})`;
            if (metadata.expiryMode === 'custom') {
                chartTitle += ` - ${metadata.optionTenorHours.toFixed(1)}h Option`;
            } else {
                chartTitle += ` - ${metadata.optionTenorHours.toFixed(1)}h Option (expires at end)`;
            }

            // Update modal title
            document.getElementById('chartTitle').textContent = chartTitle;

            // Update statistics
            const statsHTML = `
                <p><strong>Initial Portfolio Value:</strong> ${formatThousand(initialPortfolio * 1000)}</p>
                <p><strong>Final Portfolio Value:</strong> ${formatThousand(finalPortfolio * 1000)}</p>
                <p><strong>Max Portfolio Value:</strong> ${formatThousand(maxPortfolio * 1000)} (at t=${maxTime} min)</p>
                <p><strong>Min Portfolio Value:</strong> ${formatThousand(minPortfolio * 1000)} (at t=${minTime} min)</p>
            `;
            document.getElementById('chartStats').innerHTML = statsHTML;

            // Prepare spot data (ALL time points at base frequency)
            const allSpotTimes = [];
            const allSpotPrices = [];
            const spots = metadata.spots;
            const baseFreq = metadata.baseFreq;

            for (let i = 0; i < spots.length; i++) {
                allSpotTimes.push(i * baseFreq);
                allSpotPrices.push(spots[i]);
            }

            // Get canvas and draw custom chart
            const canvas = document.getElementById('pnlChart');
            canvas.width = 1000;  // Set explicit dimensions for better quality
            canvas.height = 500;

            // Draw the custom chart with spot data
            drawCustomChart(canvas, timePoints, premiumValues, optionValues, hedgePnLs, portfolioValues, allSpotTimes, allSpotPrices);

            // Show modal
            console.log("Attempting to show modal...");
            const modal = document.getElementById('chartModal');
            console.log("Modal element:", modal);

            if (!modal) {
                console.error("CRITICAL: Modal element not found!");
                alert("Error: Chart modal not found. Please refresh the page.");
                return;
            }

            modal.style.display = 'block';
            console.log("Modal display set to block. Modal should now be visible.");
            console.log("Modal computed style display:", window.getComputedStyle(modal).display);
        }

        // No auto-calculate on load - wait for user input
    </script>

    <!-- Chart Modal (CSP-safe: no inline handlers) -->
    <div id="chartModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalTitle">Pair P&L Analysis</h3>
                <button class="modal-close" id="modalCloseBtn">√ó</button>
            </div>
            
            <div class="modal-body">
                <!-- Pair info -->
                <div id="modalPairInfo" class="pair-info-summary">
                    <div style="color: #888; text-align: center; padding: 20px;">Loading pair info...</div>
                </div>
                
                <!-- Chart container -->
                <div id="chartContainer" style="width: 100%; height: 500px; background: #0d0d0d; border: 1px solid #333; border-radius: 4px; position: relative;">
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #888;">Loading chart...</div>
                </div>
                
                <!-- Strike breakdown -->
                <div id="strikeBreakdown" class="strike-breakdown-table"></div>
            </div>
            
            <div class="modal-footer">
                <button class="btn btn-secondary" id="exportChartBtn">
                    üìä Export Chart as Image
                </button>
                <button class="btn btn-secondary" id="modalCloseBtnFooter">
                    Close
                </button>
            </div>
        </div>
    </div>

</body>
</html>
